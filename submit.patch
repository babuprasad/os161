diff --git a/common/libc/string/strcpy.c b/common/libc/string/strcpy.c
index 88627ed..9a51b24 100644
--- a/common/libc/string/strcpy.c
+++ b/common/libc/string/strcpy.c
@@ -47,17 +47,18 @@ strcpy(char *dest, const char *src)
 {
 	size_t i;
 
+
 	/*
 	 * Copy characters until we hit the null terminator.
 	 */
 	for (i=0; src[i]; i++) {
 		dest[i] = src[i];
 	}
-
 	/*
 	 * Add null terminator to result.
 	 */
 	dest[i] = 0;
+	//kprintf("Destination string %s\n",dest);
 
 	return dest;
 }
diff --git a/defs.mk b/defs.mk
new file mode 100644
index 0000000..9345229
--- /dev/null
+++ b/defs.mk
@@ -0,0 +1,20 @@
+# This file was generated by configure. Edits will disappear if you rerun
+# configure. If you find that you need to edit this file to make things
+# work, let the course staff know and we'll try to fix the configure script.
+#
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. If I've done it right, all you need to do is rerun the
+# configure script and make clean if you start working on a different
+# host OS. If I've done it mostly right, you may need to edit this
+# file but you still hopefully won't need to edit any of the
+# makefiles.
+#
+# The things that can be set here are documented in mk/os161.config.mk.
+#
+
+OSTREE=$(HOME)/root
+PLATFORM=sys161
+MACHINE=mips
+COMPAT_CFLAGS=
+COMPAT_TARGETS=
diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
index af393c7..03aea4c 100644
--- a/kern/arch/mips/include/vm.h
+++ b/kern/arch/mips/include/vm.h
@@ -67,6 +67,12 @@
  */
 #define PADDR_TO_KVADDR(paddr) ((paddr)+MIPS_KSEG0)
 
+/**
+ * Address translation from kernel virtual address to physical address
+ * Author : Babu
+ */
+#define KVADDR_TO_PADDR(kvaddr) ((kvaddr)-MIPS_KSEG0)
+
 /*
  * The top of user space. (Actually, the address immediately above the
  * last valid user address.)
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..2509f75 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -114,7 +114,8 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+	//panic("I don't know how to handle this\n");
+	sys__exit(0);
 }
 
 /*
@@ -394,7 +395,9 @@ mips_usermode(struct trapframe *tf)
 	 * either another thread's stack or in the kernel heap.
 	 * (Exercise: why?)
 	 */
+	//kprintf("before SAME STACK");
 	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
+	//kprintf("after SAME STACK");
 
 	/*
 	 * This actually does it. See exception.S.
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..6de47f2 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -36,6 +36,8 @@
 #include <current.h>
 #include <syscall.h>
 
+#include <endian.h>
+#include <copyinout.h>
 
 /*
  * System call dispatcher.
@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+	uint32_t retval2;
+	uint64_t ar2,ret;
+	int whence;
 	int err;
 
 	KASSERT(curthread != NULL);
@@ -98,7 +103,7 @@ syscall(struct trapframe *tf)
 	 */
 
 	retval = 0;
-
+	//kprintf("syscall number : %d\n",callno);
 	switch (callno) {
 	    case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
@@ -109,15 +114,92 @@ syscall(struct trapframe *tf)
 				 (userptr_t)tf->tf_a1);
 		break;
 
+		/**
+		 * Added by Babu : case statements for process related syscalls
+		 */
+	    case SYS_fork:
+	        err = sys_fork(&retval, tf);
+	        //kprintf("ret val : %d and err no : %d\n",retval, err);
+	    	break;
+
+	    case SYS_execv:
+	    	err = sys_execv((userptr_t)tf->tf_a0, (userptr_t *)tf->tf_a1);
+	    	break;
+
+	    case SYS__exit:
+	    	sys__exit((int)tf->tf_a0);
+	    	err = 0;
+	    	break;
+
+	    case SYS_waitpid:
+	    	err = sys_waitpid(&retval, (pid_t)tf->tf_a0, (int32_t *)tf->tf_a1, (int32_t)tf->tf_a2);
+	    	break;
+
+	    case SYS_getpid:
+	    	err = sys_getpid(&retval);
+	    	break;
+
+	    case SYS_getppid:
+	    	err = sys_getppid(&retval);
+	    	break;
+
+
 	    /* Add stuff here */
- 
+	    // File system calls - Vasanth
+	    case SYS_open:
+	    	retval = open((userptr_t)tf->tf_a0,
+	    	(int)tf->tf_a1,&err);
+	    break;
+
+   	    case SYS_close:
+			err = close(tf->tf_a0);
+			break;
+
+        case SYS_read:
+        	retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
+        	break;
+
+        case SYS_write:
+        	retval = write(tf->tf_a0,(userptr_t)tf->tf_a1, tf->tf_a2,&err);
+        	break;
+
+        case SYS_dup2:
+        	ret = dup2(tf->tf_a0,tf->tf_a1,&err);
+        	break;
+
+        case SYS_lseek:
+			join32to64(tf->tf_a2,tf->tf_a3,&ar2);
+			//kprintf("Correct lseek called\n");
+			if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0)
+			{
+				   break;
+			}
+			ret = lseek((int)tf->tf_a0,ar2,whence,&err);
+			//kprintf("ret value %llu\n",ret);
+			split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
+			//kprintf("Retval %d,%d\n",retval,retval2);
+			if (!err)
+			{
+				tf->tf_v1 = retval2;
+			}
+			break;
+
+        case SYS_chdir:
+        	err = chdir((const_userptr_t)tf->tf_a0);
+        	break;
+
+        case SYS___getcwd:
+			ret = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1,&err);
+			break;
+        case SYS_remove:
+        		err = sys_remove((userptr_t)tf->tf_a0);
+        		break;
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
 		break;
 	}
 
-
 	if (err) {
 		/*
 		 * Return the error code. This gets converted at
@@ -137,7 +219,7 @@ syscall(struct trapframe *tf)
 	 * Now, advance the program counter, to avoid restarting
 	 * the syscall over and over again.
 	 */
-	
+
 	tf->tf_epc += 4;
 
 	/* Make sure the syscall code didn't forget to lower spl */
diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
deleted file mode 100644
index ca9992a..0000000
--- a/kern/arch/mips/vm/dumbvm.c
+++ /dev/null
@@ -1,374 +0,0 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <types.h>
-#include <kern/errno.h>
-#include <lib.h>
-#include <spl.h>
-#include <spinlock.h>
-#include <thread.h>
-#include <current.h>
-#include <mips/tlb.h>
-#include <addrspace.h>
-#include <vm.h>
-
-/*
- * Dumb MIPS-only "VM system" that is intended to only be just barely
- * enough to struggle off the ground. You should replace all of this
- * code while doing the VM assignment. In fact, starting in that
- * assignment, this file is not included in your kernel!
- */
-
-/* under dumbvm, always have 48k of user stack */
-#define DUMBVM_STACKPAGES    12
-
-/*
- * Wrap rma_stealmem in a spinlock.
- */
-static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
-
-void
-vm_bootstrap(void)
-{
-	/* Do nothing. */
-}
-
-static
-paddr_t
-getppages(unsigned long npages)
-{
-	paddr_t addr;
-
-	spinlock_acquire(&stealmem_lock);
-
-	addr = ram_stealmem(npages);
-	
-	spinlock_release(&stealmem_lock);
-	return addr;
-}
-
-/* Allocate/free some kernel-space virtual pages */
-vaddr_t 
-alloc_kpages(int npages)
-{
-	paddr_t pa;
-	pa = getppages(npages);
-	if (pa==0) {
-		return 0;
-	}
-	return PADDR_TO_KVADDR(pa);
-}
-
-void 
-free_kpages(vaddr_t addr)
-{
-	/* nothing - leak the memory. */
-
-	(void)addr;
-}
-
-void
-vm_tlbshootdown_all(void)
-{
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-void
-vm_tlbshootdown(const struct tlbshootdown *ts)
-{
-	(void)ts;
-	panic("dumbvm tried to do tlb shootdown?!\n");
-}
-
-int
-vm_fault(int faulttype, vaddr_t faultaddress)
-{
-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
-	paddr_t paddr;
-	int i;
-	uint32_t ehi, elo;
-	struct addrspace *as;
-	int spl;
-
-	faultaddress &= PAGE_FRAME;
-
-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
-
-	switch (faulttype) {
-	    case VM_FAULT_READONLY:
-		/* We always create pages read-write, so we can't get this */
-		panic("dumbvm: got VM_FAULT_READONLY\n");
-	    case VM_FAULT_READ:
-	    case VM_FAULT_WRITE:
-		break;
-	    default:
-		return EINVAL;
-	}
-
-	as = curthread->t_addrspace;
-	if (as == NULL) {
-		/*
-		 * No address space set up. This is probably a kernel
-		 * fault early in boot. Return EFAULT so as to panic
-		 * instead of getting into an infinite faulting loop.
-		 */
-		return EFAULT;
-	}
-
-	/* Assert that the address space has been set up properly. */
-	KASSERT(as->as_vbase1 != 0);
-	KASSERT(as->as_pbase1 != 0);
-	KASSERT(as->as_npages1 != 0);
-	KASSERT(as->as_vbase2 != 0);
-	KASSERT(as->as_pbase2 != 0);
-	KASSERT(as->as_npages2 != 0);
-	KASSERT(as->as_stackpbase != 0);
-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
-
-	vbase1 = as->as_vbase1;
-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
-	vbase2 = as->as_vbase2;
-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
-	stacktop = USERSTACK;
-
-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
-		paddr = (faultaddress - vbase1) + as->as_pbase1;
-	}
-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
-		paddr = (faultaddress - vbase2) + as->as_pbase2;
-	}
-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
-	}
-	else {
-		return EFAULT;
-	}
-
-	/* make sure it's page-aligned */
-	KASSERT((paddr & PAGE_FRAME) == paddr);
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_read(&ehi, &elo, i);
-		if (elo & TLBLO_VALID) {
-			continue;
-		}
-		ehi = faultaddress;
-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
-		tlb_write(ehi, elo, i);
-		splx(spl);
-		return 0;
-	}
-
-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
-	splx(spl);
-	return EFAULT;
-}
-
-struct addrspace *
-as_create(void)
-{
-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
-	if (as==NULL) {
-		return NULL;
-	}
-
-	as->as_vbase1 = 0;
-	as->as_pbase1 = 0;
-	as->as_npages1 = 0;
-	as->as_vbase2 = 0;
-	as->as_pbase2 = 0;
-	as->as_npages2 = 0;
-	as->as_stackpbase = 0;
-
-	return as;
-}
-
-void
-as_destroy(struct addrspace *as)
-{
-	kfree(as);
-}
-
-void
-as_activate(struct addrspace *as)
-{
-	int i, spl;
-
-	(void)as;
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
-	}
-
-	splx(spl);
-}
-
-int
-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
-		 int readable, int writeable, int executable)
-{
-	size_t npages; 
-
-	/* Align the region. First, the base... */
-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
-	vaddr &= PAGE_FRAME;
-
-	/* ...and now the length. */
-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
-
-	npages = sz / PAGE_SIZE;
-
-	/* We don't use these - all pages are read-write */
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-
-	if (as->as_vbase1 == 0) {
-		as->as_vbase1 = vaddr;
-		as->as_npages1 = npages;
-		return 0;
-	}
-
-	if (as->as_vbase2 == 0) {
-		as->as_vbase2 = vaddr;
-		as->as_npages2 = npages;
-		return 0;
-	}
-
-	/*
-	 * Support for more than two regions is not available.
-	 */
-	kprintf("dumbvm: Warning: too many regions\n");
-	return EUNIMP;
-}
-
-static
-void
-as_zero_region(paddr_t paddr, unsigned npages)
-{
-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
-}
-
-int
-as_prepare_load(struct addrspace *as)
-{
-	KASSERT(as->as_pbase1 == 0);
-	KASSERT(as->as_pbase2 == 0);
-	KASSERT(as->as_stackpbase == 0);
-
-	as->as_pbase1 = getppages(as->as_npages1);
-	if (as->as_pbase1 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_pbase2 = getppages(as->as_npages2);
-	if (as->as_pbase2 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
-	if (as->as_stackpbase == 0) {
-		return ENOMEM;
-	}
-	
-	as_zero_region(as->as_pbase1, as->as_npages1);
-	as_zero_region(as->as_pbase2, as->as_npages2);
-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
-
-	return 0;
-}
-
-int
-as_complete_load(struct addrspace *as)
-{
-	(void)as;
-	return 0;
-}
-
-int
-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
-{
-	KASSERT(as->as_stackpbase != 0);
-
-	*stackptr = USERSTACK;
-	return 0;
-}
-
-int
-as_copy(struct addrspace *old, struct addrspace **ret)
-{
-	struct addrspace *new;
-
-	new = as_create();
-	if (new==NULL) {
-		return ENOMEM;
-	}
-
-	new->as_vbase1 = old->as_vbase1;
-	new->as_npages1 = old->as_npages1;
-	new->as_vbase2 = old->as_vbase2;
-	new->as_npages2 = old->as_npages2;
-
-	/* (Mis)use as_prepare_load to allocate some physical memory. */
-	if (as_prepare_load(new)) {
-		as_destroy(new);
-		return ENOMEM;
-	}
-
-	KASSERT(new->as_pbase1 != 0);
-	KASSERT(new->as_pbase2 != 0);
-	KASSERT(new->as_stackpbase != 0);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
-		old->as_npages1*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
-		old->as_npages2*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
-		DUMBVM_STACKPAGES*PAGE_SIZE);
-	
-	*ret = new;
-	return 0;
-}
diff --git a/kern/arch/mips/vm/dumbvm_dontuse.c b/kern/arch/mips/vm/dumbvm_dontuse.c
new file mode 100644
index 0000000..f15c4cc
--- /dev/null
+++ b/kern/arch/mips/vm/dumbvm_dontuse.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+
+/*
+ * Dumb MIPS-only "VM system" that is intended to only be just barely
+ * enough to struggle off the ground. You should replace all of this
+ * code while doing the VM assignment. In fact, starting in that
+ * assignment, this file is not included in your kernel!
+ */
+
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+void
+vm_bootstrap(void)
+{
+
+}
+
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+	
+	spinlock_release(&stealmem_lock);
+	return addr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t 
+alloc_kpages(int npages)
+{
+	paddr_t pa;
+	pa = getppages(npages);
+	if (pa==0) {
+		return 0;
+	}
+	return PADDR_TO_KVADDR(pa);
+}
+
+void 
+free_kpages(vaddr_t addr)
+{
+	/* nothing - leak the memory. */
+
+	(void)addr;
+}
+
+void
+vm_tlbshootdown_all(void)
+{
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+	paddr_t paddr;
+	int i;
+	uint32_t ehi, elo;
+	struct addrspace *as;
+	int spl;
+
+	faultaddress &= PAGE_FRAME;
+
+	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+	switch (faulttype) {
+	    case VM_FAULT_READONLY:
+		/* We always create pages read-write, so we can't get this */
+		panic("dumbvm: got VM_FAULT_READONLY\n");
+	    case VM_FAULT_READ:
+	    case VM_FAULT_WRITE:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	as = curthread->t_addrspace;
+	if (as == NULL) {
+		/*
+		 * No address space set up. This is probably a kernel
+		 * fault early in boot. Return EFAULT so as to panic
+		 * instead of getting into an infinite faulting loop.
+		 */
+		return EFAULT;
+	}
+
+	/* Assert that the address space has been set up properly. */
+	KASSERT(as->as_vbase1 != 0);
+	KASSERT(as->as_pbase1 != 0);
+	KASSERT(as->as_npages1 != 0);
+	KASSERT(as->as_vbase2 != 0);
+	KASSERT(as->as_pbase2 != 0);
+	KASSERT(as->as_npages2 != 0);
+	KASSERT(as->as_stackpbase != 0);
+	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+	vbase1 = as->as_vbase1;
+	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+	vbase2 = as->as_vbase2;
+	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+	stacktop = USERSTACK;
+
+	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+		paddr = (faultaddress - vbase1) + as->as_pbase1;
+	}
+	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+		paddr = (faultaddress - vbase2) + as->as_pbase2;
+	}
+	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+	}
+	else {
+		return EFAULT;
+	}
+
+	/* make sure it's page-aligned */
+	KASSERT((paddr & PAGE_FRAME) == paddr);
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_read(&ehi, &elo, i);
+		if (elo & TLBLO_VALID) {
+			continue;
+		}
+		ehi = faultaddress;
+		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+		tlb_write(ehi, elo, i);
+		splx(spl);
+		return 0;
+	}
+
+	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+	splx(spl);
+	return EFAULT;
+}
+
+struct addrspace *
+as_create(void)
+{
+	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+	if (as==NULL) {
+		return NULL;
+	}
+
+	as->as_vbase1 = 0;
+	as->as_pbase1 = 0;
+	as->as_npages1 = 0;
+	as->as_vbase2 = 0;
+	as->as_pbase2 = 0;
+	as->as_npages2 = 0;
+	as->as_stackpbase = 0;
+
+	return as;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+	kfree(as);
+}
+
+void
+as_activate(struct addrspace *as)
+{
+	int i, spl;
+
+	(void)as;
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+	}
+
+	splx(spl);
+}
+
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+		 int readable, int writeable, int executable)
+{
+	size_t npages; 
+
+	/* Align the region. First, the base... */
+	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+	vaddr &= PAGE_FRAME;
+
+	/* ...and now the length. */
+	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+	npages = sz / PAGE_SIZE;
+
+	/* We don't use these - all pages are read-write */
+	(void)readable;
+	(void)writeable;
+	(void)executable;
+
+	if (as->as_vbase1 == 0) {
+		as->as_vbase1 = vaddr;
+		as->as_npages1 = npages;
+		return 0;
+	}
+
+	if (as->as_vbase2 == 0) {
+		as->as_vbase2 = vaddr;
+		as->as_npages2 = npages;
+		return 0;
+	}
+
+	/*
+	 * Support for more than two regions is not available.
+	 */
+	kprintf("dumbvm: Warning: too many regions\n");
+	return EUNIMP;
+}
+
+static
+void
+as_zero_region(paddr_t paddr, unsigned npages)
+{
+	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+	KASSERT(as->as_pbase1 == 0);
+	KASSERT(as->as_pbase2 == 0);
+	KASSERT(as->as_stackpbase == 0);
+
+	as->as_pbase1 = getppages(as->as_npages1);
+	if (as->as_pbase1 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_pbase2 = getppages(as->as_npages2);
+	if (as->as_pbase2 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+	if (as->as_stackpbase == 0) {
+		return ENOMEM;
+	}
+	
+	as_zero_region(as->as_pbase1, as->as_npages1);
+	as_zero_region(as->as_pbase2, as->as_npages2);
+	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+	return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+	(void)as;
+	return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+	KASSERT(as->as_stackpbase != 0);
+
+	*stackptr = USERSTACK;
+	return 0;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+	struct addrspace *new;
+
+	new = as_create();
+	if (new==NULL) {
+		return ENOMEM;
+	}
+
+	new->as_vbase1 = old->as_vbase1;
+	new->as_npages1 = old->as_npages1;
+	new->as_vbase2 = old->as_vbase2;
+	new->as_npages2 = old->as_npages2;
+
+	/* (Mis)use as_prepare_load to allocate some physical memory. */
+	if (as_prepare_load(new)) {
+		as_destroy(new);
+		return ENOMEM;
+	}
+
+	KASSERT(new->as_pbase1 != 0);
+	KASSERT(new->as_pbase2 != 0);
+	KASSERT(new->as_stackpbase != 0);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+		old->as_npages1*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+		old->as_npages2*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+		DUMBVM_STACKPAGES*PAGE_SIZE);
+	
+	*ret = new;
+	return 0;
+}
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..64c18e0 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,6 +330,7 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
+file	  vm/vm.c
 
 optofffile dumbvm   vm/addrspace.c
 
@@ -367,6 +368,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file	  syscall/file_syscalls.c
+file	  syscall/process.c
 
 #
 # Startup and initialization
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..775ec57 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -47,6 +47,19 @@ struct vnode;
  *
  * You write this.
  */
+struct pagetable{
+	vaddr_t viraddress;
+	paddr_t phyaddress;
+	uint32_t permissions;
+	struct pagetable *next;
+};
+
+struct region{
+	vaddr_t viraddress;
+	size_t numpages;
+	uint32_t permissions;
+	struct region *next;
+};
 
 struct addrspace {
 #if OPT_DUMBVM
@@ -59,9 +72,17 @@ struct addrspace {
         paddr_t as_stackpbase;
 #else
         /* Put stuff here for your VM system */
+        struct region *reg;
+        struct pagetable *table;
+        vaddr_t sbase;
+        vaddr_t stop;
+        vaddr_t hbase;
+        vaddr_t htop;
 #endif
 };
 
+
+
 /*
  * Functions in addrspace.c:
  *
@@ -110,6 +131,8 @@ int               as_prepare_load(struct addrspace *as);
 int               as_complete_load(struct addrspace *as);
 int               as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
 
+struct pagetable * as_pagetable_entry(struct addrspace *as, vaddr_t faultaddress);
+uint32_t as_permissions(struct addrspace *as, vaddr_t faultaddress);
 
 /*
  * Functions in loadelf.c
diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
new file mode 100644
index 0000000..40e3f6c
--- /dev/null
+++ b/kern/include/fcntl.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_FCNTL_H_
+#define _KERN_FCNTL_H_
+
+/*
+ * Constants for libc's <fcntl.h>.
+ */
+
+
+/*
+ * Important
+ */
+
+/* Flags for open: choose one of these: */
+#define O_RDONLY      0      /* Open for read */
+#define O_WRONLY      1      /* Open for write */
+#define O_RDWR        2      /* Open for read and write */
+/* then or in any of these: */
+#define O_CREAT       4      /* Create file if it doesn't exist */
+#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+#define O_TRUNC      16      /* Truncate file upon open */
+#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
+
+/* Additional related definition */
+#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+
+/*
+ * Not so important
+ */
+
+/* operation codes for flock() */
+#define LOCK_SH         1       /* shared lock */
+#define LOCK_EX         2       /* exclusive lock */
+#define LOCK_UN         3       /* release the lock */
+#define LOCK_NB         4       /* flag: don't block */
+
+/*
+ * Mostly pretty useless
+ */
+
+/* fcntl() operations */
+#define F_DUPFD         0       /* like dup() but not quite */  
+#define F_GETFD         1       /* get per-handle flags */
+#define F_SETFD         2       /* set per-handle flags */
+#define F_GETFL         3       /* get per-file flags (O_* open flags) */
+#define F_SETFL         4       /* set per-file flags (O_* open flags) */
+#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
+#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
+#define F_GETLK         7       /* inspect record locks */
+#define F_SETLK         8       /* acquire record locks nonblocking */
+#define F_SETLKW        9       /* acquire record locks and wait */
+
+/* flag for F_GETFD and F_SETFD */
+#define FD_CLOEXEC      1       /* close-on-exec */
+
+/* modes for fcntl (F_GETLK/SETLK) locking */
+#define F_RDLCK         0       /* shared lock */
+#define F_WRLCK         1       /* exclusive lock */
+#define F_UNLCK         2       /* unlock */
+
+/* struct for fcntl (F_GETLK/SETLK) locking */
+struct flock {
+	off_t l_start;          /* place in file */
+	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
+	int l_type;             /* F_RDLCK or F_WRLCK */
+	off_t l_len;            /* length of locked region */
+	pid_t l_pid;            /* process that holds the lock */
+};
+
+
+#endif /* _KERN_FCNTL_H_ */
diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
index 3fad3f2..a1941ec 100644
--- a/kern/include/kern/limits.h
+++ b/kern/include/kern/limits.h
@@ -96,5 +96,11 @@
 /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
 #define __IOV_MAX       1024
 
+/* Max number of process which can run on os161*/
+#define _MAX_RUNNING_PROCS 400
+
+
+/*Maximum number of file table entry per process */
+#define _MAX_FILE 10
 
 #endif /* _KERN_LIMITS_H_ */
diff --git a/kern/include/kern/types.h b/kern/include/kern/types.h
index 002d3b7..285d626 100644
--- a/kern/include/kern/types.h
+++ b/kern/include/kern/types.h
@@ -79,6 +79,7 @@ typedef __u64 __rlim_t;    /* Resource limit quantity */
 typedef __u8 __sa_family_t;/* Socket address family */
 typedef __i64 __time_t;    /* Time in seconds */
 typedef __i32 __uid_t;     /* User ID */
+//typedef __u32 __pstate_t;  /* Physical Page State*/
 
 typedef int __nfds_t;    /* Number of file handles */
 typedef int __socklen_t;   /* Socket-related length */
diff --git a/kern/include/lib.h b/kern/include/lib.h
index da04195..78c310f 100644
--- a/kern/include/lib.h
+++ b/kern/include/lib.h
@@ -189,7 +189,9 @@ void kprintf_bootstrap(void);
  */
 
 #define DIVROUNDUP(a,b) (((a)+(b)-1)/(b))
+#define DIVROUNDDOWN(a,b) (((a)+(b)+1)/(b))
 #define ROUNDUP(a,b)    (DIVROUNDUP(a,b)*b)
+#define ROUNDDOWN(a,b)  (((a)-(b))/(b) ) //(DIVROUNDDOWN(a,b)*b)
 
 void random_yielder(uint32_t);
 void random_spinner(uint32_t);
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..81ec912 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,7 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+#define MAX_RUNNING_PROCS _MAX_RUNNING_PROCS
+#define MAX_FILE _MAX_FILE
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/process.h b/kern/include/process.h
new file mode 100644
index 0000000..fe29960
--- /dev/null
+++ b/kern/include/process.h
@@ -0,0 +1,114 @@
+/*
+ * process.h
+ *
+ *  	Created on: Mar 8, 2014
+ *      Author: Babu
+ */
+
+#ifndef PROCESS_H_
+#define PROCESS_H_
+
+#include <spinlock.h>
+
+struct trapframe;
+
+/*
+ * Process table which holds all information about the process
+ * such as pid, parent process, threads belongs to that process
+ *
+ */
+struct process {
+
+	pid_t p_pid_self;  /* process id of the process */
+
+	struct thread *p_thread;
+
+	pid_t p_pid_parent;
+
+	// Variables for process exit
+	bool p_exited;
+
+	int p_exitcode;
+
+	struct semaphore *p_exitsem;
+};
+
+
+
+/** process table as linked list */
+struct process_list
+{
+	struct process *process_info;
+	struct process_list *next;
+};
+
+struct process_list *proc_table;
+
+struct spinlock proc_lock;
+
+/**
+ * When a process exits it should invoke this method so that
+ * this will add the allocated pid to free pool which can be assigned
+ * for other process  - Added by Babu
+ */
+void add_pid_to_pool(pid_t);
+
+/**
+ * Allocate pid based on the pids available in the pool or
+ * generate from the counter if the pool is empty  - Added by Babu
+ */
+pid_t allocate_pid(void);
+
+/**
+ * function to destroy process and it related book keeping stuffs
+ */
+void process_destroy(struct process *process);
+
+
+/**
+ * getpid system call which fetches the pid of the calling process
+ */
+pid_t sys_getpid(int32_t *retval);
+
+/**
+ * getppid system call which fetches the pid of the calling process parent
+ */
+pid_t sys_getppid(int32_t *retval);
+
+/**
+ * exit system call which allows the calling process to exit
+ */
+void sys__exit(int exitcode);
+
+/**
+ * wait system call allows the calling process' parent to collect the status of child process
+ */
+int sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags);
+
+/**
+ * fork system call which creates clone of the calling process
+ */
+int sys_fork(int32_t *retval, struct trapframe *tf);
+
+/**
+ * execv system call allows create process from the file and loads into address space and executes
+ */
+int sys_execv(userptr_t prgname, userptr_t argv[]);
+
+/**
+ * Entry point function for the child process/thread created by fork()
+ */
+void child_entrypoint(void *data1, unsigned long data2);
+
+/**
+ * Find process in process table
+ */
+struct process_list * process_lookup(pid_t pid_lookup);
+
+/**
+ * Find process in process table
+ */
+void addto_proc_table(struct process *proc);
+
+
+#endif /* PROCESS_H_ */
diff --git a/kern/include/seek.h b/kern/include/seek.h
new file mode 100644
index 0000000..cf1cfe6
--- /dev/null
+++ b/kern/include/seek.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_SEEK_H_
+#define _KERN_SEEK_H_
+
+/*
+ * Codes for lseek(), which are shared in libc between <fcntl.h> and
+ * <unistd.h> and thus get their own file.
+ *
+ * These are pretty important. Back in the day (like 20+ years ago)
+ * people would often just write the values 0, 1, and 2, but that's
+ * really not recommended.
+ */
+
+#define SEEK_SET      0      /* Seek relative to beginning of file */
+#define SEEK_CUR      1      /* Seek relative to current position in file */
+#define SEEK_END      2      /* Seek relative to end of file */
+
+
+#endif /* _KERN_SEEK_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..35565c6 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        //added by vasanth
+        volatile struct thread *lock_owner;
+        struct wchan *lock_wchan;
+        struct spinlock spn_lock;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        struct wchan *cv_waitchan;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 /*
  * 13 Feb 2012 : GWA : Reader-writer locks.
  */
-
+/* we use two waiting channels one for reader and one for writer we do this so that
+ *if a writer is waiting all the readers will be put on sleep until the writers are
+ *done with their writing
+ */
 struct rwlock {
         char *rwlock_name;
+        volatile int num_reader;
+        volatile int num_writer;
+        struct wchan *rlock_wchan;
+        struct wchan *wlock_wchan;
+        struct lock *rw_lock;
+
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..52c242a 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -27,6 +27,9 @@
  * SUCH DAMAGE.
  */
 
+#include <process.h>
+
+
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
@@ -57,5 +60,13 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
-
+int open(userptr_t filename, int flags,int *err);
+int close(int fd);
+int read(int fd, userptr_t buf, size_t buflen,int *err);
+int write(int fd, userptr_t buf, size_t buflen,int *err);
+int dup2(int oldfd, int newfd,int *err);
+off_t lseek(int fd,off_t pos, int whence, int *err);
+int chdir(const_userptr_t pathname);
+int __getcwd(userptr_t buf, size_t buflen,int *err);
+int sys_remove(userptr_t p);
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..71dc1ed 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -63,16 +63,25 @@ void whalemating_cleanup(void);
  * Traffic light.
  */
 
-void inQuadrant(int);
+//volatile unsigned long intersectionOccupied = 0;
+
+/**
+* Added by Babu:
+* Locks for each quadrants
+**/
+
+
+
 void leaveIntersection(void);
 int stoplight(int, char **);
-
+void inQuadrant(int);
 void gostraight(void *, unsigned long);
 void turnleft(void *, unsigned long);
 void turnright(void *, unsigned long);
 void stoplight_init(void);
 void stoplight_cleanup(void);
 
+
 /*
  * Test code.
  */
@@ -105,7 +114,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, char *argv[],  unsigned long argc);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..31a1868 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,7 +38,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
-
+#include <limits.h>
 struct addrspace;
 struct cpu;
 struct vnode;
@@ -57,6 +57,7 @@ struct vnode;
 #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
 
 
+
 /* States a thread can be in. */
 typedef enum {
 	S_RUN,		/* running */
@@ -65,6 +66,15 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+struct fTable{
+	    char *name;
+	    int status;
+	    off_t offset;
+	    int ref_count;
+	    struct lock *lock;
+	    struct vnode *vn;
+	};
+
 /* Thread structure. */
 struct thread {
 	/*
@@ -101,9 +111,16 @@ struct thread {
 	int t_curspl;			/* Current spl*() state */
 	int t_iplhigh_count;		/* # of times IPL has been raised */
 
+
+
 	/*
 	 * Public fields
 	 */
+	/**
+	 * Added by Babu :
+	 * pointer to parent process data structure
+	 */
+	struct process *t_process;
 
 	/* VM */
 	struct addrspace *t_addrspace;	/* virtual address space */
@@ -112,8 +129,11 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
+	int priority;
 };
 
+
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
diff --git a/kern/include/types.h b/kern/include/types.h
index e031bde..a078f39 100644
--- a/kern/include/types.h
+++ b/kern/include/types.h
@@ -129,6 +129,7 @@ typedef __rlim_t rlim_t;
 typedef __sa_family_t sa_family_t;
 typedef __time_t time_t;
 typedef __uid_t uid_t;
+//typedef __pstate_t page_state_t;
 
 typedef __nfds_t nfds_t;
 typedef __socklen_t socklen_t;
diff --git a/kern/include/unistd.h b/kern/include/unistd.h
new file mode 100644
index 0000000..30f2678
--- /dev/null
+++ b/kern/include/unistd.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _KERN_UNISTD_H_
+#define _KERN_UNISTD_H_
+
+/* Constants for read/write/etc: special file handles */
+#define STDIN_FILENO  0      /* Standard input */
+#define STDOUT_FILENO 1      /* Standard output */
+#define STDERR_FILENO 2      /* Standard error */
+
+
+#endif /* _KERN_UNISTD_H_ */
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..55ae4cc 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -44,6 +44,46 @@
 #define VM_FAULT_WRITE       1    /* A write was attempted */
 #define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
 
+enum page_state
+{
+	FREE,
+	FIXED,
+	DIRTY,
+	CLEAN
+};
+
+/**
+ * CoreMap Structure for storing information
+ * about the pages in physical memory
+ *
+ * Author : Babu
+ */
+struct page
+{
+	// Address space
+	struct addrspace *addrspce;
+
+	// Virtual Address
+	vaddr_t virtual_addr;
+
+	// Physical page state (used for swapping)
+	enum page_state page_state;
+
+	// Incase of n-continuous page allocation store that information also
+	int32_t num_pages;
+
+	// For FIFO- Paging algorithm
+	uint64_t timestamp;
+
+};
+
+#define CME_SIZE (sizeof(struct page))
+
+// CoreMap
+struct page *pages;
+
+// Total Page number
+uint32_t page_num;
 
 /* Initialization function */
 void vm_bootstrap(void);
@@ -55,6 +95,14 @@ int vm_fault(int faulttype, vaddr_t faultaddress);
 vaddr_t alloc_kpages(int npages);
 void free_kpages(vaddr_t addr);
 
+/*Allocate/free user pages (called by malloc/free)*/
+vaddr_t page_alloc(void);
+vaddr_t page_nalloc(unsigned long npages);
+void page_free(vaddr_t addr);
+
+/*Make the page available by swapping or by flushing*/
+int32_t make_page_avail(struct page *page);
+
 /* TLB shootdown handling called from interprocessor_interrupt */
 void vm_tlbshootdown_all(void);
 void vm_tlbshootdown(const struct tlbshootdown *);
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..1ba112a 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,4 @@
+/*vsubrama@buffalo.edu*/
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
@@ -100,7 +101,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("babupras@buffalo.edu vsubrama@buffalo.edu 's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..71e7e2b 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -86,6 +86,8 @@ void
 cmd_progthread(void *ptr, unsigned long nargs)
 {
 	char **args = ptr;
+	//char args[] ;
+	//strcpy(args[i])
 	char progname[128];
 	int result;
 
@@ -93,14 +95,17 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	if (nargs > 2) {
 		kprintf("Warning: argument passing from menu not supported\n");
+		//kprintf("Multiple arguments passed : %d \n",(int)nargs);
 	}
 
 	/* Hope we fit. */
+	//kprintf("Passed function name %s\n",args[0]);
 	KASSERT(strlen(args[0]) < sizeof(progname));
+	strcpy(progname,args[0]);
 
-	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	//kprintf("progname : %s\n", progname);
+	result = runprogram(args[0], args, nargs);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
@@ -133,10 +138,32 @@ common_prog(int nargs, char **args)
 		"synchronization-problems kernel.\n");
 #endif
 
+	struct thread *newthread = NULL;
+	pid_t retpid ;
+	//struct thread *parentthread = curthread;
+	int status = 0 , err = 0;
+	//kprintf("before thread fork args  : %s, %s\n", args[0], args[1]);
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&newthread);
+
+	if(newthread != NULL)
+	{
+		// Parent wait
+
+		//err = waitpid(newthread->t_process->p_pid_self, &status, 1);
+		err = sys_waitpid(&retpid, newthread->t_process->p_pid_self, &status, 0);
+		if(err != 0)
+		{
+			kprintf("wait not success : %d\n", err);
+		}
+	}
+	// child wait
+	//something like this is expected please do --vasanth
+	//int s_wait;
+
+	//sys_waitpid(NULL, fork_Thread->t_process->p_pid_self,&s_wait,0);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
@@ -157,6 +184,8 @@ cmd_prog(int nargs, char **args)
 		return EINVAL;
 	}
 
+	//kprintf("cmd_prg args  : %s, %s\n", args[0], args[1]);
+
 	/* drop the leading "p" */
 	args++;
 	nargs--;
@@ -579,6 +608,8 @@ cmd_dispatch(char *cmd)
 	char *context;
 	int i, result;
 
+	//kprintf("cmd : %s\n",cmd);
+
 	for (word = strtok_r(cmd, " \t", &context);
 	     word != NULL;
 	     word = strtok_r(NULL, " \t", &context)) {
@@ -587,7 +618,9 @@ cmd_dispatch(char *cmd)
 			kprintf("Command line has too many words\n");
 			return E2BIG;
 		}
+		//kprintf("original wrd :%s\n",word);
 		args[nargs++] = word;
+		//kprintf("args :%s\n",args[nargs-1]);
 	}
 
 	if (nargs==0) {
diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
index 02e336f..05d3d21 100644
--- a/kern/synchprobs/drivers.c
+++ b/kern/synchprobs/drivers.c
@@ -148,7 +148,7 @@ inline void leaveIntersection() {
 	kprintf("%s left the intersection\n", curthread->t_name);
 }
 
-#define NCARS 99
+#define NCARS 10
 
 struct semaphore * stoplightMenuSemaphore;
 
@@ -158,12 +158,13 @@ int stoplight(int nargs, char **args) {
 	int i, direction, turn, err = 0;
 	char name[32];
 
+	kprintf("Stop light called\n");
+	stoplight_init();
 	stoplightMenuSemaphore = sem_create("Stoplight Driver Semaphore", 0);
 	if (stoplightMenuSemaphore == NULL ) {
 		panic("stoplight: sem_create failed.\n");
 	}
 
-	stoplight_init();
 
 	for (i = 0; i < NCARS; i++) {
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..3c50d3d 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -35,6 +35,33 @@
 #include <thread.h>
 #include <test.h>
 #include <synch.h>
+#include <wchan.h>
+
+/*Locks for each quadrant - Babu*/
+struct lock *lockquad0;
+struct lock *lockquad1;
+struct lock *lockquad2;
+struct lock *lockquad3;
+
+/*Get the corresponding lock for the destination quadrant */
+struct lock *getlock(int destQuadrant);
+
+struct whalemating
+{
+	volatile int num_male_whale;
+	volatile int num_female_whale;
+	volatile int num_matchmaker_whale;
+	struct wchan *male_wchan;
+	struct wchan *female_wchan;
+	struct wchan *matchmaker_wchan;
+	struct wchan *match_wchan;
+	volatile int match_found;
+	struct lock *lock;
+	volatile int match_male;
+	volatile int match_female;
+};
+struct whalemating *whale_mating;
+
 
 /*
  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
@@ -48,6 +75,61 @@
 // the top of the corresponding driver code.
 
 void whalemating_init() {
+
+
+	whale_mating = kmalloc(sizeof(struct whalemating));
+	if (whale_mating == NULL)
+	{
+		return;
+	}
+	whale_mating->male_wchan = wchan_create("name");
+	if (whale_mating->male_wchan == NULL)
+	{
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->female_wchan = wchan_create("name");
+	if (whale_mating->female_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->matchmaker_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->match_wchan = wchan_create("name");
+	if (whale_mating->matchmaker_wchan == NULL)
+		{
+			wchan_destroy(whale_mating->male_wchan);
+			wchan_destroy(whale_mating->female_wchan);
+			wchan_destroy(whale_mating->match_wchan);
+			kfree(whale_mating);
+			return;
+		}
+	whale_mating->lock = lock_create("name");
+	if (whale_mating->lock == NULL)
+	{
+		wchan_destroy(whale_mating->male_wchan);
+		wchan_destroy(whale_mating->female_wchan);
+		wchan_destroy(whale_mating->matchmaker_wchan);
+		wchan_destroy(whale_mating->match_wchan);
+		kfree(whale_mating);
+		return;
+	}
+	whale_mating->num_male_whale = 0;
+	whale_mating->num_female_whale = 0;
+	whale_mating->num_matchmaker_whale = 0;
+	whale_mating->match_found=0;
+	whale_mating->match_male=0;
+	whale_mating->match_female=0;
+
+
   return;
 }
 
@@ -55,6 +137,12 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+	wchan_destroy(whale_mating->male_wchan);
+	wchan_destroy(whale_mating->female_wchan);
+	wchan_destroy(whale_mating->matchmaker_wchan);
+	wchan_destroy(whale_mating->match_wchan);
+	lock_destroy(whale_mating->lock);
+	kfree(whale_mating);
   return;
 }
 
@@ -64,9 +152,26 @@ male(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
-  male_start();
-	// Implement this function 
-  male_end();
+ lock_acquire(whale_mating->lock);
+ male_start();
+	// Implement this function
+
+ while(whale_mating->num_male_whale>=1)
+ {
+   wchan_lock(whale_mating->male_wchan);
+   lock_release(whale_mating->lock);
+   wchan_sleep(whale_mating->male_wchan);
+   lock_acquire(whale_mating->lock);
+ }
+ whale_mating->num_male_whale++;
+ wchan_wakeall(whale_mating->match_wchan);
+ while(!(whale_mating->match_found==1))
+ {
+	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+ }
+ whale_mating->match_male=1;
+ male_end();
+ lock_release(whale_mating->lock);
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -80,32 +185,78 @@ female(void *p, unsigned long which)
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
   
+  lock_acquire(whale_mating->lock);
   female_start();
-	// Implement this function 
+
+	// Implement this function
+
+   while(whale_mating->num_female_whale>=1)
+   {
+     wchan_lock(whale_mating->female_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->female_wchan);lock_acquire(whale_mating->lock);
+   }
+   whale_mating->num_female_whale++;
+   wchan_wakeall(whale_mating->match_wchan);
+   while(!(whale_mating->match_found==1))
+   {
+  	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+   }
+  whale_mating->match_female=1;
   female_end();
-  
+  lock_release(whale_mating->lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 void
 matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+  lock_acquire(whale_mating->lock);
   matchmaker_start();
-	// Implement this function 
+  while(whale_mating->num_matchmaker_whale>=1)
+  {
+     wchan_lock(whale_mating->matchmaker_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->matchmaker_wchan);lock_acquire(whale_mating->lock);
+  }
+  whale_mating->num_matchmaker_whale++;
+  wchan_wakeall(whale_mating->match_wchan);
+  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
+  {
+	  wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
+  }
+  whale_mating->match_found=1;
+  wchan_wakeall(whale_mating->match_wchan);
+  while(whale_mating->match_male!=1 || whale_mating->match_female!=1)
+  {
+  lock_release(whale_mating->lock);
+  lock_acquire(whale_mating->lock);
+  }
+  whale_mating->match_male=0;
+  whale_mating->match_female=0;
+  whale_mating->num_male_whale--;
+  whale_mating->num_female_whale--;
+  whale_mating->num_matchmaker_whale--;
+
+  wchan_wakeall(whale_mating->male_wchan);
+  wchan_wakeall(whale_mating->female_wchan);
+  wchan_wakeall(whale_mating->matchmaker_wchan);
+
+	// Implement this function
+  whale_mating->match_found=0;
   matchmaker_end();
-  
+  lock_release(whale_mating->lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -133,27 +284,55 @@ matchmaker(void *p, unsigned long which)
  * functions in drivers.c.
  */
 
+/**
+ * Added by Babu : 27 Feb 2012
+ * Solving Stop light problem with the help
+ * of locks and predefined semaphores.
+ */
+
+
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
 void stoplight_init() {
-  return;
+
+	lockquad0 = lock_create("quad0lk");
+	lockquad1 = lock_create("quad1lk");
+	lockquad2 = lock_create("quad2lk");
+	lockquad3 = lock_create("quad3lk");
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	lock_destroy(lockquad0);
+	lock_destroy(lockquad1);
+	lock_destroy(lockquad2);
+	lock_destroy(lockquad3);
+	return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	kprintf("go straight....\n");
+
+	lock_acquire(getlock(destQuadrant1));
+	lock_acquire(getlock(destQuadrant2));
+
+	inQuadrant(destQuadrant1);
+	inQuadrant(destQuadrant2);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant2));
+	lock_release(getlock(destQuadrant1));
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -163,8 +342,24 @@ gostraight(void *p, unsigned long direction)
 void
 turnleft(void *p, unsigned long direction)
 {
+	kprintf("turn left....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+	unsigned long destQuadrant2 = (direction + 3) % 4;
+	unsigned long destQuadrant3 = (direction + 2) % 4;
+
+	lock_acquire(getlock(destQuadrant1));
+	lock_acquire(getlock(destQuadrant2));
+	lock_acquire(getlock(destQuadrant3));
+
+	inQuadrant(destQuadrant1);
+	inQuadrant(destQuadrant2);
+	inQuadrant(destQuadrant3);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant3));
+	lock_release(getlock(destQuadrant2));
+	lock_release(getlock(destQuadrant1));
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -175,11 +370,58 @@ turnleft(void *p, unsigned long direction)
 void
 turnright(void *p, unsigned long direction)
 {
+	kprintf("turn right....\n");
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+	unsigned long destQuadrant1 = direction;
+
+	lock_acquire(getlock(destQuadrant1));
+
+	inQuadrant(destQuadrant1);
+	leaveIntersection();
+
+	lock_release(getlock(destQuadrant1));
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
   return;
 }
+
+/*
+ * Added by Babu
+ * Function which serve as a wrapper to get the correct inQuadrant
+ * locks based on the direction passed
+ */
+struct lock *
+getlock(int destQuadrant)
+{
+	struct lock *lockquad;
+	switch (destQuadrant)
+	{
+		case 0:
+			lockquad = lockquad0;
+			break;
+		case 1:
+			lockquad = lockquad1;
+			break;
+		case 2:
+			lockquad = lockquad2;
+			break;
+		case 3:
+			lockquad = lockquad3;
+			break;
+		default:
+			panic("unknown direction");
+			break;
+	}
+
+	/* If the lock is not held before, then acquire it */
+	/*if(lock_do_i_hold(lockquad))
+	{
+		lock_acquire(lockquad);
+		inQuadrant(destQuadrant);
+		lock_release(lockquad);
+	}*/
+	return lockquad;
+
+}
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..01f8566
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,352 @@
+/*
+ * file_syscalls.c
+ *
+ *  Created on: Mar 8, 2014
+ *      Author: trinity
+ */
+#include <types.h>
+#include <copyinout.h>
+#include <lib.h>
+#include <thread.h>
+#include <syscall.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <fcntl.h>
+#include <current.h>
+#include <synch.h>
+
+#include <uio.h>
+#include <kern/iovec.h>
+#include <seek.h>
+#include <stat.h>
+#include <kern/errno.h>
+
+int
+open(userptr_t filename, int flags,int *err)
+{
+	char *iobuff;
+	int rFlag,vfs_ret;
+	size_t aSize;
+	if (filename == NULL)
+	{
+		*err = EFAULT;
+		 return -1;
+	}
+	int tflags = flags & O_ACCMODE;
+	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
+	{
+		kprintf("Failing in arguments\n");
+		*err = EINVAL;
+		return -1;
+	}
+	int i;
+	for ( i=0;i<OPEN_MAX;i++)
+	{
+		if (curthread->ft[i] == NULL)
+		{
+			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+			if (curthread->ft[i] == NULL)
+			{
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->lock = lock_create(curthread->t_name);
+			if (curthread->ft[i]->lock == NULL)
+			{
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			curthread->ft[i]->offset=0;
+			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+			curthread->ft[i]->status = flags;
+			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
+			if (iobuff == NULL)
+			{
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = ENOMEM;
+				return -1;
+			}
+			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
+			if(rFlag)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = EFAULT;
+				return -1;
+			}
+			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+			if(vfs_ret)
+			{
+				kfree(iobuff);
+				lock_destroy(curthread->ft[i]->lock);
+				kfree(curthread->ft[i]);
+				curthread->ft[i] = NULL;
+				*err = vfs_ret;
+				return -1;
+			}
+			*err = vfs_ret;
+			return i;
+		}
+	}
+	return 0;
+}
+int close(int fd)
+{
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		return EBADF;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		return EBADF;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+	if(curthread->ft[fd]->ref_count == 0)
+	{
+		vfs_close(curthread->ft[fd]->vn);
+		lock_release(curthread->ft[fd]->lock);
+		lock_destroy(curthread->ft[fd]->lock);
+		kfree(curthread->ft[fd]);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	else
+	{
+		lock_release(curthread->ft[fd]->lock);
+		curthread->ft[fd]=NULL;
+		return 0;
+	}
+	return 0;
+}
+
+int
+read(int fd, userptr_t buf, size_t buflen,int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_READ;
+	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err = 0;
+	return diff;
+}
+int
+write(int fd, userptr_t buf, size_t buflen, int *err)
+{
+	int ret;
+	if ( fd < 0 || fd > OPEN_MAX)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		return -1;
+	}
+	if (buf == NULL)
+	{
+		*err = EFAULT;
+		return -1;
+	}
+	lock_acquire(curthread->ft[fd]->lock);
+	struct iovec iov;
+	struct uio uio;
+	iov.iov_ubase = buf;
+	iov.iov_len = buflen;
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = curthread->ft[fd]->offset;
+	uio.uio_resid = buflen;
+	uio.uio_segflg = UIO_USERSPACE;
+	uio.uio_space = curthread->t_addrspace;
+	uio.uio_rw=UIO_WRITE;
+	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+	{
+		*err = ret;
+		return -1;
+	}
+	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+	curthread->ft[fd]->offset=uio.uio_offset;
+	lock_release(curthread->ft[fd]->lock);
+	*err=0;
+	return diff;
+}
+off_t
+lseek(int fd,off_t pos, int whence,int *err)
+{
+	off_t nPos=0;
+	struct stat eoFILE;
+	//kprintf("lseek entered\n");
+	if ( fd < 0 || fd > OPEN_MAX)
+		{
+			*err = EBADF;
+			 return -1;
+		}
+	if (curthread->ft[fd] == NULL)
+	{
+		*err = EBADF;
+		 return -1;
+	}
+	//kprintf("curthread->ft[fd] == NULL\n");
+
+	//kprintf("fd < 0 || fd > OPEN_MAX\n");
+	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
+	{
+		*err = EINVAL;
+		return -1;
+	}
+	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
+	//kprintf("Acquiring lock\n");
+	lock_acquire(curthread->ft[fd]->lock);
+	//kprintf("Stat gathering\n");
+	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+	if (whence == SEEK_SET)
+	{
+		nPos = pos;
+	}
+	if (whence == SEEK_CUR)
+	{
+		nPos = curthread->ft[fd]->offset+pos;
+	}
+	if (whence == SEEK_END)
+	{
+		nPos = eoFILE.st_size+pos;
+	}
+	if (nPos < 0)
+	{
+		*err = EINVAL;
+		lock_release(curthread->ft[fd]->lock);
+		return -1;
+	}
+	//kprintf("NPos %llu\n",nPos);
+	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+	if (*err)
+	{
+		lock_release(curthread->ft[fd]->lock);
+	    return -1;
+	}
+	curthread->ft[fd]->offset = nPos;
+	lock_release(curthread->ft[fd]->lock);
+	//kprintf("New position  %llu\n",nPos);
+	return curthread->ft[fd]->offset;
+}
+int
+dup2(int ofile_desc, int nfile_desc,int *err)
+{
+		if ( ofile_desc < 0 || ofile_desc > OPEN_MAX || nfile_desc < 0 ||
+				nfile_desc > OPEN_MAX || curthread->ft[ofile_desc] == NULL || curthread->ft[nfile_desc] == NULL)
+		{
+			*err = EBADF;
+			return -1;
+		}
+		if (curthread->ft[ofile_desc] == curthread->ft[nfile_desc] || ofile_desc == nfile_desc)
+		{
+		    return ofile_desc;
+		}
+		if (curthread->ft[nfile_desc] != NULL)
+		{
+		   *err = close(nfile_desc);
+		   if (*err)
+		      return -1;
+		}
+		curthread->ft[nfile_desc] = curthread->ft[ofile_desc];
+		lock_acquire(curthread->ft[nfile_desc]->lock);
+		curthread->ft[nfile_desc]->ref_count++;
+		lock_release(curthread->ft[nfile_desc]->lock);
+		return nfile_desc;
+}
+
+int
+chdir(const_userptr_t pathname)
+{
+	char new_path[PATH_MAX];
+	size_t get;
+
+	if (pathname == NULL)
+	{
+		return EFAULT;
+	}
+
+	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
+
+	if (ret)
+	{
+		return EFAULT;
+	}
+
+	return vfs_chdir(new_path);
+}
+int
+__getcwd(userptr_t buf, size_t buflen,int *err)
+{
+	char path[PATH_MAX];
+	struct iovec iov;
+	struct uio uio;
+	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
+	*err = vfs_getcwd(&uio);
+	if (*err)
+	{
+		return -1;
+	}
+	*err = copyout((userptr_t)path,buf,buflen);
+	if (*err)
+	{
+		return -1;
+	}
+	return uio.uio_offset;
+}
+int
+sys_remove(userptr_t p)
+{
+	char pbuf_store[PATH_MAX];
+	int err;
+
+	err = copyinstr(p, pbuf_store, sizeof(pbuf_store), NULL);
+	if (!err) {
+		return vfs_remove(pbuf_store);
+	}
+	else {
+		return err;
+	}
+}
diff --git a/kern/syscall/process.c b/kern/syscall/process.c
new file mode 100644
index 0000000..dbe5e90
--- /dev/null
+++ b/kern/syscall/process.c
@@ -0,0 +1,685 @@
+/*
+ * process.c
+ *
+ *  Created on: Mar 8, 2014
+ *  Author: Babu
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/syscall.h>
+#include <lib.h>
+#include <mips/trapframe.h>
+#include <thread.h>
+#include <current.h>
+#include <syscall.h>
+#include <addrspace.h>
+#include <spl.h>
+#include <synch.h>
+#include <limits.h>
+#include <kern/fcntl.h>
+#include <copyinout.h>
+#include <vfs.h>
+#include <kern/wait.h>
+#include <process.h>
+#include <copyinout.h>
+
+//extern struct spinlock proc_lock;
+
+/**
+ * Added by Babu:
+ * Pid pool to maintain the free available pids
+ */
+struct pid_pool
+{
+	pid_t pid_avail; // Available pid
+	struct pid_pool *next; // Point to next available pid
+};
+
+
+// Golbal PID counter
+pid_t global_pid_count = 1;
+
+/* Head and tail pointer for query and insert operation from pool which
+ * follows FIFO approach - Added by Babu
+ */
+struct pid_pool *head = NULL;
+struct pid_pool *tail = NULL;
+
+
+
+/**
+ * When a process exits it should invoke this method so that
+ * this will add the allocated pid to free pool which can be assigned
+ * for other process  - Added by Babu
+ */
+void
+add_pid_to_pool(pid_t pid_free)
+{
+	if(tail == NULL)
+	{
+		tail = kmalloc(sizeof(struct pid_pool));
+		if(tail != NULL)
+			tail->pid_avail = pid_free;
+		else
+			panic("not able to add pid");
+	}
+	else
+	{
+		tail->next = kmalloc(sizeof(struct pid_pool));
+		if(tail->next != NULL)
+		{
+			tail = tail->next;
+			tail->pid_avail = pid_free;
+		}
+	}
+	if(head == NULL)
+		head = tail;
+
+}
+
+/**
+ * Allocate pid based on the pids available in the pool or
+ * generate from the counter if the pool is empty  - Added by Babu
+ */
+pid_t
+allocate_pid()
+{
+	pid_t pid_alloc;
+	struct pid_pool *temp;
+	if(head == NULL)
+	{
+		if(global_pid_count < PID_MAX)
+			pid_alloc = global_pid_count++;
+		else
+			return ENOMEM;
+	}
+	else
+	{
+		pid_alloc = head->pid_avail;
+		temp = head;
+		if(head == tail)
+		{
+			head = NULL;
+			tail = NULL;
+		}
+		else
+			head = head->next;
+		kfree(temp);
+	}
+	return pid_alloc;
+}
+
+/**
+ * Added by Babu : 04/02/2014
+ * Function to destroy process structure
+ */
+void
+process_destroy(struct process *process)
+{
+   //int retval = -1;
+	/* Adding pid to available pool so that it can be allocated to other processes	 */
+	add_pid_to_pool(process->p_pid_self);
+	sem_destroy(process->p_exitsem);
+	//processtable[(int)process->p_pid_self] = NULL;
+	(process_lookup(process->p_pid_self))->process_info = NULL;
+
+	kfree(process);
+	return;
+}
+
+/**
+ * Added by Babu on : 04/01/2014
+ * Get pid of the calling process
+ */
+pid_t
+sys_getpid(int32_t *retval)
+{
+	if(curthread != NULL)
+	{
+		if(curthread->t_process != NULL)
+		{
+			//*retval = *curthread->t_process->p_pid_self;
+			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/**
+ * Added by Babu on : 04/01/2014
+ * Get pid of the calling process
+ */
+pid_t
+sys_getppid(int32_t *retval)
+{
+	if(curthread != NULL)
+	{
+		if(curthread->t_process != NULL)
+		{
+			//*retval = *curthread->t_process->p_pid_parent;
+			memcpy(retval, &curthread->t_process->p_pid_parent, sizeof(pid_t));
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/**
+ * Added by Babu : 04/02/2014warn
+ * Waitpid will wait for the process to change status/destroyed and collect the return status
+ * process which are not collected the return status remain as 'zombies'
+ */
+int
+sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags)
+{
+	//kprintf("Waiting for %d",pid);
+	int err = -1;
+
+	struct process *childprocess = (process_lookup(pid))->process_info;
+	if(childprocess == NULL)
+		return EFAULT;
+
+	if(pid < 1 || pid > MAX_RUNNING_PROCS)
+		return EINVAL;
+
+	if(childprocess == NULL)
+		return EINVAL;
+
+	if(exitcode == NULL)
+    	return EFAULT;
+
+    if(exitcode == (void *)0x80000000) // Kernel pointer check
+        return EFAULT;
+
+    if(exitcode == (void *)0x40000000)  // Invalid pointer check
+        return EFAULT;
+
+    int i=0;
+    char * checkptr = (char *)exitcode;
+    while(checkptr[i] != 0)
+    {
+    	checkptr++;
+    	i++;
+    }
+	if(i%4 != 0)
+		return EFAULT;
+
+	if(sizeof(checkptr)%4 != 0)
+		return EFAULT;
+
+	// if flags are not proper
+	if(flags < 0 || flags > 2)
+		return EINVAL;
+
+	// Dont wait for yourself :)
+	if(pid == curthread->t_process->p_pid_self)
+		return EFAULT;
+
+	if(pid == curthread->t_process->p_pid_parent)
+		return EFAULT;
+
+	/*Dont wait for siblings child*/
+	if(childprocess->p_pid_parent != -1)
+	{
+		if(curthread->t_process->p_pid_parent == childprocess->p_pid_parent)
+			return ECHILD;
+
+	}
+
+	if(childprocess->p_exited)
+	{
+		/*collect the exitstatus and return*/
+		//memcpy(exitcode, &childprocess->p_exitcode, sizeof(int));
+		//memcpy(retval, &childprocess->p_pid_self, sizeof(pid_t));
+		if(sizeof(*exitcode) != 4)
+			return EFAULT;
+		*exitcode =  childprocess->p_exitcode;
+		*retval = childprocess->p_pid_self;
+		process_destroy(childprocess);
+		err = 0;
+	}
+	else
+	{
+		/*else wait on sem until the thread exits then collect exit status and return*/
+		P(childprocess->p_exitsem);
+		//memcpy(exitcode, childprocess->p_exitcode, sizeof(int));
+		//memcpy(retval, childprocess->p_pid_self, sizeof(pid_t));
+		*exitcode = childprocess->p_exitcode;
+		*retval = childprocess->p_pid_self;
+		process_destroy(childprocess);
+		err = 0;
+	}
+	return err;
+}
+
+/**
+ * Added by Babu : 04/02/2014
+ * sysexit will stop the current thread execution and destroy it immediately
+ */
+void
+sys__exit(int exitstatus)
+{
+	int32_t pid = 0;
+	sys_getpid(&pid);
+	//kprintf("Exiting for %d",pid);
+	if(curthread->t_process != NULL)
+	{
+		if(!curthread->t_process->p_exited)
+		{
+			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
+			curthread->t_process->p_exited = true;
+			/**
+			 *
+			 */
+			/* Free thread structure and destroy all the thread related book keeping stuffs*/
+			//kprintf("thread exited successfully.\n");
+			thread_exit();
+		}
+	}
+
+	return;
+}
+
+/**
+ * Added by Babu on 03/09/2014:
+ *
+ * fork() creates a new process by duplicating the calling process. The new process,
+ * referred to as the child, is an exact duplicate of the calling process, referred
+ * to as the parent.
+ *
+ * return value(retval) 0 for child process and child pid for parent process
+ *
+ */
+int
+sys_fork(int32_t *retval, struct trapframe *tf)
+{
+	struct addrspace *child_addrspce = NULL;
+	struct process *child = NULL;
+//	/int spl = 0;
+	struct process *parent = NULL;
+	struct trapframe *child_trapframe = NULL;
+	int retvalfork = 0;
+	/**
+	 * Create
+	 */
+
+	parent = curthread->t_process;
+	if(parent == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+
+		//panic("parent process retrieve operation failed");
+
+	parent->p_thread = curthread;
+	//parent_trapframe = tf;
+
+	/*
+	 * Child process creation
+	 */
+	child  = kmalloc(sizeof(struct process));
+	if(child == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+		//panic("Child process creation failed");
+
+	/* Child process struct init */
+	child->p_pid_parent = parent->p_pid_self;
+	child->p_pid_self = allocate_pid();
+	child->p_exited = false;
+	child->p_exitsem = sem_create("p_exitsem", 0);
+
+	/* To protect from multiple thread generating pid same time - Babu*/
+	spinlock_acquire(&proc_lock);
+
+	child->p_pid_self = allocate_pid();
+
+	/* Assigning in process table */
+	addto_proc_table(child);
+
+	/* release lock */
+	spinlock_release(&proc_lock);
+
+	/* create a copy of trapframe using memcpy */
+	child_trapframe = kmalloc(sizeof(struct trapframe));
+	if(child_trapframe == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+	memcpy(child_trapframe, tf, sizeof(struct trapframe));
+
+	/* Addres space and file table cloning from parent */
+	as_copy(parent->p_thread->t_addrspace, &child_addrspce);
+
+	/* disable interrupts*/
+	//spl  = splhigh();
+
+	/**
+	 * copy parent trapframe to the child process
+	 * and invoke creating child thread
+	 */
+	//tf->tf_a0 = (uint32_t) child_addrspce;
+	retvalfork = thread_fork("child process", child_entrypoint, child_trapframe,(unsigned long) child_addrspce, &child->p_thread);
+	//kprintf("return value of thread_fork : %d\n",retvalfork);
+
+	/*Assigning the process structure to the thread just got created*/
+	if(child == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+	if(child->p_thread == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+
+	if(child->p_thread->t_process == NULL)
+	{
+		*retval = ENOMEM;
+		return -1;
+	}
+	child->p_thread->t_process = child;
+
+	/* Return values as child process pid */
+	*retval = child->p_pid_self;
+	//copyout(&child->p_pid_self, (userptr_t) retval, sizeof(child->p_pid_self));
+
+	/* enable interrupts again*/
+	//splx(spl);
+
+	/* Return success or error code  */
+	return retvalfork;
+
+}
+
+/**
+ * Child entry point function which will be invoked
+ * immediately after the child process creation
+ */
+void
+child_entrypoint(void *data1, unsigned long data2)
+{
+	struct trapframe tf_copy;
+	struct trapframe *child_tf = (struct trapframe *) data1;
+	struct addrspace *child_addrspce = (struct addrspace *) data2;
+
+
+	if(child_addrspce == NULL || child_tf == NULL) /* To indicate failure of child fork */
+	{
+		child_tf->tf_v0 = ENOMEM;
+		child_tf->tf_a3 = 1;
+		return;
+		//panic("child entry point failed");
+	}
+	else /* To indicate success of child fork */
+	{
+		child_tf->tf_v0 = 0;
+		child_tf->tf_a3 = 0;
+	}
+
+	/*
+	* Now, advance the program counter, to avoid restarting
+	* the syscall over and over again.
+	*/
+	child_tf->tf_epc += 4;
+
+	/** Loading child's address space into current thread address space */
+	curthread->t_addrspace = child_addrspce;
+	as_activate(curthread->t_addrspace);
+
+	/* Copy modified trap frame*/
+	memcpy(&tf_copy, child_tf, sizeof(struct trapframe));
+
+	/* And enter user mode*/
+	mips_usermode(&tf_copy);
+
+	//kprintf("user mode entered successfully /n");
+
+}
+
+
+/** *
+ * Added by Babu
+ * execv() system call creates a process by reading from ELF file and
+ * loading it into the address space.
+ *
+ */
+int
+sys_execv(userptr_t userprgname, userptr_t userargv[])
+{
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result, j=0, err, argsize= 0;
+	int argc = 0, totsize = 0 , totsizecnt = 0;
+	char *prgname = (char *)userprgname;
+	char **argv = (char **)userargv;
+
+	if(userprgname == NULL || userargv == NULL)
+		return EFAULT;
+
+	if((void *)userprgname == (void *)0x40000000 || (void *)userargv == (void *)0x40000000)
+		return EFAULT;
+
+	if((void *)userprgname == (void *)0x80000000 || (void *)userargv == (void *)0x80000000)
+		return EFAULT;
+
+	if((char *)userprgname == "\0" || (char *)userprgname == "")
+		return EINVAL;
+
+	if(*argv == "\0" || *argv == "")
+		return EINVAL;
+
+	if(strlen(prgname) == 0 || strlen(*argv) == 0)
+		return EINVAL;
+
+	if(strcmp(prgname,"\0") == 0 || strcmp(prgname,"") == 0)
+		return EINVAL;
+
+	if(strcmp(*argv,"\0") == 0 || strcmp(*argv,"") == 0)
+		return EINVAL;
+
+
+	if(argv != NULL)
+	{
+		while(argv[j] != NULL)
+		{
+			if((void *)userargv[j] == (void *)0x80000000 ||  (void *)userargv[j] == (void *)0x40000000)
+				return EFAULT;
+			argc++;
+			j++;
+		}
+	}
+
+	char *kbuf[argc];
+	int32_t *koffset[argc];
+	size_t copylen[argc];
+
+	if(argc != 0)
+	{
+
+		/**Copyin user args to kernel buffer */
+		totsizecnt = (argc + 1) * sizeof(int32_t);
+
+		j = 0;
+		if(argv != NULL)
+		{
+			while(argv[j] != NULL)
+			{
+				argsize = strlen(argv[j]) + 1;
+				totsize = argsize + (4 - (argsize % 4));
+				copylen[j] = totsize * sizeof(char);
+				kbuf[j] = kmalloc (copylen[j]);
+				koffset[j] = kmalloc(sizeof(int32_t));
+				//memcpy(kbuf[j], argv[j], argsize);
+				err = copyinstr((const_userptr_t)argv[j], kbuf[j], argsize, &copylen[j]);
+				//if(copylen[j] != (size_t)argsize)
+					//return EFAULT;
+				//if(err != 0)
+					//return err;
+
+				// Assign the offset
+				memcpy(koffset[j], &totsizecnt, sizeof(int32_t));
+				//err = copyin((userptr_t)(totsizecnt), koffset[j], sizeof(int32_t));
+				//if(err != 0)
+					//return err;
+				totsizecnt += totsize;
+				j++;
+			}
+			koffset[j] = NULL;
+		}
+		else
+			kprintf("user args null");
+
+	}
+
+	/*char *kprgname;
+	size_t copied;
+	if(prgname != NULL)
+	{
+		err = copyinstr((const_userptr_t)prgname, kprgname, strlen(prgname)+1, &copied);
+		if(copied != strlen(prgname))
+			return EFAULT;
+		if(err != 0)
+			return err;
+	}*/
+
+	/* Open the file. */
+	result = vfs_open(prgname, O_RDONLY, 0, &v);
+	if (result) {
+		return result;
+	}
+
+	/* We should be a new thread. */
+	//KASSERT(curthread->t_addrspace == NULL);
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+
+	j = 0;
+	// Starting address  of userstack from which args and pointers should be copied
+	vaddr_t initstckptr = stackptr - totsizecnt;
+	vaddr_t userstckptr = initstckptr;
+	vaddr_t userargsptr = userstckptr;
+	size_t usercopylen[argc];
+
+	if(argc != 0)
+	{
+		for(j=0; j<argc; j++)
+		{
+			userargsptr =  initstckptr + (vaddr_t)(*koffset[j]);
+
+			/* copyout user pointer (in kernel buffer) to user stack */
+			err = copyout(&userargsptr, (userptr_t)userstckptr, sizeof(int32_t));
+			if(err != 0)
+				return err;
+
+			/* Copyout user arguments (in kernel buffer) to user stack*/
+			err = copyoutstr((const char *)kbuf[j],(userptr_t)userargsptr, copylen[j], &usercopylen[j]);
+			if(err != 0)
+				return err;
+			userstckptr += sizeof(int32_t);
+
+		}
+	}
+
+	userstckptr = initstckptr;
+	while(userstckptr != initstckptr + (vaddr_t)(*koffset[0]))
+	{
+		//kprintf("user address : %x",userstckptr);
+		//kprintf("user address : %x",userargsptr);
+		//kprintf("user stack : %x\n", *(int32_t *)userstckptr);
+		userstckptr+=4;
+	}
+
+	/* Warp to user mode. */
+	//enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+		//	  stackptr, entrypoint);
+	userstckptr = initstckptr + (vaddr_t)(*koffset[0]);
+	//kprintf("user space address : %x",userstckptr);
+
+	enter_new_process(argc /*argc*/, (userptr_t)initstckptr /*userspace addr of argv (TODO userstckptr or stackptr?)*/,
+			initstckptr, entrypoint);
+
+
+	/* enter_new_process does not return. */
+	panic("enter_new_process returned\n");
+	return EINVAL;
+
+}
+
+/**
+ * Lookup process using pid in process table
+ */
+struct process_list *
+process_lookup(pid_t pid_lookup)
+{
+	struct process_list *local_ptable = proc_table;
+	while(local_ptable != NULL)
+	{
+		if(local_ptable->process_info->p_pid_self == pid_lookup)
+			return local_ptable;
+
+		local_ptable = local_ptable->next;
+	}
+
+	return NULL;
+}
+
+
+/**
+ * Add process entry to process table
+ */
+void
+addto_proc_table(struct process *proc)
+{
+	struct process_list *local_ptable = proc_table;
+	if(local_ptable == NULL)
+	{
+		proc_table = kmalloc(sizeof(struct process_list));
+		proc_table->process_info = proc;
+		proc_table->next = NULL;
+	}
+	else
+	{
+		while(local_ptable->next != NULL)
+		{
+			local_ptable = local_ptable->next;
+		}
+		local_ptable->next = kmalloc(sizeof(struct process_list));
+		local_ptable->next->process_info = proc;
+		local_ptable->next->next = NULL;
+	}
+
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..a289d6d 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,7 +44,9 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <synch.h>
+#include <unistd.h>
+#include <copyinout.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -52,13 +54,137 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname, char *argv[], unsigned long argc)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	struct vnode *o, *i, *e;
+	char *con0 = kstrdup("con:");
+	char *con1 = kstrdup("con:");
+	char *con2 = kstrdup("con:");
+	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
+	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
+	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
+	KASSERT(inpTemp!=1);
+	KASSERT(outTemp!=1);
+	KASSERT(errTemp!=1);
+
+	struct fTable *input, *output, *error;
+	input= kmalloc(sizeof(struct fTable));
+	output = kmalloc(sizeof(struct fTable));
+	error = kmalloc(sizeof(struct fTable));
+	KASSERT(input!=NULL);
+	KASSERT(output!=NULL);
+	KASSERT(error!=NULL);
+
+	input->name=kstrdup("Standard_Input");
+	input->offset=0;
+	input->ref_count =0;
+	input->status=O_RDONLY;
+	input->vn=i;
+	input->lock=lock_create("Standard Input");
+
+	output->name=kstrdup("Standard_Output");
+	output->offset=0;
+	output->ref_count =0;
+	output->status=O_WRONLY;
+	output->vn=o;
+	output->lock=lock_create("Standard Output");
+
+	error->name=kstrdup("Standard_Error");
+	error->offset=0;
+	error->ref_count =0;
+	error->status=O_WRONLY;
+	error->vn=e;
+	error->lock=lock_create("Standard Error");
+	KASSERT(input->lock!=NULL);
+	KASSERT(output->lock!=NULL);
+	KASSERT(error->lock!=NULL);
+
+	curthread->ft[STDIN_FILENO]=input;
+	curthread->ft[STDOUT_FILENO]=output;
+	curthread->ft[STDERR_FILENO]=error;
+	kfree(con0);
+	kfree(con1);
+	kfree(con2);
+	//kprintf("IO fd's initialized\n");
+
+	unsigned long j = 0;
+	int  err, argsize= 0;
+	int  totsize = 0 , totsizecnt = 0;
+
+
+
+	/*if(argv != NULL)
+	{
+		while(argv[j] != NULL)
+		{
+			argc++;
+			j++;
+		}
+	}*/
+
+
+
+	char *kbuf[argc];
+	int32_t *koffset[argc];
+	size_t copylen[argc];
+
+	if(argc != 0)
+	{
+
+		/**Copyin user args to kernel buffer */
+		totsizecnt = (argc + 1) * sizeof(int32_t);
+
+		j = 0;
+		if(argv != NULL)
+		{
+			//while(argv[j] != NULL)
+			for(j=0;j<argc; j++)
+			{
+				argsize = strlen(argv[j]) + 1;
+				totsize = argsize + (4 - (argsize % 4));
+				copylen[j] = totsize * sizeof(char);
+				kbuf[j] = kmalloc (copylen[j]);
+				koffset[j] = kmalloc(sizeof(int32_t));
+				memcpy(kbuf[j], argv[j], argsize);
+
+				//err = copyinstr((const_userptr_t)argv[j], kbuf[j], argsize, &copylen[j]);
+				//if(copylen[j] != (size_t)argsize)
+					//return EFAULT;
+				//if(err != 0)
+					//return err;
+
+				// Assign the offset
+				memcpy(koffset[j], &totsizecnt, sizeof(int32_t));
+				//err = copyin((userptr_t)(totsizecnt), koffset[j], sizeof(int32_t));
+				//if(err != 0)
+					//return err;
+				totsizecnt += totsize;
+			}
+			koffset[j] = NULL;
+		}
+		else
+			kprintf("user args null");
+
+		//char *kprgname;
+		//size_t copied;
+		//if(progname != NULL)
+		//{
+			//err = copyinstr((const_userptr_t)progname, kprgname, strlen(progname), &copied);
+			//if(copied != strlen(progname))
+				//return EFAULT;
+			//if(err != 0)
+				//return err;
+		//}
+
+	}
+
+
 	/* Open the file. */
+	kprintf("opening file : %s",progname);
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
 		return result;
@@ -81,6 +207,7 @@ runprogram(char *progname)
 	result = load_elf(v, &entrypoint);
 	if (result) {
 		/* thread_exit destroys curthread->t_addrspace */
+		kprintf("Load ELF error\n");
 		vfs_close(v);
 		return result;
 	}
@@ -95,9 +222,50 @@ runprogram(char *progname)
 		return result;
 	}
 
+	j = 0;
+	// Starting address  of userstack from which args and pointers should be copied
+	vaddr_t initstckptr = stackptr - totsizecnt;
+	vaddr_t userstckptr = initstckptr;
+	vaddr_t userargsptr = userstckptr;
+	size_t usercopylen[argc];
+
+	if(argc != 0)
+	{
+		for(j=0; j<argc; j++)
+		{
+			userargsptr =  initstckptr + (vaddr_t)(*koffset[j]);
+
+			/* copyout user pointer (in kernel buffer) to user stack */
+			err = copyout(&userargsptr, (userptr_t)userstckptr, sizeof(int32_t));
+			if(err != 0)
+				return err;
+
+			/* Copyout user arguments (in kernel buffer) to user stack*/
+			err = copyoutstr((const char *)kbuf[j],(userptr_t)userargsptr, copylen[j], &usercopylen[j]);
+			if(err != 0)
+				return err;
+			userstckptr += sizeof(int32_t);
+
+		}
+	}
+
+	userstckptr = initstckptr;
+	while(userstckptr != initstckptr + (vaddr_t)(*koffset[0]))
+	{
+		//kprintf("user address : %x",userstckptr);
+		//kprintf("user address : %x",userargsptr);
+		//kprintf("user stack : %x\n", *(int32_t *)userstckptr);
+		userstckptr+=4;
+	}
+
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
-			  stackptr, entrypoint);
+	//enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+		//	  stackptr, entrypoint);
+	userstckptr = initstckptr + (vaddr_t)(*koffset[0]);
+	//kprintf("user space address : %x",userstckptr);
+
+	enter_new_process(argc /*argc*/, (userptr_t)initstckptr /*userspace addr of argv (TODO userstckptr or stackptr?)*/,
+			initstckptr, entrypoint);
 	
 	/* enter_new_process does not return. */
 	panic("enter_new_process returned\n");
diff --git a/kern/t_addrspace b/kern/t_addrspace
new file mode 100644
index 0000000..80766b6
--- /dev/null
+++ b/kern/t_addrspace
@@ -0,0 +1,239 @@
+Binary file compile/ASST1/trap.o matches
+Binary file compile/ASST1/main.o matches
+Binary file compile/ASST1/uio.o matches
+Binary file compile/ASST1/lamebus_machdep.o matches
+Binary file compile/ASST1/runprogram.o matches
+Binary file compile/ASST1/synch.o matches
+Binary file compile/ASST1/thread.o matches
+Binary file compile/ASST1/console.o matches
+Binary file compile/ASST1/kernel matches
+Binary file compile/ASST1/syscall.o matches
+Binary file compile/ASST2/trap.o matches
+Binary file compile/ASST2/main.o matches
+Binary file compile/ASST2/uio.o matches
+Binary file compile/ASST2/lamebus_machdep.o matches
+Binary file compile/ASST2/runprogram.o matches
+Binary file compile/ASST2/synch.o matches
+Binary file compile/ASST2/thread.o matches
+Binary file compile/ASST2/console.o matches
+Binary file compile/ASST2/kernel matches
+Binary file compile/ASST2/syscall.o matches
+Binary file compile/ASST3/trap.o matches
+Binary file compile/ASST3/main.o matches
+Binary file compile/ASST3/uio.o matches
+Binary file compile/ASST3/lamebus_machdep.o matches
+Binary file compile/ASST3/runprogram.o matches
+Binary file compile/ASST3/synch.o matches
+Binary file compile/ASST3/thread.o matches
+Binary file compile/ASST3/console.o matches
+Binary file compile/ASST3/kernel matches
+Binary file compile/ASST3/syscall.o matches
+Binary file compile/ASST0/trap.o matches
+Binary file compile/ASST0/main.o matches
+Binary file compile/ASST0/uio.o matches
+Binary file compile/ASST0/lamebus_machdep.o matches
+Binary file compile/ASST0/runprogram.o matches
+Binary file compile/ASST0/synch.o matches
+Binary file compile/ASST0/thread.o matches
+Binary file compile/ASST0/console.o matches
+Binary file compile/ASST0/kernel matches
+Binary file compile/ASST0/syscall.o matches
+arch/mips/vm/dumbvm_dontuse.c:	as = curthread->t_addrspace;
+arch/mips/thread/cpu.c:	if (c->c_curthread->t_stack == NULL) {
+arch/mips/thread/cpu.c:		stackpointer = (vaddr_t) c->c_curthread->t_stack;
+arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
+arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
+arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
+arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
+arch/mips/locore/trap.c:	if (curthread != NULL && curthread->t_stack != NULL) {
+arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf > (vaddr_t)curthread->t_stack);
+arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf < (vaddr_t)(curthread->t_stack
+arch/mips/locore/trap.c:		old_in = curthread->t_in_interrupt;
+arch/mips/locore/trap.c:		curthread->t_in_interrupt = 1;
+arch/mips/locore/trap.c:		if (curthread->t_curspl == 0) {
+arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == 0);
+arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 0);
+arch/mips/locore/trap.c:			curthread->t_curspl = IPL_HIGH;
+arch/mips/locore/trap.c:			curthread->t_iplhigh_count++;
+arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == IPL_HIGH);
+arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 1);
+arch/mips/locore/trap.c:			curthread->t_iplhigh_count--;
+arch/mips/locore/trap.c:			curthread->t_curspl = 0;
+arch/mips/locore/trap.c:		curthread->t_in_interrupt = old_in;
+arch/mips/locore/trap.c:		KASSERT(curthread->t_curspl == 0);
+arch/mips/locore/trap.c:		KASSERT(curthread->t_iplhigh_count == 0);
+arch/mips/locore/trap.c:	    curthread->t_machdep.tm_badfaultfunc != NULL) {
+arch/mips/locore/trap.c:		tf->tf_epc = (vaddr_t) curthread->t_machdep.tm_badfaultfunc;
+arch/mips/locore/trap.c:	if (curthread->t_stack == NULL) {
+arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
+arch/mips/locore/trap.c:	 *   (1) curthread->t_stack is corrupted, or
+arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
+arch/mips/include/current.h: * make curcpu be curthread->t_cpu.
+arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
+arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
+lib/uio.c:		KASSERT(uio->uio_space == curthread->t_addrspace);
+lib/kprintf.c:		&& curthread->t_in_interrupt == false
+lib/kprintf.c:		&& curthread->t_iplhigh_count == 0;
+vm/copyinout.c:	longjmp(curthread->t_machdep.tm_copyjmp, 1);
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
+vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
+vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
+vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
+vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
+vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
+vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
+vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
+vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
+vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
+thread/spl.c: * curthread->t_iplhigh_count is used to track this.
+thread/synch.c:        KASSERT(curthread->t_in_interrupt == false);
+thread/thread.c:		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
+thread/thread.c:		 * Leave c->c_curthread->t_stack NULL for the boot
+thread/thread.c:		/*c->c_curthread->t_stack = ... */
+thread/thread.c:		c->c_curthread->t_stack = kmalloc(STACK_SIZE);
+thread/thread.c:		if (c->c_curthread->t_stack == NULL) {
+thread/thread.c:	c->c_curthread->t_cpu = c;
+thread/thread.c:	curthread->t_cpu = curcpu;
+thread/thread.c:	newthread->t_cpu = curthread->t_cpu;
+thread/thread.c:	if (curthread->t_cwd != NULL) {
+thread/thread.c:		VOP_INCREF(curthread->t_cwd);
+thread/thread.c:		newthread->t_cwd = curthread->t_cwd;
+thread/thread.c:		newthread->ft[i] = curthread->ft[i];
+thread/thread.c:		if ( curthread->ft[i] !=0)
+thread/thread.c:			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
+thread/thread.c:	DEBUGASSERT(curthread->t_cpu == curcpu->c_self);
+thread/thread.c:		if (curthread->ft[i] !=  NULL)
+thread/thread.c:	//if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
+thread/thread.c:		V(curthread->t_process->p_exitsem);
+thread/thread.c:	KASSERT(!curthread->t_in_interrupt);
+syscall/process.c:		if(curthread->t_process != NULL)
+syscall/process.c:			//*retval = *curthread->t_process->p_pid_self;
+syscall/process.c:			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
+syscall/process.c:		if(curthread->t_process != NULL)
+syscall/process.c:			//*retval = *curthread->t_process->p_pid_parent;
+syscall/process.c:			memcpy(retval, &curthread->t_process->p_pid_parent, sizeof(pid_t));
+syscall/process.c:	if(pid == curthread->t_process->p_pid_self)
+syscall/process.c:	if(pid == curthread->t_process->p_pid_parent)
+syscall/process.c:		if(curthread->t_process->p_pid_parent == childprocess->p_pid_parent)
+syscall/process.c:	if(curthread->t_process != NULL)
+syscall/process.c:		if(!curthread->t_process->p_exited)
+syscall/process.c:			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
+syscall/process.c:			curthread->t_process->p_exited = true;
+syscall/process.c:	parent = curthread->t_process;
+syscall/process.c:	curthread->t_addrspace = child_addrspce;
+syscall/process.c:	as_activate(curthread->t_addrspace);
+syscall/process.c:	//KASSERT(curthread->t_addrspace == NULL);
+syscall/process.c:	curthread->t_addrspace = as_create();
+syscall/process.c:	if (curthread->t_addrspace==NULL) {
+syscall/process.c:	as_activate(curthread->t_addrspace);
+syscall/process.c:		/* thread_exit destroys curthread->t_addrspace */
+syscall/process.c:	result = as_define_stack(curthread->t_addrspace, &stackptr);
+syscall/process.c:		/* thread_exit destroys curthread->t_addrspace */
+syscall/loadelf.c:	u.uio_space = curthread->t_addrspace;
+syscall/loadelf.c:		result = as_define_region(curthread->t_addrspace,
+syscall/loadelf.c:	result = as_prepare_load(curthread->t_addrspace);
+syscall/loadelf.c:	result = as_complete_load(curthread->t_addrspace);
+syscall/file_syscalls.c:		if (curthread->ft[i] == NULL)
+syscall/file_syscalls.c:			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+syscall/file_syscalls.c:			if (curthread->ft[i] == NULL)
+syscall/file_syscalls.c:			curthread->ft[i]->lock = lock_create(curthread->t_name);
+syscall/file_syscalls.c:			if (curthread->ft[i]->lock == NULL)
+syscall/file_syscalls.c:				kfree(curthread->ft[i]);
+syscall/file_syscalls.c:				curthread->ft[i] = NULL;
+syscall/file_syscalls.c:			curthread->ft[i]->offset=0;
+syscall/file_syscalls.c:			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+syscall/file_syscalls.c:			curthread->ft[i]->status = flags;
+syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
+syscall/file_syscalls.c:				kfree(curthread->ft[i]);
+syscall/file_syscalls.c:				curthread->ft[i] = NULL;
+syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
+syscall/file_syscalls.c:				kfree(curthread->ft[i]);
+syscall/file_syscalls.c:				curthread->ft[i] = NULL;
+syscall/file_syscalls.c:			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
+syscall/file_syscalls.c:				kfree(curthread->ft[i]);
+syscall/file_syscalls.c:				curthread->ft[i] = NULL;
+syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
+syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+syscall/file_syscalls.c:	if(curthread->ft[fd]->ref_count == 0)
+syscall/file_syscalls.c:		vfs_close(curthread->ft[fd]->vn);
+syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:		lock_destroy(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:		kfree(curthread->ft[fd]);
+syscall/file_syscalls.c:		curthread->ft[fd]=NULL;
+syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:		curthread->ft[fd]=NULL;
+syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
+syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	uio.uio_offset = curthread->ft[fd]->offset;
+syscall/file_syscalls.c:	uio.uio_space = curthread->t_addrspace;
+syscall/file_syscalls.c:	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+syscall/file_syscalls.c:	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+syscall/file_syscalls.c:	curthread->ft[fd]->offset=uio.uio_offset;
+syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
+syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	uio.uio_offset = curthread->ft[fd]->offset;
+syscall/file_syscalls.c:	uio.uio_space = curthread->t_addrspace;
+syscall/file_syscalls.c:	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+syscall/file_syscalls.c:	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+syscall/file_syscalls.c:	curthread->ft[fd]->offset=uio.uio_offset;
+syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
+syscall/file_syscalls.c:	//kprintf("curthread->ft[fd] == NULL\n");
+syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+syscall/file_syscalls.c:		nPos = curthread->ft[fd]->offset+pos;
+syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	curthread->ft[fd]->offset = nPos;
+syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
+syscall/file_syscalls.c:	return curthread->ft[fd]->offset;
+syscall/file_syscalls.c:				nfile_desc > OPEN_MAX || curthread->ft[ofile_desc] == NULL || curthread->ft[nfile_desc] == NULL)
+syscall/file_syscalls.c:		if (curthread->ft[ofile_desc] == curthread->ft[nfile_desc] || ofile_desc == nfile_desc)
+syscall/file_syscalls.c:		if (curthread->ft[nfile_desc] != NULL)
+syscall/file_syscalls.c:		curthread->ft[nfile_desc] = curthread->ft[ofile_desc];
+syscall/file_syscalls.c:		lock_acquire(curthread->ft[nfile_desc]->lock);
+syscall/file_syscalls.c:		curthread->ft[nfile_desc]->ref_count++;
+syscall/file_syscalls.c:		lock_release(curthread->ft[nfile_desc]->lock);
+syscall/runprogram.c:	curthread->ft[STDIN_FILENO]=input;
+syscall/runprogram.c:	curthread->ft[STDOUT_FILENO]=output;
+syscall/runprogram.c:	curthread->ft[STDERR_FILENO]=error;
+syscall/runprogram.c:	KASSERT(curthread->t_addrspace == NULL);
+syscall/runprogram.c:	curthread->t_addrspace = as_create();
+syscall/runprogram.c:	if (curthread->t_addrspace==NULL) {
+syscall/runprogram.c:	as_activate(curthread->t_addrspace);
+syscall/runprogram.c:		/* thread_exit destroys curthread->t_addrspace */
+syscall/runprogram.c:	result = as_define_stack(curthread->t_addrspace, &stackptr);
+syscall/runprogram.c:		/* thread_exit destroys curthread->t_addrspace */
+synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
+synchprobs/drivers.c:	kprintf("%s in quadrant %d\n", curthread->t_name, quadrant);
+synchprobs/drivers.c:	kprintf("%s left the intersection\n", curthread->t_name);
+startup/main.c:	KASSERT(curthread->t_curspl > 0);
+startup/main.c:	KASSERT(curthread->t_curspl == 0);
+vfs/vfscwd.c: * We do not synchronize curthread->t_cwd, because it belongs exclusively
+vfs/vfscwd.c:	if (curthread->t_cwd!=NULL) {
+vfs/vfscwd.c:		VOP_INCREF(curthread->t_cwd);
+vfs/vfscwd.c:		*ret = curthread->t_cwd;
+vfs/vfscwd.c:	old = curthread->t_cwd;
+vfs/vfscwd.c:	curthread->t_cwd = dir;
+vfs/vfscwd.c:	old = curthread->t_cwd;
+vfs/vfscwd.c:	curthread->t_cwd = NULL;
+include/current.h:#define curcpu curthread->t_cpu
+dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
+dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
+dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
+dev/generic/console.c:	KASSERT(!curthread->t_in_interrupt && curthread->t_iplhigh_count == 0);
diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
index b4dd87c..dd298d9 100644
--- a/kern/test/malloctest.c
+++ b/kern/test/malloctest.c
@@ -98,6 +98,8 @@ malloctest(int nargs, char **args)
 
 	kprintf("Starting kmalloc test...\n");
 	mallocthread(NULL, 0);
+	//int *chumma = kmalloc(997);
+	//*chumma = 32;
 	kprintf("kmalloc test done\n");
 
 	return 0;
diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
index d072469..f106f4a 100644
--- a/kern/test/synchtest.c
+++ b/kern/test/synchtest.c
@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
 {
 	int i;
 	(void)junk;
-
 	for (i=0; i<NCVLOOPS; i++) {
 		lock_acquire(testlock);
 		while (testval1 != num) {
-      testval2 = 0;
+			testval2 = 0;
+
 			cv_wait(testcv, testlock);
-      testval2 = 0xFFFFFFFF;
+			testval2 = 0xFFFFFFFF;
 		}
 		testval2 = num;
+
 		cv_broadcast(testcv, testlock);
 		thread_yield();
 		kprintf("Thread %lu\n", testval2);
 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
 		lock_release(testlock);
 	}
+	kprintf("cv2 test exiting\n");
 	V(donesem);
 }
 
@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
 	for (i=0; i<NTHREADS; i++) {
 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
 				      NULL);
+		//kprintf("Thread fork failure\n");
 		if (result) {
 			panic("cvtest: thread_fork failed: %s\n",
 			      strerror(result));
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..229bc82 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -47,20 +47,20 @@
 struct semaphore *
 sem_create(const char *name, int initial_count)
 {
-        struct semaphore *sem;
+	struct semaphore *sem;
 
-        KASSERT(initial_count >= 0);
+	KASSERT(initial_count >= 0);
 
-        sem = kmalloc(sizeof(struct semaphore));
-        if (sem == NULL) {
-                return NULL;
-        }
+	sem = kmalloc(sizeof(struct semaphore));
+	if (sem == NULL) {
+			return NULL;
+	}
 
-        sem->sem_name = kstrdup(name);
-        if (sem->sem_name == NULL) {
-                kfree(sem);
-                return NULL;
-        }
+	sem->sem_name = kstrdup(name);
+	if (sem->sem_name == NULL) {
+			kfree(sem);
+			return NULL;
+	}
 
 	sem->sem_wchan = wchan_create(sem->sem_name);
 	if (sem->sem_wchan == NULL) {
@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
 	}
 
 	spinlock_init(&sem->sem_lock);
-        sem->sem_count = initial_count;
+    sem->sem_count = initial_count;
 
-        return sem;
+    return sem;
 }
 
 void
@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
         KASSERT(sem != NULL);
 
 	/* wchan_cleanup will assert if anyone's waiting on it */
-	spinlock_cleanup(&sem->sem_lock);
-	wchan_destroy(sem->sem_wchan);
+		spinlock_cleanup(&sem->sem_lock);
+		wchan_destroy(sem->sem_wchan);
         kfree(sem->sem_name);
         kfree(sem);
 }
@@ -100,7 +100,7 @@ P(struct semaphore *sem)
          */
         KASSERT(curthread->t_in_interrupt == false);
 
-	spinlock_acquire(&sem->sem_lock);
+        spinlock_acquire(&sem->sem_lock);
         while (sem->sem_count == 0) {
 		/*
 		 * Bridge to the wchan lock, so if someone else comes
@@ -120,24 +120,22 @@ P(struct semaphore *sem)
 		 */
 		wchan_lock(sem->sem_wchan);
 		spinlock_release(&sem->sem_lock);
-                wchan_sleep(sem->sem_wchan);
-
+        wchan_sleep(sem->sem_wchan);
 		spinlock_acquire(&sem->sem_lock);
-        }
-        KASSERT(sem->sem_count > 0);
-        sem->sem_count--;
+	}
+	KASSERT(sem->sem_count > 0);
+	sem->sem_count--;
 	spinlock_release(&sem->sem_lock);
 }
 
 void
 V(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
-
-	spinlock_acquire(&sem->sem_lock);
+    KASSERT(sem != NULL);
+	spinlock_acquire(&sem->sem_lock); 
 
-        sem->sem_count++;
-        KASSERT(sem->sem_count > 0);
+	sem->sem_count++;
+	KASSERT(sem->sem_count > 0);
 	wchan_wakeone(sem->sem_wchan);
 
 	spinlock_release(&sem->sem_lock);
@@ -158,20 +156,36 @@ lock_create(const char *name)
         }
 
         lock->lk_name = kstrdup(name);
+
         if (lock->lk_name == NULL) {
                 kfree(lock);
                 return NULL;
         }
-        
+
+        //added by vasanth
+        lock->lock_owner=NULL;
+        lock->lock_wchan = wchan_create(lock->lk_name);
+		if (lock->lock_wchan == NULL)
+		{
+			kfree(lock->lk_name);
+			kfree(lock);
+			return NULL;
+		}
+		spinlock_init(&lock->spn_lock);
+
         // add stuff here as needed
-        
         return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
+
         KASSERT(lock != NULL);
+        //added by vasanth
+        //KASSERT(lock->lock_owner == NULL);
+        spinlock_cleanup(&lock->spn_lock);
+        wchan_destroy(lock->lock_wchan);
 
         // add stuff here as needed
         
@@ -182,27 +196,64 @@ lock_destroy(struct lock *lock)
 void
 lock_acquire(struct lock *lock)
 {
+		//added by vasanth
+		KASSERT(lock != NULL);
+		if(!lock_do_i_hold(lock))
+		{
+			spinlock_acquire(&lock->spn_lock);
+			while (lock->lock_owner!=NULL)
+			{
+				wchan_lock(lock->lock_wchan);
+				spinlock_release(&lock->spn_lock);
+				wchan_sleep(lock->lock_wchan);
+				spinlock_acquire(&lock->spn_lock);
+			}
+			lock->lock_owner=curthread;
+			spinlock_release(&lock->spn_lock);
+		}
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+       // (void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+		//added by vasanth
+ 		KASSERT(lock != NULL);
+		spinlock_acquire(&lock->spn_lock);
+		if(lock->lock_owner==curthread)
+		{
+			lock->lock_owner=NULL;
+			wchan_wakeall(lock->lock_wchan);
+		}
+		spinlock_release(&lock->spn_lock);
+		// Write this
+
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+		bool status;
+		spinlock_acquire(&lock->spn_lock);
+		if (lock->lock_owner==curthread)
+		{
+			status = true;
+		}
+		else
+		{
+			status = false;
+		}
+		spinlock_release(&lock->spn_lock);
+		return status;
+
+        //(void)lock;  // suppress warning until code gets written
+
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -217,26 +268,36 @@ cv_create(const char *name)
 
         cv = kmalloc(sizeof(struct cv));
         if (cv == NULL) {
-                return NULL;
+        	return NULL;
         }
 
         cv->cv_name = kstrdup(name);
         if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
+            kfree(cv);
+            return NULL;
         }
         
         // add stuff here as needed
+        /* Added by Babu :
+        * Adding a wait channel for making the threads wait during cv_acquire
+        */
+        cv->cv_waitchan = wchan_create(cv->cv_name);
+
         
         return cv;
 }
 
+
 void
 cv_destroy(struct cv *cv)
 {
         KASSERT(cv != NULL);
 
         // add stuff here as needed
+        /*
+         * Added by Babu : wchan destructor
+         */
+        wchan_destroy(cv->cv_waitchan);
         
         kfree(cv->cv_name);
         kfree(cv);
@@ -245,23 +306,158 @@ cv_destroy(struct cv *cv)
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+    // Write this
+	/** Release lock, wait and then acquire once awake */
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	wchan_lock(cv->cv_waitchan);
+	if(lock_do_i_hold(lock))
+			lock_release(lock);
+	wchan_sleep(cv->cv_waitchan);
+
+	if(!lock_do_i_hold(lock))
+		lock_acquire(lock);
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+    // Write this
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+
+
+	//kprintf("Signaling CV\n");
+
+	wchan_wakeone(cv->cv_waitchan);
+	//wchan_unlock(cv->cv_waitchan);
+
+
+
+	(void) lock;
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv != NULL);
+	KASSERT(lock != NULL);
+
+	wchan_wakeall(cv->cv_waitchan);
+
+	(void) lock;
+}
+
+struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rwlock;
+	rwlock = kmalloc(sizeof(struct rwlock));
+	if (rwlock == NULL)
+	{
+		return NULL;
+	}
+	rwlock->rwlock_name=kstrdup(name);
+	if (rwlock->rwlock_name == NULL)
+	{
+	    kfree(rwlock);
+	    return NULL;
+	}
+	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->rlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
+	if (rwlock->wlock_wchan == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	rwlock->num_reader=0;
+	rwlock->num_writer=0;
+	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
+	if (rwlock->rw_lock == NULL)
+	{
+		kfree(rwlock->rwlock_name);
+		wchan_destroy(rwlock->rlock_wchan);
+		wchan_destroy(rwlock->wlock_wchan);
+		kfree(rwlock);
+		return NULL;
+	}
+	return rwlock;
+
+}
+void
+rwlock_destroy(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_destroy(rwlock->rw_lock);
+	wchan_destroy(rwlock->rlock_wchan);
+	wchan_destroy(rwlock->wlock_wchan);
+	kfree(rwlock->rwlock_name);
+	kfree(rwlock);
+}
+
+void
+rwlock_acquire_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while (rwlock->num_writer>0)
+	{
+		wchan_lock(rwlock->rlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->rlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_reader++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_read(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_reader > 0);
+	lock_acquire(rwlock->rw_lock);
+	if(rwlock->num_reader > 0)
+	{
+		rwlock->num_reader--;
+	}
+	wchan_wakeall(rwlock->wlock_wchan);
+	wchan_wakeall(rwlock->rlock_wchan);
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_acquire_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	lock_acquire(rwlock->rw_lock);
+	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
+	{
+		wchan_lock(rwlock->wlock_wchan);
+		lock_release(rwlock->rw_lock);
+		wchan_sleep(rwlock->wlock_wchan);
+		lock_acquire(rwlock->rw_lock);
+	}
+	rwlock->num_writer++;
+	lock_release(rwlock->rw_lock);
+}
+void
+rwlock_release_write(struct rwlock *rwlock)
+{
+	KASSERT(rwlock != NULL);
+	KASSERT(rwlock->num_writer > 0);
+	lock_acquire(rwlock->rw_lock);
+	rwlock->num_writer--;
+	wchan_wakeall(rwlock->rlock_wchan);
+	wchan_wakeall(rwlock->wlock_wchan);
+	lock_release(rwlock->rw_lock);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..7a9734c 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,6 +47,9 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <limits.h>
+#include <process.h>
+#include <syscall.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
@@ -70,6 +73,8 @@ static struct cpuarray allcpus;
 /* Used to wait for secondary CPUs to come online. */
 static struct semaphore *cpu_startup_sem;
 
+//extern struct spinlock proc_lock;
+
 ////////////////////////////////////////////////////////////
 
 /*
@@ -126,6 +131,13 @@ thread_create(const char *name)
 		return NULL;
 	}
 
+	/**
+	 * Added by Babu :
+	 * Initializing parent process thread
+	 */
+	thread->t_process = kmalloc(sizeof(struct process));
+	if(thread->t_process == NULL)
+		panic("Process creation failed during thread_create");
 	thread->t_name = kstrdup(name);
 	if (thread->t_name == NULL) {
 		kfree(thread);
@@ -152,7 +164,44 @@ thread_create(const char *name)
 	/* VFS fields */
 	thread->t_cwd = NULL;
 
+	/* To protect from multiple thread generating pid same time - Babu*/
+	spinlock_acquire(&proc_lock);
+
+	// creation of pid
+	thread->t_process->p_pid_self = allocate_pid();
+
+	// Adding entry to process table
+	addto_proc_table(thread->t_process);
+
+	spinlock_release(&proc_lock);
+
+	if( thread->t_process->p_pid_self > 4) /* curr thread is the parent */
+		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
+	else /* -1 to denote that this is the init process*/
+		thread->t_process->p_pid_parent = -1;
+
+
+	thread->t_process->p_exitsem = sem_create("p_exitsem", 0);
+	thread->t_process->p_exited = false;
+	thread->t_process->p_thread = thread;
+	DEBUG(DB_THREADS, "Thread created %s", thread->t_name);
+
+
+
 	/* If you add to struct thread, be sure to initialize here */
+	/*File descriptor*/
+		int i;
+		for (i=0;i<OPEN_MAX;i++)
+		{
+			thread->ft[i] = kmalloc(sizeof(struct file_table *));
+			if (thread->ft[i] == NULL)
+					{
+						kfree(thread);
+						return NULL;
+					}
+			thread->ft[i]=0;
+		}
+		thread->priority = 5;
 
 	return thread;
 }
@@ -262,7 +311,9 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+	DEBUG(DB_THREADS, "%s Thread destroyed.",thread->t_name); 
 	kfree(thread->t_name);
+	//if(thread->ft!=NULL)kfree(thread->ft);
 	kfree(thread);
 }
 
@@ -381,6 +432,8 @@ thread_bootstrap(void)
 	curthread->t_cpu = curcpu;
 	curcpu->c_curthread = curthread;
 
+	spinlock_init(&proc_lock);
+
 	/* Done */
 }
 
@@ -483,7 +536,7 @@ thread_fork(const char *name,
 	    struct thread **ret)
 {
 	struct thread *newthread;
-
+	int i=0;
 	newthread = thread_create(name);
 	if (newthread == NULL) {
 		return ENOMEM;
@@ -520,7 +573,21 @@ thread_fork(const char *name,
 	 */
 	newthread->t_iplhigh_count++;
 
+	//Might have to add the copy of the file table --vasanth
+	// Yes - Copying file table as part of fork - Babu
+	for (i = 0; i < OPEN_MAX; i++)
+	{
+		newthread->ft[i] = curthread->ft[i];
+		if ( curthread->ft[i] !=0)
+		{
+			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
+										 	 // parent and child point to the same ft
+			newthread->ft[i]->ref_count++;
+		}
+	}
+
 	/* Set up the switchframe so entrypoint() gets called */
+
 	switchframe_init(newthread, entrypoint, data1, data2);
 
 	/* Lock the current cpu's run queue and make the new thread runnable */
@@ -574,6 +641,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
+	if ( cur->priority > 0 && cur->priority< 10)
+	{
+		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
+		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
+	}
 
 	/* Lock the run queue. */
 	spinlock_acquire(&curcpu->c_runqueue_lock);
@@ -585,6 +657,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 		return;
 	}
 
+
 	/* Put the thread in the right place. */
 	switch (newstate) {
 	    case S_RUN:
@@ -618,6 +691,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 	}
 	cur->t_state = newstate;
 
+
 	/*
 	 * Get the next thread. While there isn't one, call md_idle().
 	 * curcpu->c_isidle must be true when md_idle is
@@ -791,9 +865,25 @@ void
 thread_exit(void)
 {
 	struct thread *cur;
+	int i = 0;
 
 	cur = curthread;
 
+	/**
+	 * TODO
+	 * Added by Babu :
+	 * Closing file handles which thread possess
+	 */
+	for (i = 0; i < OPEN_MAX; i++)
+	{
+		if (curthread->ft[i] !=  NULL)
+		{
+			// close file descriptor. Ask vasanth
+			//close(i);
+		}
+	}
+
+
 	/* VFS fields */
 	if (cur->t_cwd) {
 		VOP_DECREF(cur->t_cwd);
@@ -818,7 +908,16 @@ thread_exit(void)
 	thread_checkstack(cur);
 
 	/* Interrupts off on this processor */
-        splhigh();
+    splhigh();
+
+    /* Added by Babu :
+     * return if invalid parent and return if parent already exited
+     * */
+	//if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
+	{
+		V(curthread->t_process->p_exitsem);
+	}
+
 	thread_switch(S_ZOMBIE, NULL);
 	panic("The zombie walks!\n");
 }
@@ -853,6 +952,24 @@ schedule(void)
 {
   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
   // "interactive" threads here.
+	spinlock_acquire(&curcpu->c_runqueue_lock);
+	if (curcpu->c_runqueue.tl_count>1)
+	{
+		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
+		while(tnode->tln_next->tln_next != NULL )
+		{
+			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
+			tnode = tnode->tln_next;
+			int curr_priority = tnode->tln_self->priority;
+			//kprintf("curr_priority %d\n",curr_priority);
+			if ( curr_priority < head_priority)
+			{
+				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
+				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
+			}
+		}
+	}
+	spinlock_release(&curcpu->c_runqueue_lock);
 }
 #endif
 
diff --git a/kern/vfs/device.c b/kern/vfs/device.c
index 5446f7b..0357b2a 100644
--- a/kern/vfs/device.c
+++ b/kern/vfs/device.c
@@ -52,6 +52,7 @@ static
 int
 dev_open(struct vnode *v, int flags)
 {
+	DEBUG(DB_VFS, "Calling Device Open...");
 	struct device *d = v->vn_data;
 
 	if (flags & (O_CREAT | O_TRUNC | O_EXCL | O_APPEND)) {
@@ -69,6 +70,7 @@ static
 int
 dev_close(struct vnode *v)
 {
+	DEBUG(DB_VFS, "Calling Device Close...");
 	struct device *d = v->vn_data;
 	return d->d_close(d);
 }
@@ -81,6 +83,7 @@ static
 int
 dev_reclaim(struct vnode *v)
 {
+	DEBUG(DB_VFS, "Calling Device Reclaim...");
 	(void)v;
 	/* nothing - device continues to exist even when not in use */
 	return 0;
@@ -93,6 +96,7 @@ static
 int
 dev_read(struct vnode *v, struct uio *uio)
 {
+	DEBUG(DB_VFS, "Calling Device Read...");
 	struct device *d = v->vn_data;
 	KASSERT(uio->uio_rw == UIO_READ);
 	return d->d_io(d, uio);
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..507b6b1 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -33,6 +33,10 @@
 #include <addrspace.h>
 #include <vm.h>
 
+uint32_t P_INVAL = 0;
+uint32_t P_READ = 1;
+uint32_t P_WRITE = 2;
+
 /*
  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
  * assignment, this file is not compiled or linked or in any way
@@ -52,7 +56,10 @@ as_create(void)
 	/*
 	 * Initialize as needed.
 	 */
-
+	as->table = NULL;
+	as->reg = NULL;
+	as->sbase = 0;
+	as->stop = 0;
 	return as;
 }
 
@@ -65,14 +72,29 @@ as_copy(struct addrspace *old, struct addrspace **ret)
 	if (newas==NULL) {
 		return ENOMEM;
 	}
-
-	/*
-	 * Write this.
-	 */
-
-	(void)old;
-	
-	*ret = newas;
+	struct addrspace *new;
+	int numRegTab = 0;
+		new = as_create();
+		if (new==NULL) {
+			return ENOMEM;
+		}
+		new->hbase = old->hbase;
+		new->htop = old->htop;
+		new->sbase = old->sbase;
+		new->stop = old->stop;
+		while(old->reg != NULL)
+		{
+			numRegTab++;
+		}
+		memmove(new->reg,old->reg,(sizeof(struct region)* numRegTab));
+		numRegTab = 0;
+		while(old->table != NULL)
+		{
+			numRegTab++;
+		}
+		memmove(new->table,old->table,(sizeof(struct pagetable)* numRegTab));
+		numRegTab = 0;
+		*ret = newas;
 	return 0;
 }
 
@@ -82,7 +104,27 @@ as_destroy(struct addrspace *as)
 	/*
 	 * Clean up as needed.
 	 */
-	
+	struct region *reg;
+	struct pagetable *page;
+
+		while (as->reg != NULL)
+		{
+			reg = as->reg;
+			as->reg = as->reg->next;
+			kfree(reg);
+		}
+
+		while(as->table != NULL)
+		{
+			page = as->table;
+			if(page->phyaddress != 0)
+			{
+				page_free(page->phyaddress);
+				as->table = as->table->next;
+				kfree(page);
+			}
+
+		}
 	kfree(as);
 }
 
@@ -94,6 +136,7 @@ as_activate(struct addrspace *as)
 	 */
 
 	(void)as;  // suppress warning until code gets written
+	vm_tlbshootdown_all();
 }
 
 /*
@@ -114,13 +157,50 @@ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
 	 * Write this.
 	 */
 
-	(void)as;
-	(void)vaddr;
-	(void)sz;
 	(void)readable;
 	(void)writeable;
 	(void)executable;
-	return EUNIMP;
+
+	struct region *reg,*tmp;
+
+	sz += vaddr & ~(vaddr_t)PAGE_FRAME; //Aligning Regions
+	vaddr &= PAGE_FRAME;
+
+		/* ...and now the length. */
+	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+		// Update heap_start
+	as->hbase = vaddr + (sz/PAGE_SIZE) * PAGE_SIZE;
+	as->htop = vaddr + (sz/PAGE_SIZE) * PAGE_SIZE;
+
+		// Record region (to be used in vm_fault)
+		reg = kmalloc(sizeof(struct region));
+		if (reg == NULL)return ENOMEM;
+		KASSERT(reg!=NULL);
+		reg->viraddress = vaddr;
+		reg->numpages = sz / PAGE_SIZE;
+		reg->next = NULL;
+		/*reg->readable = readable;
+		reg->writeable = writeable;
+		reg->executable = executable;*/
+		if(as->reg == NULL)
+			{
+				as->reg = reg;
+				as->reg->next = NULL;
+			}
+		else
+			{
+				tmp = as->reg;
+				if (tmp && tmp->next )
+				{
+				while(tmp->next != NULL)
+				{
+					tmp = tmp->next;
+				}
+				tmp->next = reg;
+				}
+			}
+		return 0;
 }
 
 int
@@ -129,8 +209,42 @@ as_prepare_load(struct addrspace *as)
 	/*
 	 * Write this.
 	 */
-
-	(void)as;
+	struct region *reg;
+	struct pagetable *page,*temp;
+	reg = as->reg;
+	while(reg!=NULL)
+	{
+		size_t i;
+		size_t cnt = reg->numpages;
+		vaddr_t reg_base = reg->viraddress;
+		temp = as->table;
+		if (temp !=NULL)
+		{
+			while(temp->next != NULL)
+			{
+				temp = temp->next;
+			}
+		}
+		for(i=0;i<cnt;i++)
+		{
+		 	page = (struct pagetable *)kmalloc(sizeof(struct pagetable));
+			KASSERT(page!=NULL);
+			//virtual address being computed according to the base address for the region.
+			page->viraddress = reg_base + i * PAGE_SIZE;
+			page->phyaddress = page_alloc();
+			page->next = NULL;
+			if(temp == NULL)
+			{
+				as->table=temp=page;
+			}
+			else
+			{
+				temp->next = page;
+				temp = temp->next;
+			}
+		}
+		reg = reg->next;
+	}
 	return 0;
 }
 
@@ -152,11 +266,51 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 	 * Write this.
 	 */
 
-	(void)as;
-
 	/* Initial user-level stack pointer */
+	as->sbase = USERSTACK;
+	as->stop =USERSTACK;
 	*stackptr = USERSTACK;
 	
 	return 0;
 }
 
+/**
+ * Get address space permissions
+ */
+uint32_t
+as_permissions(struct addrspace *as, vaddr_t faultaddress)
+{
+	KASSERT(as!= NULL);
+	KASSERT(as->reg!= NULL);
+	struct region *as_region = as->reg;
+	while(as_region->next != NULL)
+	{
+		if(faultaddress == as_region->viraddress)
+		{
+			return as_region->permissions;
+		}
+		as_region = as_region->next;
+	}
+	return P_INVAL;
+}
+
+/**
+ * Get Page table entry
+ */
+struct pagetable *
+as_pagetable_entry(struct addrspace *as, vaddr_t faultaddress)
+{
+	KASSERT(as!= NULL);
+	KASSERT(as->table != NULL);
+	struct pagetable *as_ptable = as->table;
+	while(as_ptable->next != NULL)
+	{
+		if(faultaddress == as_ptable->viraddress)
+		{
+			return as_ptable;
+		}
+		as_ptable  = as_ptable->next;
+	}
+	return NULL;
+}
+
diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
index 09b764b..f8efc2d 100644
--- a/kern/vm/kmalloc.c
+++ b/kern/vm/kmalloc.c
@@ -148,9 +148,11 @@ allocpageref(void)
 	unsigned i,j;
 	uint32_t k;
 
+	DEBUG(DB_KMALLOC, "Allocating Page Reference ..... ");
 	for (i=0; i<INUSE_WORDS; i++) {
 		if (pagerefs_inuse[i]==0xffffffff) {
 			/* full */
+			DEBUG(DB_KMALLOC, "Virtual Memory is full. All pages are being used...");
 			continue;
 		}
 		for (k=1,j=0; k!=0; k<<=1,j++) {
@@ -179,6 +181,7 @@ freepageref(struct pageref *p)
 	k = ((uint32_t)1) << (j%32);
 	KASSERT((pagerefs_inuse[i] & k) != 0);
 	pagerefs_inuse[i] &= ~k;
+	DEBUG(DB_VM, "VM Page references freed ");
 }
 
 ////////////////////////////////////////
@@ -218,6 +221,7 @@ checksubpage(struct pageref *pr)
 
 	KASSERT(spinlock_do_i_hold(&kmalloc_spinlock));
 
+	DEBUG(DB_VM, "Checking Sub Pages...");
 	if (pr->freelist_offset == INVALID_OFFSET) {
 		KASSERT(pr->nfree==0);
 		return;
@@ -226,6 +230,7 @@ checksubpage(struct pageref *pr)
 	prpage = PR_PAGEADDR(pr);
 	blktype = PR_BLOCKTYPE(pr);
 
+	DEBUG(DB_VM,"Free List of VM Pages %u",pr->freelist_offset);
 	KASSERT(pr->freelist_offset < PAGE_SIZE);
 	KASSERT(pr->freelist_offset % sizes[blktype] == 0);
 
@@ -525,7 +530,6 @@ subpage_kfree(void *ptr)
 	spinlock_acquire(&kmalloc_spinlock);
 
 	checksubpages();
-
 	for (pr = allbase; pr; pr = pr->next_all) {
 		prpage = PR_PAGEADDR(pr);
 		blktype = PR_BLOCKTYPE(pr);
diff --git a/kern/vm/vm.c b/kern/vm/vm.c
new file mode 100644
index 0000000..220971b
--- /dev/null
+++ b/kern/vm/vm.c
@@ -0,0 +1,606 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <synch.h>
+#include <clock.h>
+
+/*
+ * Working VM which is carved out of VM assignment :)
+ * Author : Babu
+ */
+
+/* under dumbvm, always have 48k of user stack */
+//#define DUMBVM_STACKPAGES    12
+
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+struct spinlock spnlock_coremap;
+
+uint32_t vol_pagefree =  0;
+
+//uint32_t P_INVAL = 0;
+//uint32_t P_READ = 1;
+//uint32_t P_WRITE = 2;
+
+/*
+ * flag to check whether the vm_bootstrap has been initialized
+ */
+bool is_vm_bootstrapped = false;
+
+void
+vm_bootstrap(void)
+{
+	paddr_t paddr_first = 0;
+	paddr_t paddr_last = 0;
+	paddr_t paddr_free = 0;
+
+	spinlock_init(&spnlock_coremap);
+
+	/* Initialize coremap */
+	ram_getsize(&paddr_first, &paddr_last);
+
+
+	//page_num = ROUNDUP(paddr_last, PAGE_SIZE) / PAGE_SIZE;// :| Why rounddown?
+	//page_num = ROUNDDOWN(paddr_last, PAGE_SIZE) / PAGE_SIZE;
+	paddr_t ramsize = (paddr_last - paddr_first);
+	page_num =  (ramsize - (ramsize % 4)) / PAGE_SIZE;
+
+
+	/* pages should be a kernel virtual address !!  */
+	pages = (struct page *) PADDR_TO_KVADDR(paddr_first);
+	paddr_free = paddr_first + (page_num * CME_SIZE); // core map size
+
+	// Mapping coremap elements(page table entry - PTE) to their respective virtual memory.
+	paddr_t tmp_addr = paddr_first;
+	for (uint32_t i = 0; i < page_num; i++)
+	{
+		(pages + i)-> virtual_addr = PADDR_TO_KVADDR(tmp_addr);
+		(pages + i)->addrspce = NULL;
+		(pages + i)-> num_pages = 1;
+		(pages + i)-> timestamp = 0xffffffff;
+		if(tmp_addr < paddr_free)
+			(pages + i)-> page_state = FIXED;
+		else
+			(pages + i)-> page_state = FREE;
+		tmp_addr += PAGE_SIZE;
+	}
+
+	is_vm_bootstrapped = true;
+
+}
+
+/**
+ * Get pages by stealing memory from ram.
+ * Invoked during boot sequence as the vm might have not been initialized.
+ * Should never be called once vm is initialized
+ * Modified by : Babu
+ */
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+
+	spinlock_acquire(&stealmem_lock);
+
+	addr = ram_stealmem(npages);
+
+	spinlock_release(&stealmem_lock);
+
+	return addr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t
+alloc_kpages(int npages)
+{
+
+	vaddr_t alloc_mem = 0;
+	if(is_vm_bootstrapped)
+	{
+		alloc_mem = page_nalloc(npages);
+	}
+	else
+	{
+		if(getppages(npages) != 0)
+			alloc_mem = PADDR_TO_KVADDR(getppages(npages));
+		else
+			panic("ERROR : Zero address returned.");
+	}
+	return alloc_mem;
+}
+
+void 
+free_kpages(vaddr_t addr)
+{
+	//kprintf("before spin");
+
+	spinlock_acquire(&spnlock_coremap);
+
+	struct page *find_page = pages;
+
+	uint32_t page_cnt = 0;
+	//while(find_page->virtual_addr != addr)
+	for(page_cnt=0;page_cnt < page_num;page_cnt++)
+	{
+		if(find_page->virtual_addr == addr)
+			break;
+		find_page ++;
+	}
+
+//	kprintf("free_k : 1");
+
+	//Check whether this is the page we are looking for to de-allocate.
+	//KASSERT(find_page->virtual_addr == addr);
+	if(find_page->virtual_addr != addr)
+	{
+		//lock_release(lock_coremap);
+		spinlock_release(&spnlock_coremap);
+		return;
+	}
+
+	//kprintf("free_k : 2");
+	// if the address to be freed belongs to kernel then dont do anything
+	// else free it.
+
+	int no_dealloc = find_page->num_pages;
+	for (int i = 0; i < no_dealloc; ++i)
+	{
+		find_page->page_state =  FREE;
+		find_page->timestamp = 0;
+		find_page->num_pages = 1;
+		//as_destroy(find_page->addrspce);
+		find_page ++;
+
+	}
+
+	//kprintf("free_k : 3");
+
+	spinlock_release(&spnlock_coremap);
+	return;
+	//kprintf("after spin");
+
+
+}
+
+
+void
+page_free(vaddr_t addr)
+{
+	spinlock_acquire(&spnlock_coremap);
+
+	struct page *find_page = pages;
+
+	uint32_t page_cnt = 0;
+	//while(find_page->virtual_addr != addr)
+	for(page_cnt=0;page_cnt < page_num;page_cnt++)
+	{
+		if(find_page->virtual_addr == addr)
+			break;
+		find_page ++;
+	}
+
+	//Check whether this is the page we are looking for to de-allocate.
+	//KASSERT(find_page->virtual_addr == addr);
+	if(find_page->virtual_addr != addr)
+	{
+		spinlock_release(&spnlock_coremap);
+		return;
+	}
+
+	// if the address to be freed belongs to kernel then dont do anything
+	// else free it.
+	if(find_page->page_state != FIXED)
+	{
+		int32_t no_dealloc = find_page->num_pages;
+		for (int32_t i = 0; i < no_dealloc; ++i)
+		{
+			find_page->page_state =  FREE;
+			find_page->timestamp = 0;
+			find_page->num_pages = 1;
+			//as_destroy(find_page->addrspce); user space ---??
+
+			find_page ++;;
+		}
+
+	}
+	else
+		kprintf("kernel page. cannot deallocate");
+
+	spinlock_release(&spnlock_coremap);
+
+	//kprintf("after spin");
+
+
+}
+
+
+/**
+ * page_alloc - Page allocation for user program
+ */
+vaddr_t
+page_alloc()
+{
+
+	//kprintf("before spin");
+
+	uint32_t npages = 1;
+	//kprintf("before spin");
+
+
+	spinlock_acquire(&spnlock_coremap);
+	/**
+	 * Find some free memory and try to allocate to the caller
+	 */
+	struct page *free_page = pages;
+
+	//kprintf("page_n : 1");
+	uint32_t start_page = 0;
+	uint32_t free_page_cnt = 0;
+	for(start_page=0;start_page < page_num;start_page++)
+	{
+		if(free_page->page_state == FREE)
+		{
+			for (free_page_cnt=1; free_page_cnt<npages; free_page_cnt++)
+			{
+				free_page ++;
+				if(free_page->page_state != FREE)
+					break;
+			}
+
+			if(free_page_cnt == npages)
+				break;
+			else
+				start_page += free_page_cnt - 1;
+		}
+		free_page ++;
+	}
+
+
+	if(free_page_cnt == 0)
+	{
+		//kprintf("page not free.. so oldest one..");
+		free_page = pages;
+		uint64_t oldest_page_timestamp = 0xffffffff;
+		uint32_t oldest_page_num = 0, i;
+		for(i=0;i < page_num; i++)
+		{
+			// TODO : allocate the pages if its not fixed untill swapping is implemented
+			/*Logic for page swapping - FIFO*/
+			if(free_page -> timestamp < oldest_page_timestamp && free_page->page_state != FIXED)
+			{
+				oldest_page_timestamp = free_page -> timestamp;
+				oldest_page_num = i;
+			}
+			free_page ++;
+		}
+
+
+		start_page = oldest_page_num;
+		free_page_cnt = npages;
+	}
+
+	//kprintf("page_n : 3");
+
+	// Check at the end of the iteration whether we got the
+	// number of pages we want
+	KASSERT(free_page_cnt == npages);
+
+	free_page = pages + start_page;
+
+	//kprintf("page_n : 4");
+
+	// Make the entire page available
+
+	for (free_page_cnt=0; free_page_cnt<npages; free_page_cnt++)
+	{
+		make_page_avail(free_page);
+
+		//free_page->addrspce = as_create(); // TODO : ????
+		free_page->num_pages = npages;
+
+		time_t current_time = -1;
+		uint32_t nanosec;
+		gettime(&current_time, &nanosec);
+		if(current_time != -1)
+			free_page->timestamp = current_time;
+		else
+		{
+			spinlock_release(&spnlock_coremap);
+			panic("time error");
+		}
+
+		// Zeroing the page before returning
+		//bzero((void *)free_page->virtual_addr, PAGE_SIZE);
+
+		free_page ++;
+
+	}
+
+	//kprintf("page_n : 5");
+
+	// Start of n chunks of free pages
+	free_page = pages + start_page;
+
+	spinlock_release(&spnlock_coremap);
+
+	//kprintf("after spin");
+
+	return free_page->virtual_addr;
+}
+
+vaddr_t
+page_nalloc(unsigned long npages)
+{
+	//kprintf("before spin");
+
+
+	spinlock_acquire(&spnlock_coremap);
+	/**
+	 * Find some free memory and try to allocate to the caller
+	 */
+	struct page *free_page = pages;
+
+	//kprintf("page_n : 1");
+	uint32_t start_page = 0;
+	uint32_t free_page_cnt = 0;
+	for(start_page=0;start_page < page_num;start_page++)
+	{
+		if(free_page->page_state == FREE)
+		{
+			for (free_page_cnt=1; free_page_cnt<npages; free_page_cnt++)
+			{
+				free_page ++;
+				if(free_page->page_state != FREE)
+					break;
+			}
+
+			if(free_page_cnt == npages)
+				break;
+			else
+				start_page += free_page_cnt - 1;
+		}
+		free_page ++;
+	}
+
+
+	if(free_page_cnt == 0)
+	{
+		//kprintf("page not free.. so oldest one..");
+		free_page = pages;
+		uint64_t oldest_page_timestamp = 0xffffffff;
+		uint32_t oldest_page_num = 0, i;
+		for(i=0;i < page_num; i++)
+		{
+			// TODO : allocate the pages if its not fixed untill swapping is implemented
+			/*Logic for page swapping - FIFO*/
+			if(free_page -> timestamp < oldest_page_timestamp && free_page->page_state != FIXED)
+			{
+				oldest_page_timestamp = free_page -> timestamp;
+				oldest_page_num = i;
+			}
+			free_page ++;
+		}
+
+
+		start_page = oldest_page_num;
+		free_page_cnt = npages;
+	}
+
+	//kprintf("page_n : 3");
+
+	// Check at the end of the iteration whether we got the
+	// number of pages we want
+	KASSERT(free_page_cnt == npages);
+
+	free_page = pages + start_page;
+
+	//kprintf("page_n : 4");
+
+	// Make the entire page available
+
+	for (free_page_cnt=0; free_page_cnt<npages; free_page_cnt++)
+	{
+		make_page_avail(free_page);
+
+		//free_page->addrspce = as_create(); // TODO : ????
+		free_page->num_pages = npages;
+
+		time_t current_time = -1;
+		uint32_t nanosec;
+		gettime(&current_time, &nanosec);
+		if(current_time != -1)
+			free_page->timestamp = current_time;
+		else
+		{
+			spinlock_release(&spnlock_coremap);
+			panic("time error");
+		}
+
+		// Zeroing the page before returning
+		//bzero((void *)free_page->virtual_addr, PAGE_SIZE);
+
+		free_page ++;
+
+	}
+
+	//kprintf("page_n : 5");
+
+	// Start of n chunks of free pages
+	free_page = pages + start_page;
+
+	spinlock_release(&spnlock_coremap);
+
+	//kprintf("after spin");
+
+	return free_page->virtual_addr;
+
+}
+
+
+/**
+ * This function will make the page available for either by evicting the page to disk
+ * a.k.a swapping out or by flushing it
+ * Author : Babu
+ */
+int32_t
+make_page_avail(struct page *free_page)
+{
+
+	// as of now just making the page state as free by flushing it
+	// TODO : implement swapping in this as_create function
+
+	// Allocating it as dirty for the first time as the disk will not have a copy
+	free_page->page_state = DIRTY;
+	bzero((void *)free_page->virtual_addr, PAGE_SIZE);
+
+	return 0;
+}
+
+
+void
+vm_tlbshootdown_all(void)
+{
+
+	/* TODO */
+
+
+}
+
+
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+
+	int i,spl;
+
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++)
+		tlb_write(TLBHI_INVALID(i),TLBLO_INVALID(),i);
+
+	splx(spl);
+
+	(void)ts;
+}//
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	/* TODO */
+	struct addrspace *as = curthread->t_addrspace;
+	//uint32_t tlb_high, tlb_low;
+	//paddr_t paddress;
+
+	// get page number from MASKING variable
+	faultaddress = faultaddress & PAGE_FRAME;
+	KASSERT(faultaddress < MIPS_KSEG0);
+//	KASSERT(as != NULL);
+
+    if(faultaddress < as->htop && faultaddress > as->htop &&
+    		faultaddress < USERSTACK - PAGE_SIZE * 4096)
+    {
+    	// Valid
+    }
+    else
+    {
+    	// else return
+    	return EFAULT;
+    }
+
+    if(as_permissions(as,faultaddress) == 0)
+    	return EFAULT;
+
+    struct pagetable *pte = as_pagetable_entry(as,faultaddress);
+
+    KASSERT(pte != NULL);
+
+    uint32_t page_perm = pte->permissions;
+
+	switch(faulttype)
+	{
+		case VM_FAULT_READONLY:
+			// then update tlb
+			if(page_perm == 2)
+			{
+				struct page *find_page = pages;
+				uint32_t i = 0;
+				for (i = 0; i<page_num; ++i) {
+					if(find_page->virtual_addr == faultaddress)
+					{
+						find_page->page_state = DIRTY;
+						//find_page->addrspce = as;
+					}
+					find_page++;
+				}
+
+
+				//tlb_low =  paddress & TLBLO_PPAGE;
+				//tlb_high = faultaddress & TLBHI_VPAGE;
+			}
+			else
+				return EFAULT;
+
+			break;
+
+		case VM_FAULT_READ:
+		case VM_FAULT_WRITE:
+			// create new page with the virtual address passed
+			if(pte == NULL)
+			{
+				page_alloc();
+			}
+			else
+			{
+
+			}
+			break;
+	}
+
+
+	(void) faulttype;
+	(void) faultaddress;
+	return EUNIMP;
+}
+
+
diff --git a/mk/os161.config.mk b/mk/os161.config.mk
index 3de8771..8790d16 100644
--- a/mk/os161.config.mk
+++ b/mk/os161.config.mk
@@ -295,7 +295,7 @@
 #
 
 # Locations of things.
-OSTREE=$(HOME)/os161/root	# Root directory to install into.
+OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
 WORKDIR=$(TOP)/build		# Top of tree to build into.
 BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
 
diff --git a/sample.txt b/sample.txt
new file mode 100644
index 0000000..60cb071
--- /dev/null
+++ b/sample.txt
@@ -0,0 +1,38 @@
+//kprintf("Inside waitpid\n");
+	/*Argument checking*/
+	// if child process does not exist
+	if(pid < 1)
+		return EINVAL;
+
+	if(childprocess == NULL)
+		return EINVAL;
+
+	if(exitcode == NULL)
+		return EINVAL;
+	if(exitcode == (void *)0x80000000) // Kernel pointer check
+		return EFAULT;
+	if(exitcode == (void *)0x40000000)  // Invalide pointer check
+		return EFAULT;
+
+
+	// if exitcode alignment is not proper ? DOUBT
+	if(sizeof(exitcode) != sizeof(int32_t))
+		return EFAULT;
+
+	// if flags are not proper
+	if(flags != WNOHANG && flags != WUNTRACED)
+		return EINVAL;
+
+
+
+
+	// copy this for improper alignment badwaitpid
+	result = copycheck(usersrc, len, &stoplen);
+			if (result) {
+				return result;
+			}
+			if (stoplen != len) {
+				/* Single block, can't legally truncate it. */
+				return EFAULT;
+			}
+		
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..bf11115
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,5381 @@
+diff --git a/common/libc/string/strcpy.c b/common/libc/string/strcpy.c
+index 88627ed..9a51b24 100644
+--- a/common/libc/string/strcpy.c
++++ b/common/libc/string/strcpy.c
+@@ -47,17 +47,18 @@ strcpy(char *dest, const char *src)
+ {
+ 	size_t i;
+ 
++
+ 	/*
+ 	 * Copy characters until we hit the null terminator.
+ 	 */
+ 	for (i=0; src[i]; i++) {
+ 		dest[i] = src[i];
+ 	}
+-
+ 	/*
+ 	 * Add null terminator to result.
+ 	 */
+ 	dest[i] = 0;
++	//kprintf("Destination string %s\n",dest);
+ 
+ 	return dest;
+ }
+diff --git a/defs.mk b/defs.mk
+new file mode 100644
+index 0000000..9345229
+--- /dev/null
++++ b/defs.mk
+@@ -0,0 +1,20 @@
++# This file was generated by configure. Edits will disappear if you rerun
++# configure. If you find that you need to edit this file to make things
++# work, let the course staff know and we'll try to fix the configure script.
++#
++# The purpose of this file is to hold all the makefile definitions
++# needed to adjust the OS/161 build process to any particular
++# environment. If I've done it right, all you need to do is rerun the
++# configure script and make clean if you start working on a different
++# host OS. If I've done it mostly right, you may need to edit this
++# file but you still hopefully won't need to edit any of the
++# makefiles.
++#
++# The things that can be set here are documented in mk/os161.config.mk.
++#
++
++OSTREE=$(HOME)/root
++PLATFORM=sys161
++MACHINE=mips
++COMPAT_CFLAGS=
++COMPAT_TARGETS=
+diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
+index af393c7..03aea4c 100644
+--- a/kern/arch/mips/include/vm.h
++++ b/kern/arch/mips/include/vm.h
+@@ -67,6 +67,12 @@
+  */
+ #define PADDR_TO_KVADDR(paddr) ((paddr)+MIPS_KSEG0)
+ 
++/**
++ * Address translation from kernel virtual address to physical address
++ * Author : Babu
++ */
++#define KVADDR_TO_PADDR(kvaddr) ((kvaddr)-MIPS_KSEG0)
++
+ /*
+  * The top of user space. (Actually, the address immediately above the
+  * last valid user address.)
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..2509f75 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -114,7 +114,8 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
+ 
+ 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+ 		code, sig, trapcodenames[code], epc, vaddr);
+-	panic("I don't know how to handle this\n");
++	//panic("I don't know how to handle this\n");
++	sys__exit(0);
+ }
+ 
+ /*
+@@ -394,7 +395,9 @@ mips_usermode(struct trapframe *tf)
+ 	 * either another thread's stack or in the kernel heap.
+ 	 * (Exercise: why?)
+ 	 */
++	//kprintf("before SAME STACK");
+ 	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
++	//kprintf("after SAME STACK");
+ 
+ 	/*
+ 	 * This actually does it. See exception.S.
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..6de47f2 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -36,6 +36,8 @@
+ #include <current.h>
+ #include <syscall.h>
+ 
++#include <endian.h>
++#include <copyinout.h>
+ 
+ /*
+  * System call dispatcher.
+@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++	uint32_t retval2;
++	uint64_t ar2,ret;
++	int whence;
+ 	int err;
+ 
+ 	KASSERT(curthread != NULL);
+@@ -98,7 +103,7 @@ syscall(struct trapframe *tf)
+ 	 */
+ 
+ 	retval = 0;
+-
++	//kprintf("syscall number : %d\n",callno);
+ 	switch (callno) {
+ 	    case SYS_reboot:
+ 		err = sys_reboot(tf->tf_a0);
+@@ -109,15 +114,92 @@ syscall(struct trapframe *tf)
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
+ 
++		/**
++		 * Added by Babu : case statements for process related syscalls
++		 */
++	    case SYS_fork:
++	        err = sys_fork(&retval, tf);
++	        //kprintf("ret val : %d and err no : %d\n",retval, err);
++	    	break;
++
++	    case SYS_execv:
++	    	err = sys_execv((userptr_t)tf->tf_a0, (userptr_t *)tf->tf_a1);
++	    	break;
++
++	    case SYS__exit:
++	    	sys__exit((int)tf->tf_a0);
++	    	err = 0;
++	    	break;
++
++	    case SYS_waitpid:
++	    	err = sys_waitpid(&retval, (pid_t)tf->tf_a0, (int32_t *)tf->tf_a1, (int32_t)tf->tf_a2);
++	    	break;
++
++	    case SYS_getpid:
++	    	err = sys_getpid(&retval);
++	    	break;
++
++	    case SYS_getppid:
++	    	err = sys_getppid(&retval);
++	    	break;
++
++
+ 	    /* Add stuff here */
+- 
++	    // File system calls - Vasanth
++	    case SYS_open:
++	    	retval = open((userptr_t)tf->tf_a0,
++	    	(int)tf->tf_a1,&err);
++	    break;
++
++   	    case SYS_close:
++			err = close(tf->tf_a0);
++			break;
++
++        case SYS_read:
++        	retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
++        	break;
++
++        case SYS_write:
++        	retval = write(tf->tf_a0,(userptr_t)tf->tf_a1, tf->tf_a2,&err);
++        	break;
++
++        case SYS_dup2:
++        	ret = dup2(tf->tf_a0,tf->tf_a1,&err);
++        	break;
++
++        case SYS_lseek:
++			join32to64(tf->tf_a2,tf->tf_a3,&ar2);
++			//kprintf("Correct lseek called\n");
++			if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0)
++			{
++				   break;
++			}
++			ret = lseek((int)tf->tf_a0,ar2,whence,&err);
++			//kprintf("ret value %llu\n",ret);
++			split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
++			//kprintf("Retval %d,%d\n",retval,retval2);
++			if (!err)
++			{
++				tf->tf_v1 = retval2;
++			}
++			break;
++
++        case SYS_chdir:
++        	err = chdir((const_userptr_t)tf->tf_a0);
++        	break;
++
++        case SYS___getcwd:
++			ret = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1,&err);
++			break;
++        case SYS_remove:
++        		err = sys_remove((userptr_t)tf->tf_a0);
++        		break;
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+ 		break;
+ 	}
+ 
+-
+ 	if (err) {
+ 		/*
+ 		 * Return the error code. This gets converted at
+@@ -137,7 +219,7 @@ syscall(struct trapframe *tf)
+ 	 * Now, advance the program counter, to avoid restarting
+ 	 * the syscall over and over again.
+ 	 */
+-	
++
+ 	tf->tf_epc += 4;
+ 
+ 	/* Make sure the syscall code didn't forget to lower spl */
+diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
+deleted file mode 100644
+index ca9992a..0000000
+--- a/kern/arch/mips/vm/dumbvm.c
++++ /dev/null
+@@ -1,374 +0,0 @@
+-/*
+- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+- *	The President and Fellows of Harvard College.
+- *
+- * Redistribution and use in source and binary forms, with or without
+- * modification, are permitted provided that the following conditions
+- * are met:
+- * 1. Redistributions of source code must retain the above copyright
+- *    notice, this list of conditions and the following disclaimer.
+- * 2. Redistributions in binary form must reproduce the above copyright
+- *    notice, this list of conditions and the following disclaimer in the
+- *    documentation and/or other materials provided with the distribution.
+- * 3. Neither the name of the University nor the names of its contributors
+- *    may be used to endorse or promote products derived from this software
+- *    without specific prior written permission.
+- *
+- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+- * SUCH DAMAGE.
+- */
+-
+-#include <types.h>
+-#include <kern/errno.h>
+-#include <lib.h>
+-#include <spl.h>
+-#include <spinlock.h>
+-#include <thread.h>
+-#include <current.h>
+-#include <mips/tlb.h>
+-#include <addrspace.h>
+-#include <vm.h>
+-
+-/*
+- * Dumb MIPS-only "VM system" that is intended to only be just barely
+- * enough to struggle off the ground. You should replace all of this
+- * code while doing the VM assignment. In fact, starting in that
+- * assignment, this file is not included in your kernel!
+- */
+-
+-/* under dumbvm, always have 48k of user stack */
+-#define DUMBVM_STACKPAGES    12
+-
+-/*
+- * Wrap rma_stealmem in a spinlock.
+- */
+-static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+-
+-void
+-vm_bootstrap(void)
+-{
+-	/* Do nothing. */
+-}
+-
+-static
+-paddr_t
+-getppages(unsigned long npages)
+-{
+-	paddr_t addr;
+-
+-	spinlock_acquire(&stealmem_lock);
+-
+-	addr = ram_stealmem(npages);
+-	
+-	spinlock_release(&stealmem_lock);
+-	return addr;
+-}
+-
+-/* Allocate/free some kernel-space virtual pages */
+-vaddr_t 
+-alloc_kpages(int npages)
+-{
+-	paddr_t pa;
+-	pa = getppages(npages);
+-	if (pa==0) {
+-		return 0;
+-	}
+-	return PADDR_TO_KVADDR(pa);
+-}
+-
+-void 
+-free_kpages(vaddr_t addr)
+-{
+-	/* nothing - leak the memory. */
+-
+-	(void)addr;
+-}
+-
+-void
+-vm_tlbshootdown_all(void)
+-{
+-	panic("dumbvm tried to do tlb shootdown?!\n");
+-}
+-
+-void
+-vm_tlbshootdown(const struct tlbshootdown *ts)
+-{
+-	(void)ts;
+-	panic("dumbvm tried to do tlb shootdown?!\n");
+-}
+-
+-int
+-vm_fault(int faulttype, vaddr_t faultaddress)
+-{
+-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+-	paddr_t paddr;
+-	int i;
+-	uint32_t ehi, elo;
+-	struct addrspace *as;
+-	int spl;
+-
+-	faultaddress &= PAGE_FRAME;
+-
+-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+-
+-	switch (faulttype) {
+-	    case VM_FAULT_READONLY:
+-		/* We always create pages read-write, so we can't get this */
+-		panic("dumbvm: got VM_FAULT_READONLY\n");
+-	    case VM_FAULT_READ:
+-	    case VM_FAULT_WRITE:
+-		break;
+-	    default:
+-		return EINVAL;
+-	}
+-
+-	as = curthread->t_addrspace;
+-	if (as == NULL) {
+-		/*
+-		 * No address space set up. This is probably a kernel
+-		 * fault early in boot. Return EFAULT so as to panic
+-		 * instead of getting into an infinite faulting loop.
+-		 */
+-		return EFAULT;
+-	}
+-
+-	/* Assert that the address space has been set up properly. */
+-	KASSERT(as->as_vbase1 != 0);
+-	KASSERT(as->as_pbase1 != 0);
+-	KASSERT(as->as_npages1 != 0);
+-	KASSERT(as->as_vbase2 != 0);
+-	KASSERT(as->as_pbase2 != 0);
+-	KASSERT(as->as_npages2 != 0);
+-	KASSERT(as->as_stackpbase != 0);
+-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+-
+-	vbase1 = as->as_vbase1;
+-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+-	vbase2 = as->as_vbase2;
+-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+-	stacktop = USERSTACK;
+-
+-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+-		paddr = (faultaddress - vbase1) + as->as_pbase1;
+-	}
+-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+-		paddr = (faultaddress - vbase2) + as->as_pbase2;
+-	}
+-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+-	}
+-	else {
+-		return EFAULT;
+-	}
+-
+-	/* make sure it's page-aligned */
+-	KASSERT((paddr & PAGE_FRAME) == paddr);
+-
+-	/* Disable interrupts on this CPU while frobbing the TLB. */
+-	spl = splhigh();
+-
+-	for (i=0; i<NUM_TLB; i++) {
+-		tlb_read(&ehi, &elo, i);
+-		if (elo & TLBLO_VALID) {
+-			continue;
+-		}
+-		ehi = faultaddress;
+-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+-		tlb_write(ehi, elo, i);
+-		splx(spl);
+-		return 0;
+-	}
+-
+-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+-	splx(spl);
+-	return EFAULT;
+-}
+-
+-struct addrspace *
+-as_create(void)
+-{
+-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+-	if (as==NULL) {
+-		return NULL;
+-	}
+-
+-	as->as_vbase1 = 0;
+-	as->as_pbase1 = 0;
+-	as->as_npages1 = 0;
+-	as->as_vbase2 = 0;
+-	as->as_pbase2 = 0;
+-	as->as_npages2 = 0;
+-	as->as_stackpbase = 0;
+-
+-	return as;
+-}
+-
+-void
+-as_destroy(struct addrspace *as)
+-{
+-	kfree(as);
+-}
+-
+-void
+-as_activate(struct addrspace *as)
+-{
+-	int i, spl;
+-
+-	(void)as;
+-
+-	/* Disable interrupts on this CPU while frobbing the TLB. */
+-	spl = splhigh();
+-
+-	for (i=0; i<NUM_TLB; i++) {
+-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+-	}
+-
+-	splx(spl);
+-}
+-
+-int
+-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+-		 int readable, int writeable, int executable)
+-{
+-	size_t npages; 
+-
+-	/* Align the region. First, the base... */
+-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+-	vaddr &= PAGE_FRAME;
+-
+-	/* ...and now the length. */
+-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+-
+-	npages = sz / PAGE_SIZE;
+-
+-	/* We don't use these - all pages are read-write */
+-	(void)readable;
+-	(void)writeable;
+-	(void)executable;
+-
+-	if (as->as_vbase1 == 0) {
+-		as->as_vbase1 = vaddr;
+-		as->as_npages1 = npages;
+-		return 0;
+-	}
+-
+-	if (as->as_vbase2 == 0) {
+-		as->as_vbase2 = vaddr;
+-		as->as_npages2 = npages;
+-		return 0;
+-	}
+-
+-	/*
+-	 * Support for more than two regions is not available.
+-	 */
+-	kprintf("dumbvm: Warning: too many regions\n");
+-	return EUNIMP;
+-}
+-
+-static
+-void
+-as_zero_region(paddr_t paddr, unsigned npages)
+-{
+-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+-}
+-
+-int
+-as_prepare_load(struct addrspace *as)
+-{
+-	KASSERT(as->as_pbase1 == 0);
+-	KASSERT(as->as_pbase2 == 0);
+-	KASSERT(as->as_stackpbase == 0);
+-
+-	as->as_pbase1 = getppages(as->as_npages1);
+-	if (as->as_pbase1 == 0) {
+-		return ENOMEM;
+-	}
+-
+-	as->as_pbase2 = getppages(as->as_npages2);
+-	if (as->as_pbase2 == 0) {
+-		return ENOMEM;
+-	}
+-
+-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+-	if (as->as_stackpbase == 0) {
+-		return ENOMEM;
+-	}
+-	
+-	as_zero_region(as->as_pbase1, as->as_npages1);
+-	as_zero_region(as->as_pbase2, as->as_npages2);
+-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+-
+-	return 0;
+-}
+-
+-int
+-as_complete_load(struct addrspace *as)
+-{
+-	(void)as;
+-	return 0;
+-}
+-
+-int
+-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+-{
+-	KASSERT(as->as_stackpbase != 0);
+-
+-	*stackptr = USERSTACK;
+-	return 0;
+-}
+-
+-int
+-as_copy(struct addrspace *old, struct addrspace **ret)
+-{
+-	struct addrspace *new;
+-
+-	new = as_create();
+-	if (new==NULL) {
+-		return ENOMEM;
+-	}
+-
+-	new->as_vbase1 = old->as_vbase1;
+-	new->as_npages1 = old->as_npages1;
+-	new->as_vbase2 = old->as_vbase2;
+-	new->as_npages2 = old->as_npages2;
+-
+-	/* (Mis)use as_prepare_load to allocate some physical memory. */
+-	if (as_prepare_load(new)) {
+-		as_destroy(new);
+-		return ENOMEM;
+-	}
+-
+-	KASSERT(new->as_pbase1 != 0);
+-	KASSERT(new->as_pbase2 != 0);
+-	KASSERT(new->as_stackpbase != 0);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+-		old->as_npages1*PAGE_SIZE);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+-		old->as_npages2*PAGE_SIZE);
+-
+-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+-		DUMBVM_STACKPAGES*PAGE_SIZE);
+-	
+-	*ret = new;
+-	return 0;
+-}
+diff --git a/kern/arch/mips/vm/dumbvm_dontuse.c b/kern/arch/mips/vm/dumbvm_dontuse.c
+new file mode 100644
+index 0000000..f15c4cc
+--- /dev/null
++++ b/kern/arch/mips/vm/dumbvm_dontuse.c
+@@ -0,0 +1,374 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <lib.h>
++#include <spl.h>
++#include <spinlock.h>
++#include <thread.h>
++#include <current.h>
++#include <mips/tlb.h>
++#include <addrspace.h>
++#include <vm.h>
++
++/*
++ * Dumb MIPS-only "VM system" that is intended to only be just barely
++ * enough to struggle off the ground. You should replace all of this
++ * code while doing the VM assignment. In fact, starting in that
++ * assignment, this file is not included in your kernel!
++ */
++
++/* under dumbvm, always have 48k of user stack */
++#define DUMBVM_STACKPAGES    12
++
++/*
++ * Wrap rma_stealmem in a spinlock.
++ */
++static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
++
++void
++vm_bootstrap(void)
++{
++
++}
++
++static
++paddr_t
++getppages(unsigned long npages)
++{
++	paddr_t addr;
++
++	spinlock_acquire(&stealmem_lock);
++
++	addr = ram_stealmem(npages);
++	
++	spinlock_release(&stealmem_lock);
++	return addr;
++}
++
++/* Allocate/free some kernel-space virtual pages */
++vaddr_t 
++alloc_kpages(int npages)
++{
++	paddr_t pa;
++	pa = getppages(npages);
++	if (pa==0) {
++		return 0;
++	}
++	return PADDR_TO_KVADDR(pa);
++}
++
++void 
++free_kpages(vaddr_t addr)
++{
++	/* nothing - leak the memory. */
++
++	(void)addr;
++}
++
++void
++vm_tlbshootdown_all(void)
++{
++	panic("dumbvm tried to do tlb shootdown?!\n");
++}
++
++void
++vm_tlbshootdown(const struct tlbshootdown *ts)
++{
++	(void)ts;
++	panic("dumbvm tried to do tlb shootdown?!\n");
++}
++
++int
++vm_fault(int faulttype, vaddr_t faultaddress)
++{
++	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
++	paddr_t paddr;
++	int i;
++	uint32_t ehi, elo;
++	struct addrspace *as;
++	int spl;
++
++	faultaddress &= PAGE_FRAME;
++
++	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
++
++	switch (faulttype) {
++	    case VM_FAULT_READONLY:
++		/* We always create pages read-write, so we can't get this */
++		panic("dumbvm: got VM_FAULT_READONLY\n");
++	    case VM_FAULT_READ:
++	    case VM_FAULT_WRITE:
++		break;
++	    default:
++		return EINVAL;
++	}
++
++	as = curthread->t_addrspace;
++	if (as == NULL) {
++		/*
++		 * No address space set up. This is probably a kernel
++		 * fault early in boot. Return EFAULT so as to panic
++		 * instead of getting into an infinite faulting loop.
++		 */
++		return EFAULT;
++	}
++
++	/* Assert that the address space has been set up properly. */
++	KASSERT(as->as_vbase1 != 0);
++	KASSERT(as->as_pbase1 != 0);
++	KASSERT(as->as_npages1 != 0);
++	KASSERT(as->as_vbase2 != 0);
++	KASSERT(as->as_pbase2 != 0);
++	KASSERT(as->as_npages2 != 0);
++	KASSERT(as->as_stackpbase != 0);
++	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
++	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
++	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
++	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
++	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
++
++	vbase1 = as->as_vbase1;
++	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
++	vbase2 = as->as_vbase2;
++	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
++	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
++	stacktop = USERSTACK;
++
++	if (faultaddress >= vbase1 && faultaddress < vtop1) {
++		paddr = (faultaddress - vbase1) + as->as_pbase1;
++	}
++	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
++		paddr = (faultaddress - vbase2) + as->as_pbase2;
++	}
++	else if (faultaddress >= stackbase && faultaddress < stacktop) {
++		paddr = (faultaddress - stackbase) + as->as_stackpbase;
++	}
++	else {
++		return EFAULT;
++	}
++
++	/* make sure it's page-aligned */
++	KASSERT((paddr & PAGE_FRAME) == paddr);
++
++	/* Disable interrupts on this CPU while frobbing the TLB. */
++	spl = splhigh();
++
++	for (i=0; i<NUM_TLB; i++) {
++		tlb_read(&ehi, &elo, i);
++		if (elo & TLBLO_VALID) {
++			continue;
++		}
++		ehi = faultaddress;
++		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
++		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
++		tlb_write(ehi, elo, i);
++		splx(spl);
++		return 0;
++	}
++
++	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
++	splx(spl);
++	return EFAULT;
++}
++
++struct addrspace *
++as_create(void)
++{
++	struct addrspace *as = kmalloc(sizeof(struct addrspace));
++	if (as==NULL) {
++		return NULL;
++	}
++
++	as->as_vbase1 = 0;
++	as->as_pbase1 = 0;
++	as->as_npages1 = 0;
++	as->as_vbase2 = 0;
++	as->as_pbase2 = 0;
++	as->as_npages2 = 0;
++	as->as_stackpbase = 0;
++
++	return as;
++}
++
++void
++as_destroy(struct addrspace *as)
++{
++	kfree(as);
++}
++
++void
++as_activate(struct addrspace *as)
++{
++	int i, spl;
++
++	(void)as;
++
++	/* Disable interrupts on this CPU while frobbing the TLB. */
++	spl = splhigh();
++
++	for (i=0; i<NUM_TLB; i++) {
++		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
++	}
++
++	splx(spl);
++}
++
++int
++as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
++		 int readable, int writeable, int executable)
++{
++	size_t npages; 
++
++	/* Align the region. First, the base... */
++	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
++	vaddr &= PAGE_FRAME;
++
++	/* ...and now the length. */
++	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
++
++	npages = sz / PAGE_SIZE;
++
++	/* We don't use these - all pages are read-write */
++	(void)readable;
++	(void)writeable;
++	(void)executable;
++
++	if (as->as_vbase1 == 0) {
++		as->as_vbase1 = vaddr;
++		as->as_npages1 = npages;
++		return 0;
++	}
++
++	if (as->as_vbase2 == 0) {
++		as->as_vbase2 = vaddr;
++		as->as_npages2 = npages;
++		return 0;
++	}
++
++	/*
++	 * Support for more than two regions is not available.
++	 */
++	kprintf("dumbvm: Warning: too many regions\n");
++	return EUNIMP;
++}
++
++static
++void
++as_zero_region(paddr_t paddr, unsigned npages)
++{
++	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
++}
++
++int
++as_prepare_load(struct addrspace *as)
++{
++	KASSERT(as->as_pbase1 == 0);
++	KASSERT(as->as_pbase2 == 0);
++	KASSERT(as->as_stackpbase == 0);
++
++	as->as_pbase1 = getppages(as->as_npages1);
++	if (as->as_pbase1 == 0) {
++		return ENOMEM;
++	}
++
++	as->as_pbase2 = getppages(as->as_npages2);
++	if (as->as_pbase2 == 0) {
++		return ENOMEM;
++	}
++
++	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
++	if (as->as_stackpbase == 0) {
++		return ENOMEM;
++	}
++	
++	as_zero_region(as->as_pbase1, as->as_npages1);
++	as_zero_region(as->as_pbase2, as->as_npages2);
++	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
++
++	return 0;
++}
++
++int
++as_complete_load(struct addrspace *as)
++{
++	(void)as;
++	return 0;
++}
++
++int
++as_define_stack(struct addrspace *as, vaddr_t *stackptr)
++{
++	KASSERT(as->as_stackpbase != 0);
++
++	*stackptr = USERSTACK;
++	return 0;
++}
++
++int
++as_copy(struct addrspace *old, struct addrspace **ret)
++{
++	struct addrspace *new;
++
++	new = as_create();
++	if (new==NULL) {
++		return ENOMEM;
++	}
++
++	new->as_vbase1 = old->as_vbase1;
++	new->as_npages1 = old->as_npages1;
++	new->as_vbase2 = old->as_vbase2;
++	new->as_npages2 = old->as_npages2;
++
++	/* (Mis)use as_prepare_load to allocate some physical memory. */
++	if (as_prepare_load(new)) {
++		as_destroy(new);
++		return ENOMEM;
++	}
++
++	KASSERT(new->as_pbase1 != 0);
++	KASSERT(new->as_pbase2 != 0);
++	KASSERT(new->as_stackpbase != 0);
++
++	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
++		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
++		old->as_npages1*PAGE_SIZE);
++
++	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
++		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
++		old->as_npages2*PAGE_SIZE);
++
++	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
++		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
++		DUMBVM_STACKPAGES*PAGE_SIZE);
++	
++	*ret = new;
++	return 0;
++}
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..64c18e0 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -330,6 +330,7 @@ file      thread/threadlist.c
+ #
+ 
+ file      vm/kmalloc.c
++file	  vm/vm.c
+ 
+ optofffile dumbvm   vm/addrspace.c
+ 
+@@ -367,6 +368,8 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file	  syscall/file_syscalls.c
++file	  syscall/process.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
+index 6788e97..775ec57 100644
+--- a/kern/include/addrspace.h
++++ b/kern/include/addrspace.h
+@@ -47,6 +47,19 @@ struct vnode;
+  *
+  * You write this.
+  */
++struct pagetable{
++	vaddr_t viraddress;
++	paddr_t phyaddress;
++	uint32_t permissions;
++	struct pagetable *next;
++};
++
++struct region{
++	vaddr_t viraddress;
++	size_t numpages;
++	uint32_t permissions;
++	struct region *next;
++};
+ 
+ struct addrspace {
+ #if OPT_DUMBVM
+@@ -59,9 +72,17 @@ struct addrspace {
+         paddr_t as_stackpbase;
+ #else
+         /* Put stuff here for your VM system */
++        struct region *reg;
++        struct pagetable *table;
++        vaddr_t sbase;
++        vaddr_t stop;
++        vaddr_t hbase;
++        vaddr_t htop;
+ #endif
+ };
+ 
++
++
+ /*
+  * Functions in addrspace.c:
+  *
+@@ -110,6 +131,8 @@ int               as_prepare_load(struct addrspace *as);
+ int               as_complete_load(struct addrspace *as);
+ int               as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
+ 
++struct pagetable * as_pagetable_entry(struct addrspace *as, vaddr_t faultaddress);
++uint32_t as_permissions(struct addrspace *as, vaddr_t faultaddress);
+ 
+ /*
+  * Functions in loadelf.c
+diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
+new file mode 100644
+index 0000000..40e3f6c
+--- /dev/null
++++ b/kern/include/fcntl.h
+@@ -0,0 +1,100 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_FCNTL_H_
++#define _KERN_FCNTL_H_
++
++/*
++ * Constants for libc's <fcntl.h>.
++ */
++
++
++/*
++ * Important
++ */
++
++/* Flags for open: choose one of these: */
++#define O_RDONLY      0      /* Open for read */
++#define O_WRONLY      1      /* Open for write */
++#define O_RDWR        2      /* Open for read and write */
++/* then or in any of these: */
++#define O_CREAT       4      /* Create file if it doesn't exist */
++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
++#define O_TRUNC      16      /* Truncate file upon open */
++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
++
++/* Additional related definition */
++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
++
++/*
++ * Not so important
++ */
++
++/* operation codes for flock() */
++#define LOCK_SH         1       /* shared lock */
++#define LOCK_EX         2       /* exclusive lock */
++#define LOCK_UN         3       /* release the lock */
++#define LOCK_NB         4       /* flag: don't block */
++
++/*
++ * Mostly pretty useless
++ */
++
++/* fcntl() operations */
++#define F_DUPFD         0       /* like dup() but not quite */  
++#define F_GETFD         1       /* get per-handle flags */
++#define F_SETFD         2       /* set per-handle flags */
++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
++#define F_GETLK         7       /* inspect record locks */
++#define F_SETLK         8       /* acquire record locks nonblocking */
++#define F_SETLKW        9       /* acquire record locks and wait */
++
++/* flag for F_GETFD and F_SETFD */
++#define FD_CLOEXEC      1       /* close-on-exec */
++
++/* modes for fcntl (F_GETLK/SETLK) locking */
++#define F_RDLCK         0       /* shared lock */
++#define F_WRLCK         1       /* exclusive lock */
++#define F_UNLCK         2       /* unlock */
++
++/* struct for fcntl (F_GETLK/SETLK) locking */
++struct flock {
++	off_t l_start;          /* place in file */
++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
++	int l_type;             /* F_RDLCK or F_WRLCK */
++	off_t l_len;            /* length of locked region */
++	pid_t l_pid;            /* process that holds the lock */
++};
++
++
++#endif /* _KERN_FCNTL_H_ */
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..a1941ec 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -96,5 +96,11 @@
+ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+ #define __IOV_MAX       1024
+ 
++/* Max number of process which can run on os161*/
++#define _MAX_RUNNING_PROCS 400
++
++
++/*Maximum number of file table entry per process */
++#define _MAX_FILE 10
+ 
+ #endif /* _KERN_LIMITS_H_ */
+diff --git a/kern/include/kern/types.h b/kern/include/kern/types.h
+index 002d3b7..285d626 100644
+--- a/kern/include/kern/types.h
++++ b/kern/include/kern/types.h
+@@ -79,6 +79,7 @@ typedef __u64 __rlim_t;    /* Resource limit quantity */
+ typedef __u8 __sa_family_t;/* Socket address family */
+ typedef __i64 __time_t;    /* Time in seconds */
+ typedef __i32 __uid_t;     /* User ID */
++//typedef __u32 __pstate_t;  /* Physical Page State*/
+ 
+ typedef int __nfds_t;    /* Number of file handles */
+ typedef int __socklen_t;   /* Socket-related length */
+diff --git a/kern/include/lib.h b/kern/include/lib.h
+index da04195..78c310f 100644
+--- a/kern/include/lib.h
++++ b/kern/include/lib.h
+@@ -189,7 +189,9 @@ void kprintf_bootstrap(void);
+  */
+ 
+ #define DIVROUNDUP(a,b) (((a)+(b)-1)/(b))
++#define DIVROUNDDOWN(a,b) (((a)+(b)+1)/(b))
+ #define ROUNDUP(a,b)    (DIVROUNDUP(a,b)*b)
++#define ROUNDDOWN(a,b)  (((a)-(b))/(b) ) //(DIVROUNDDOWN(a,b)*b)
+ 
+ void random_yielder(uint32_t);
+ void random_spinner(uint32_t);
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..81ec912 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,7 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++#define MAX_RUNNING_PROCS _MAX_RUNNING_PROCS
++#define MAX_FILE _MAX_FILE
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/process.h b/kern/include/process.h
+new file mode 100644
+index 0000000..fe29960
+--- /dev/null
++++ b/kern/include/process.h
+@@ -0,0 +1,114 @@
++/*
++ * process.h
++ *
++ *  	Created on: Mar 8, 2014
++ *      Author: Babu
++ */
++
++#ifndef PROCESS_H_
++#define PROCESS_H_
++
++#include <spinlock.h>
++
++struct trapframe;
++
++/*
++ * Process table which holds all information about the process
++ * such as pid, parent process, threads belongs to that process
++ *
++ */
++struct process {
++
++	pid_t p_pid_self;  /* process id of the process */
++
++	struct thread *p_thread;
++
++	pid_t p_pid_parent;
++
++	// Variables for process exit
++	bool p_exited;
++
++	int p_exitcode;
++
++	struct semaphore *p_exitsem;
++};
++
++
++
++/** process table as linked list */
++struct process_list
++{
++	struct process *process_info;
++	struct process_list *next;
++};
++
++struct process_list *proc_table;
++
++struct spinlock proc_lock;
++
++/**
++ * When a process exits it should invoke this method so that
++ * this will add the allocated pid to free pool which can be assigned
++ * for other process  - Added by Babu
++ */
++void add_pid_to_pool(pid_t);
++
++/**
++ * Allocate pid based on the pids available in the pool or
++ * generate from the counter if the pool is empty  - Added by Babu
++ */
++pid_t allocate_pid(void);
++
++/**
++ * function to destroy process and it related book keeping stuffs
++ */
++void process_destroy(struct process *process);
++
++
++/**
++ * getpid system call which fetches the pid of the calling process
++ */
++pid_t sys_getpid(int32_t *retval);
++
++/**
++ * getppid system call which fetches the pid of the calling process parent
++ */
++pid_t sys_getppid(int32_t *retval);
++
++/**
++ * exit system call which allows the calling process to exit
++ */
++void sys__exit(int exitcode);
++
++/**
++ * wait system call allows the calling process' parent to collect the status of child process
++ */
++int sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags);
++
++/**
++ * fork system call which creates clone of the calling process
++ */
++int sys_fork(int32_t *retval, struct trapframe *tf);
++
++/**
++ * execv system call allows create process from the file and loads into address space and executes
++ */
++int sys_execv(userptr_t prgname, userptr_t argv[]);
++
++/**
++ * Entry point function for the child process/thread created by fork()
++ */
++void child_entrypoint(void *data1, unsigned long data2);
++
++/**
++ * Find process in process table
++ */
++struct process_list * process_lookup(pid_t pid_lookup);
++
++/**
++ * Find process in process table
++ */
++void addto_proc_table(struct process *proc);
++
++
++#endif /* PROCESS_H_ */
+diff --git a/kern/include/seek.h b/kern/include/seek.h
+new file mode 100644
+index 0000000..cf1cfe6
+--- /dev/null
++++ b/kern/include/seek.h
+@@ -0,0 +1,47 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_SEEK_H_
++#define _KERN_SEEK_H_
++
++/*
++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
++ * <unistd.h> and thus get their own file.
++ *
++ * These are pretty important. Back in the day (like 20+ years ago)
++ * people would often just write the values 0, 1, and 2, but that's
++ * really not recommended.
++ */
++
++#define SEEK_SET      0      /* Seek relative to beginning of file */
++#define SEEK_CUR      1      /* Seek relative to current position in file */
++#define SEEK_END      2      /* Seek relative to end of file */
++
++
++#endif /* _KERN_SEEK_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..35565c6 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        //added by vasanth
++        volatile struct thread *lock_owner;
++        struct wchan *lock_wchan;
++        struct spinlock spn_lock;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_waitchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ /*
+  * 13 Feb 2012 : GWA : Reader-writer locks.
+  */
+-
++/* we use two waiting channels one for reader and one for writer we do this so that
++ *if a writer is waiting all the readers will be put on sleep until the writers are
++ *done with their writing
++ */
+ struct rwlock {
+         char *rwlock_name;
++        volatile int num_reader;
++        volatile int num_writer;
++        struct wchan *rlock_wchan;
++        struct wchan *wlock_wchan;
++        struct lock *rw_lock;
++
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..52c242a 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -27,6 +27,9 @@
+  * SUCH DAMAGE.
+  */
+ 
++#include <process.h>
++
++
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+ 
+@@ -57,5 +60,13 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+-
++int open(userptr_t filename, int flags,int *err);
++int close(int fd);
++int read(int fd, userptr_t buf, size_t buflen,int *err);
++int write(int fd, userptr_t buf, size_t buflen,int *err);
++int dup2(int oldfd, int newfd,int *err);
++off_t lseek(int fd,off_t pos, int whence, int *err);
++int chdir(const_userptr_t pathname);
++int __getcwd(userptr_t buf, size_t buflen,int *err);
++int sys_remove(userptr_t p);
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..71dc1ed 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -63,16 +63,25 @@ void whalemating_cleanup(void);
+  * Traffic light.
+  */
+ 
+-void inQuadrant(int);
++//volatile unsigned long intersectionOccupied = 0;
++
++/**
++* Added by Babu:
++* Locks for each quadrants
++**/
++
++
++
+ void leaveIntersection(void);
+ int stoplight(int, char **);
+-
++void inQuadrant(int);
+ void gostraight(void *, unsigned long);
+ void turnleft(void *, unsigned long);
+ void turnright(void *, unsigned long);
+ void stoplight_init(void);
+ void stoplight_cleanup(void);
+ 
++
+ /*
+  * Test code.
+  */
+@@ -105,7 +114,7 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++int runprogram(char *progname, char *argv[],  unsigned long argc);
+ 
+ /* Kernel menu system. */
+ void menu(char *argstr);
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..31a1868 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,7 +38,7 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
+-
++#include <limits.h>
+ struct addrspace;
+ struct cpu;
+ struct vnode;
+@@ -57,6 +57,7 @@ struct vnode;
+ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
+ 
+ 
++
+ /* States a thread can be in. */
+ typedef enum {
+ 	S_RUN,		/* running */
+@@ -65,6 +66,15 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++struct fTable{
++	    char *name;
++	    int status;
++	    off_t offset;
++	    int ref_count;
++	    struct lock *lock;
++	    struct vnode *vn;
++	};
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -101,9 +111,16 @@ struct thread {
+ 	int t_curspl;			/* Current spl*() state */
+ 	int t_iplhigh_count;		/* # of times IPL has been raised */
+ 
++
++
+ 	/*
+ 	 * Public fields
+ 	 */
++	/**
++	 * Added by Babu :
++	 * pointer to parent process data structure
++	 */
++	struct process *t_process;
+ 
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+@@ -112,8 +129,11 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
++	int priority;
+ };
+ 
++
+ /* Call once during system startup to allocate data structures. */
+ void thread_bootstrap(void);
+ 
+diff --git a/kern/include/types.h b/kern/include/types.h
+index e031bde..a078f39 100644
+--- a/kern/include/types.h
++++ b/kern/include/types.h
+@@ -129,6 +129,7 @@ typedef __rlim_t rlim_t;
+ typedef __sa_family_t sa_family_t;
+ typedef __time_t time_t;
+ typedef __uid_t uid_t;
++//typedef __pstate_t page_state_t;
+ 
+ typedef __nfds_t nfds_t;
+ typedef __socklen_t socklen_t;
+diff --git a/kern/include/unistd.h b/kern/include/unistd.h
+new file mode 100644
+index 0000000..30f2678
+--- /dev/null
++++ b/kern/include/unistd.h
+@@ -0,0 +1,39 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_UNISTD_H_
++#define _KERN_UNISTD_H_
++
++/* Constants for read/write/etc: special file handles */
++#define STDIN_FILENO  0      /* Standard input */
++#define STDOUT_FILENO 1      /* Standard output */
++#define STDERR_FILENO 2      /* Standard error */
++
++
++#endif /* _KERN_UNISTD_H_ */
+diff --git a/kern/include/vm.h b/kern/include/vm.h
+index e4e73d0..55ae4cc 100644
+--- a/kern/include/vm.h
++++ b/kern/include/vm.h
+@@ -44,6 +44,46 @@
+ #define VM_FAULT_WRITE       1    /* A write was attempted */
+ #define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
+ 
++enum page_state
++{
++	FREE,
++	FIXED,
++	DIRTY,
++	CLEAN
++};
++
++/**
++ * CoreMap Structure for storing information
++ * about the pages in physical memory
++ *
++ * Author : Babu
++ */
++struct page
++{
++	// Address space
++	struct addrspace *addrspce;
++
++	// Virtual Address
++	vaddr_t virtual_addr;
++
++	// Physical page state (used for swapping)
++	enum page_state page_state;
++
++	// Incase of n-continuous page allocation store that information also
++	int32_t num_pages;
++
++	// For FIFO- Paging algorithm
++	uint64_t timestamp;
++
++};
++
++#define CME_SIZE (sizeof(struct page))
++
++// CoreMap
++struct page *pages;
++
++// Total Page number
++uint32_t page_num;
+ 
+ /* Initialization function */
+ void vm_bootstrap(void);
+@@ -55,6 +95,14 @@ int vm_fault(int faulttype, vaddr_t faultaddress);
+ vaddr_t alloc_kpages(int npages);
+ void free_kpages(vaddr_t addr);
+ 
++/*Allocate/free user pages (called by malloc/free)*/
++vaddr_t page_alloc(void);
++vaddr_t page_nalloc(unsigned long npages);
++void page_free(vaddr_t addr);
++
++/*Make the page available by swapping or by flushing*/
++int32_t make_page_avail(struct page *page);
++
+ /* TLB shootdown handling called from interprocessor_interrupt */
+ void vm_tlbshootdown_all(void);
+ void vm_tlbshootdown(const struct tlbshootdown *);
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..1ba112a 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -1,3 +1,4 @@
++/*vsubrama@buffalo.edu*/
+ /*
+  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+  *	The President and Fellows of Harvard College.
+@@ -100,7 +101,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("babupras@buffalo.edu vsubrama@buffalo.edu 's system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..71e7e2b 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -86,6 +86,8 @@ void
+ cmd_progthread(void *ptr, unsigned long nargs)
+ {
+ 	char **args = ptr;
++	//char args[] ;
++	//strcpy(args[i])
+ 	char progname[128];
+ 	int result;
+ 
+@@ -93,14 +95,17 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	if (nargs > 2) {
+ 		kprintf("Warning: argument passing from menu not supported\n");
++		//kprintf("Multiple arguments passed : %d \n",(int)nargs);
+ 	}
+ 
+ 	/* Hope we fit. */
++	//kprintf("Passed function name %s\n",args[0]);
+ 	KASSERT(strlen(args[0]) < sizeof(progname));
++	strcpy(progname,args[0]);
+ 
+-	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	//kprintf("progname : %s\n", progname);
++	result = runprogram(args[0], args, nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -133,10 +138,32 @@ common_prog(int nargs, char **args)
+ 		"synchronization-problems kernel.\n");
+ #endif
+ 
++	struct thread *newthread = NULL;
++	pid_t retpid ;
++	//struct thread *parentthread = curthread;
++	int status = 0 , err = 0;
++	//kprintf("before thread fork args  : %s, %s\n", args[0], args[1]);
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&newthread);
++
++	if(newthread != NULL)
++	{
++		// Parent wait
++
++		//err = waitpid(newthread->t_process->p_pid_self, &status, 1);
++		err = sys_waitpid(&retpid, newthread->t_process->p_pid_self, &status, 0);
++		if(err != 0)
++		{
++			kprintf("wait not success : %d\n", err);
++		}
++	}
++	// child wait
++	//something like this is expected please do --vasanth
++	//int s_wait;
++
++	//sys_waitpid(NULL, fork_Thread->t_process->p_pid_self,&s_wait,0);
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+@@ -157,6 +184,8 @@ cmd_prog(int nargs, char **args)
+ 		return EINVAL;
+ 	}
+ 
++	//kprintf("cmd_prg args  : %s, %s\n", args[0], args[1]);
++
+ 	/* drop the leading "p" */
+ 	args++;
+ 	nargs--;
+@@ -579,6 +608,8 @@ cmd_dispatch(char *cmd)
+ 	char *context;
+ 	int i, result;
+ 
++	//kprintf("cmd : %s\n",cmd);
++
+ 	for (word = strtok_r(cmd, " \t", &context);
+ 	     word != NULL;
+ 	     word = strtok_r(NULL, " \t", &context)) {
+@@ -587,7 +618,9 @@ cmd_dispatch(char *cmd)
+ 			kprintf("Command line has too many words\n");
+ 			return E2BIG;
+ 		}
++		//kprintf("original wrd :%s\n",word);
+ 		args[nargs++] = word;
++		//kprintf("args :%s\n",args[nargs-1]);
+ 	}
+ 
+ 	if (nargs==0) {
+diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
+index 02e336f..05d3d21 100644
+--- a/kern/synchprobs/drivers.c
++++ b/kern/synchprobs/drivers.c
+@@ -148,7 +148,7 @@ inline void leaveIntersection() {
+ 	kprintf("%s left the intersection\n", curthread->t_name);
+ }
+ 
+-#define NCARS 99
++#define NCARS 10
+ 
+ struct semaphore * stoplightMenuSemaphore;
+ 
+@@ -158,12 +158,13 @@ int stoplight(int nargs, char **args) {
+ 	int i, direction, turn, err = 0;
+ 	char name[32];
+ 
++	kprintf("Stop light called\n");
++	stoplight_init();
+ 	stoplightMenuSemaphore = sem_create("Stoplight Driver Semaphore", 0);
+ 	if (stoplightMenuSemaphore == NULL ) {
+ 		panic("stoplight: sem_create failed.\n");
+ 	}
+ 
+-	stoplight_init();
+ 
+ 	for (i = 0; i < NCARS; i++) {
+ 
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..3c50d3d 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -35,6 +35,33 @@
+ #include <thread.h>
+ #include <test.h>
+ #include <synch.h>
++#include <wchan.h>
++
++/*Locks for each quadrant - Babu*/
++struct lock *lockquad0;
++struct lock *lockquad1;
++struct lock *lockquad2;
++struct lock *lockquad3;
++
++/*Get the corresponding lock for the destination quadrant */
++struct lock *getlock(int destQuadrant);
++
++struct whalemating
++{
++	volatile int num_male_whale;
++	volatile int num_female_whale;
++	volatile int num_matchmaker_whale;
++	struct wchan *male_wchan;
++	struct wchan *female_wchan;
++	struct wchan *matchmaker_wchan;
++	struct wchan *match_wchan;
++	volatile int match_found;
++	struct lock *lock;
++	volatile int match_male;
++	volatile int match_female;
++};
++struct whalemating *whale_mating;
++
+ 
+ /*
+  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
+@@ -48,6 +75,61 @@
+ // the top of the corresponding driver code.
+ 
+ void whalemating_init() {
++
++
++	whale_mating = kmalloc(sizeof(struct whalemating));
++	if (whale_mating == NULL)
++	{
++		return;
++	}
++	whale_mating->male_wchan = wchan_create("name");
++	if (whale_mating->male_wchan == NULL)
++	{
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->female_wchan = wchan_create("name");
++	if (whale_mating->female_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->matchmaker_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->match_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++		{
++			wchan_destroy(whale_mating->male_wchan);
++			wchan_destroy(whale_mating->female_wchan);
++			wchan_destroy(whale_mating->match_wchan);
++			kfree(whale_mating);
++			return;
++		}
++	whale_mating->lock = lock_create("name");
++	if (whale_mating->lock == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		wchan_destroy(whale_mating->matchmaker_wchan);
++		wchan_destroy(whale_mating->match_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->num_male_whale = 0;
++	whale_mating->num_female_whale = 0;
++	whale_mating->num_matchmaker_whale = 0;
++	whale_mating->match_found=0;
++	whale_mating->match_male=0;
++	whale_mating->match_female=0;
++
++
+   return;
+ }
+ 
+@@ -55,6 +137,12 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++	wchan_destroy(whale_mating->male_wchan);
++	wchan_destroy(whale_mating->female_wchan);
++	wchan_destroy(whale_mating->matchmaker_wchan);
++	wchan_destroy(whale_mating->match_wchan);
++	lock_destroy(whale_mating->lock);
++	kfree(whale_mating);
+   return;
+ }
+ 
+@@ -64,9 +152,26 @@ male(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+-  male_start();
+-	// Implement this function 
+-  male_end();
++ lock_acquire(whale_mating->lock);
++ male_start();
++	// Implement this function
++
++ while(whale_mating->num_male_whale>=1)
++ {
++   wchan_lock(whale_mating->male_wchan);
++   lock_release(whale_mating->lock);
++   wchan_sleep(whale_mating->male_wchan);
++   lock_acquire(whale_mating->lock);
++ }
++ whale_mating->num_male_whale++;
++ wchan_wakeall(whale_mating->match_wchan);
++ while(!(whale_mating->match_found==1))
++ {
++	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++ }
++ whale_mating->match_male=1;
++ male_end();
++ lock_release(whale_mating->lock);
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -80,32 +185,78 @@ female(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
++  lock_acquire(whale_mating->lock);
+   female_start();
+-	// Implement this function 
++
++	// Implement this function
++
++   while(whale_mating->num_female_whale>=1)
++   {
++     wchan_lock(whale_mating->female_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->female_wchan);lock_acquire(whale_mating->lock);
++   }
++   whale_mating->num_female_whale++;
++   wchan_wakeall(whale_mating->match_wchan);
++   while(!(whale_mating->match_found==1))
++   {
++  	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++   }
++  whale_mating->match_female=1;
+   female_end();
+-  
++  lock_release(whale_mating->lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ void
+ matchmaker(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++  lock_acquire(whale_mating->lock);
+   matchmaker_start();
+-	// Implement this function 
++  while(whale_mating->num_matchmaker_whale>=1)
++  {
++     wchan_lock(whale_mating->matchmaker_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->matchmaker_wchan);lock_acquire(whale_mating->lock);
++  }
++  whale_mating->num_matchmaker_whale++;
++  wchan_wakeall(whale_mating->match_wchan);
++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
++  {
++	  wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_found=1;
++  wchan_wakeall(whale_mating->match_wchan);
++  while(whale_mating->match_male!=1 || whale_mating->match_female!=1)
++  {
++  lock_release(whale_mating->lock);
++  lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_male=0;
++  whale_mating->match_female=0;
++  whale_mating->num_male_whale--;
++  whale_mating->num_female_whale--;
++  whale_mating->num_matchmaker_whale--;
++
++  wchan_wakeall(whale_mating->male_wchan);
++  wchan_wakeall(whale_mating->female_wchan);
++  wchan_wakeall(whale_mating->matchmaker_wchan);
++
++	// Implement this function
++  whale_mating->match_found=0;
+   matchmaker_end();
+-  
++  lock_release(whale_mating->lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -133,27 +284,55 @@ matchmaker(void *p, unsigned long which)
+  * functions in drivers.c.
+  */
+ 
++/**
++ * Added by Babu : 27 Feb 2012
++ * Solving Stop light problem with the help
++ * of locks and predefined semaphores.
++ */
++
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
+ void stoplight_init() {
+-  return;
++
++	lockquad0 = lock_create("quad0lk");
++	lockquad1 = lock_create("quad1lk");
++	lockquad2 = lock_create("quad2lk");
++	lockquad3 = lock_create("quad3lk");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	lock_destroy(lockquad0);
++	lock_destroy(lockquad1);
++	lock_destroy(lockquad2);
++	lock_destroy(lockquad3);
++	return;
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	kprintf("go straight....\n");
++
++	lock_acquire(getlock(destQuadrant1));
++	lock_acquire(getlock(destQuadrant2));
++
++	inQuadrant(destQuadrant1);
++	inQuadrant(destQuadrant2);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant2));
++	lock_release(getlock(destQuadrant1));
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -163,8 +342,24 @@ gostraight(void *p, unsigned long direction)
+ void
+ turnleft(void *p, unsigned long direction)
+ {
++	kprintf("turn left....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	unsigned long destQuadrant3 = (direction + 2) % 4;
++
++	lock_acquire(getlock(destQuadrant1));
++	lock_acquire(getlock(destQuadrant2));
++	lock_acquire(getlock(destQuadrant3));
++
++	inQuadrant(destQuadrant1);
++	inQuadrant(destQuadrant2);
++	inQuadrant(destQuadrant3);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant3));
++	lock_release(getlock(destQuadrant2));
++	lock_release(getlock(destQuadrant1));
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -175,11 +370,58 @@ turnleft(void *p, unsigned long direction)
+ void
+ turnright(void *p, unsigned long direction)
+ {
++	kprintf("turn right....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++
++	lock_acquire(getlock(destQuadrant1));
++
++	inQuadrant(destQuadrant1);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant1));
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+   return;
+ }
++
++/*
++ * Added by Babu
++ * Function which serve as a wrapper to get the correct inQuadrant
++ * locks based on the direction passed
++ */
++struct lock *
++getlock(int destQuadrant)
++{
++	struct lock *lockquad;
++	switch (destQuadrant)
++	{
++		case 0:
++			lockquad = lockquad0;
++			break;
++		case 1:
++			lockquad = lockquad1;
++			break;
++		case 2:
++			lockquad = lockquad2;
++			break;
++		case 3:
++			lockquad = lockquad3;
++			break;
++		default:
++			panic("unknown direction");
++			break;
++	}
++
++	/* If the lock is not held before, then acquire it */
++	/*if(lock_do_i_hold(lockquad))
++	{
++		lock_acquire(lockquad);
++		inQuadrant(destQuadrant);
++		lock_release(lockquad);
++	}*/
++	return lockquad;
++
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..01f8566
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,352 @@
++/*
++ * file_syscalls.c
++ *
++ *  Created on: Mar 8, 2014
++ *      Author: trinity
++ */
++#include <types.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <thread.h>
++#include <syscall.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <fcntl.h>
++#include <current.h>
++#include <synch.h>
++
++#include <uio.h>
++#include <kern/iovec.h>
++#include <seek.h>
++#include <stat.h>
++#include <kern/errno.h>
++
++int
++open(userptr_t filename, int flags,int *err)
++{
++	char *iobuff;
++	int rFlag,vfs_ret;
++	size_t aSize;
++	if (filename == NULL)
++	{
++		*err = EFAULT;
++		 return -1;
++	}
++	int tflags = flags & O_ACCMODE;
++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
++	{
++		kprintf("Failing in arguments\n");
++		*err = EINVAL;
++		return -1;
++	}
++	int i;
++	for ( i=0;i<OPEN_MAX;i++)
++	{
++		if (curthread->ft[i] == NULL)
++		{
++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++			if (curthread->ft[i] == NULL)
++			{
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->lock = lock_create(curthread->t_name);
++			if (curthread->ft[i]->lock == NULL)
++			{
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->offset=0;
++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++			curthread->ft[i]->status = flags;
++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
++			if (iobuff == NULL)
++			{
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
++			if(rFlag)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = EFAULT;
++				return -1;
++			}
++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++			if(vfs_ret)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = vfs_ret;
++				return -1;
++			}
++			*err = vfs_ret;
++			return i;
++		}
++	}
++	return 0;
++}
++int close(int fd)
++{
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		return EBADF;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		return EBADF;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++	if(curthread->ft[fd]->ref_count == 0)
++	{
++		vfs_close(curthread->ft[fd]->vn);
++		lock_release(curthread->ft[fd]->lock);
++		lock_destroy(curthread->ft[fd]->lock);
++		kfree(curthread->ft[fd]);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	else
++	{
++		lock_release(curthread->ft[fd]->lock);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	return 0;
++}
++
++int
++read(int fd, userptr_t buf, size_t buflen,int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_READ;
++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err = 0;
++	return diff;
++}
++int
++write(int fd, userptr_t buf, size_t buflen, int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_WRITE;
++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err=0;
++	return diff;
++}
++off_t
++lseek(int fd,off_t pos, int whence,int *err)
++{
++	off_t nPos=0;
++	struct stat eoFILE;
++	//kprintf("lseek entered\n");
++	if ( fd < 0 || fd > OPEN_MAX)
++		{
++			*err = EBADF;
++			 return -1;
++		}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("curthread->ft[fd] == NULL\n");
++
++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
++	{
++		*err = EINVAL;
++		return -1;
++	}
++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
++	//kprintf("Acquiring lock\n");
++	lock_acquire(curthread->ft[fd]->lock);
++	//kprintf("Stat gathering\n");
++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++	if (whence == SEEK_SET)
++	{
++		nPos = pos;
++	}
++	if (whence == SEEK_CUR)
++	{
++		nPos = curthread->ft[fd]->offset+pos;
++	}
++	if (whence == SEEK_END)
++	{
++		nPos = eoFILE.st_size+pos;
++	}
++	if (nPos < 0)
++	{
++		*err = EINVAL;
++		lock_release(curthread->ft[fd]->lock);
++		return -1;
++	}
++	//kprintf("NPos %llu\n",nPos);
++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++	if (*err)
++	{
++		lock_release(curthread->ft[fd]->lock);
++	    return -1;
++	}
++	curthread->ft[fd]->offset = nPos;
++	lock_release(curthread->ft[fd]->lock);
++	//kprintf("New position  %llu\n",nPos);
++	return curthread->ft[fd]->offset;
++}
++int
++dup2(int ofile_desc, int nfile_desc,int *err)
++{
++		if ( ofile_desc < 0 || ofile_desc > OPEN_MAX || nfile_desc < 0 ||
++				nfile_desc > OPEN_MAX || curthread->ft[ofile_desc] == NULL || curthread->ft[nfile_desc] == NULL)
++		{
++			*err = EBADF;
++			return -1;
++		}
++		if (curthread->ft[ofile_desc] == curthread->ft[nfile_desc] || ofile_desc == nfile_desc)
++		{
++		    return ofile_desc;
++		}
++		if (curthread->ft[nfile_desc] != NULL)
++		{
++		   *err = close(nfile_desc);
++		   if (*err)
++		      return -1;
++		}
++		curthread->ft[nfile_desc] = curthread->ft[ofile_desc];
++		lock_acquire(curthread->ft[nfile_desc]->lock);
++		curthread->ft[nfile_desc]->ref_count++;
++		lock_release(curthread->ft[nfile_desc]->lock);
++		return nfile_desc;
++}
++
++int
++chdir(const_userptr_t pathname)
++{
++	char new_path[PATH_MAX];
++	size_t get;
++
++	if (pathname == NULL)
++	{
++		return EFAULT;
++	}
++
++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
++
++	if (ret)
++	{
++		return EFAULT;
++	}
++
++	return vfs_chdir(new_path);
++}
++int
++__getcwd(userptr_t buf, size_t buflen,int *err)
++{
++	char path[PATH_MAX];
++	struct iovec iov;
++	struct uio uio;
++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
++	*err = vfs_getcwd(&uio);
++	if (*err)
++	{
++		return -1;
++	}
++	*err = copyout((userptr_t)path,buf,buflen);
++	if (*err)
++	{
++		return -1;
++	}
++	return uio.uio_offset;
++}
++int
++sys_remove(userptr_t p)
++{
++	char pbuf_store[PATH_MAX];
++	int err;
++
++	err = copyinstr(p, pbuf_store, sizeof(pbuf_store), NULL);
++	if (!err) {
++		return vfs_remove(pbuf_store);
++	}
++	else {
++		return err;
++	}
++}
+diff --git a/kern/syscall/process.c b/kern/syscall/process.c
+new file mode 100644
+index 0000000..dbe5e90
+--- /dev/null
++++ b/kern/syscall/process.c
+@@ -0,0 +1,685 @@
++/*
++ * process.c
++ *
++ *  Created on: Mar 8, 2014
++ *  Author: Babu
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++#include <addrspace.h>
++#include <spl.h>
++#include <synch.h>
++#include <limits.h>
++#include <kern/fcntl.h>
++#include <copyinout.h>
++#include <vfs.h>
++#include <kern/wait.h>
++#include <process.h>
++#include <copyinout.h>
++
++//extern struct spinlock proc_lock;
++
++/**
++ * Added by Babu:
++ * Pid pool to maintain the free available pids
++ */
++struct pid_pool
++{
++	pid_t pid_avail; // Available pid
++	struct pid_pool *next; // Point to next available pid
++};
++
++
++// Golbal PID counter
++pid_t global_pid_count = 1;
++
++/* Head and tail pointer for query and insert operation from pool which
++ * follows FIFO approach - Added by Babu
++ */
++struct pid_pool *head = NULL;
++struct pid_pool *tail = NULL;
++
++
++
++/**
++ * When a process exits it should invoke this method so that
++ * this will add the allocated pid to free pool which can be assigned
++ * for other process  - Added by Babu
++ */
++void
++add_pid_to_pool(pid_t pid_free)
++{
++	if(tail == NULL)
++	{
++		tail = kmalloc(sizeof(struct pid_pool));
++		if(tail != NULL)
++			tail->pid_avail = pid_free;
++		else
++			panic("not able to add pid");
++	}
++	else
++	{
++		tail->next = kmalloc(sizeof(struct pid_pool));
++		if(tail->next != NULL)
++		{
++			tail = tail->next;
++			tail->pid_avail = pid_free;
++		}
++	}
++	if(head == NULL)
++		head = tail;
++
++}
++
++/**
++ * Allocate pid based on the pids available in the pool or
++ * generate from the counter if the pool is empty  - Added by Babu
++ */
++pid_t
++allocate_pid()
++{
++	pid_t pid_alloc;
++	struct pid_pool *temp;
++	if(head == NULL)
++	{
++		if(global_pid_count < PID_MAX)
++			pid_alloc = global_pid_count++;
++		else
++			return ENOMEM;
++	}
++	else
++	{
++		pid_alloc = head->pid_avail;
++		temp = head;
++		if(head == tail)
++		{
++			head = NULL;
++			tail = NULL;
++		}
++		else
++			head = head->next;
++		kfree(temp);
++	}
++	return pid_alloc;
++}
++
++/**
++ * Added by Babu : 04/02/2014
++ * Function to destroy process structure
++ */
++void
++process_destroy(struct process *process)
++{
++   //int retval = -1;
++	/* Adding pid to available pool so that it can be allocated to other processes	 */
++	add_pid_to_pool(process->p_pid_self);
++	sem_destroy(process->p_exitsem);
++	//processtable[(int)process->p_pid_self] = NULL;
++	(process_lookup(process->p_pid_self))->process_info = NULL;
++
++	kfree(process);
++	return;
++}
++
++/**
++ * Added by Babu on : 04/01/2014
++ * Get pid of the calling process
++ */
++pid_t
++sys_getpid(int32_t *retval)
++{
++	if(curthread != NULL)
++	{
++		if(curthread->t_process != NULL)
++		{
++			//*retval = *curthread->t_process->p_pid_self;
++			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
++			return 0;
++		}
++	}
++	return 1;
++}
++
++/**
++ * Added by Babu on : 04/01/2014
++ * Get pid of the calling process
++ */
++pid_t
++sys_getppid(int32_t *retval)
++{
++	if(curthread != NULL)
++	{
++		if(curthread->t_process != NULL)
++		{
++			//*retval = *curthread->t_process->p_pid_parent;
++			memcpy(retval, &curthread->t_process->p_pid_parent, sizeof(pid_t));
++			return 0;
++		}
++	}
++	return 1;
++}
++
++/**
++ * Added by Babu : 04/02/2014warn
++ * Waitpid will wait for the process to change status/destroyed and collect the return status
++ * process which are not collected the return status remain as 'zombies'
++ */
++int
++sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags)
++{
++	//kprintf("Waiting for %d",pid);
++	int err = -1;
++
++	struct process *childprocess = (process_lookup(pid))->process_info;
++	if(childprocess == NULL)
++		return EFAULT;
++
++	if(pid < 1 || pid > MAX_RUNNING_PROCS)
++		return EINVAL;
++
++	if(childprocess == NULL)
++		return EINVAL;
++
++	if(exitcode == NULL)
++    	return EFAULT;
++
++    if(exitcode == (void *)0x80000000) // Kernel pointer check
++        return EFAULT;
++
++    if(exitcode == (void *)0x40000000)  // Invalid pointer check
++        return EFAULT;
++
++    int i=0;
++    char * checkptr = (char *)exitcode;
++    while(checkptr[i] != 0)
++    {
++    	checkptr++;
++    	i++;
++    }
++	if(i%4 != 0)
++		return EFAULT;
++
++	if(sizeof(checkptr)%4 != 0)
++		return EFAULT;
++
++	// if flags are not proper
++	if(flags < 0 || flags > 2)
++		return EINVAL;
++
++	// Dont wait for yourself :)
++	if(pid == curthread->t_process->p_pid_self)
++		return EFAULT;
++
++	if(pid == curthread->t_process->p_pid_parent)
++		return EFAULT;
++
++	/*Dont wait for siblings child*/
++	if(childprocess->p_pid_parent != -1)
++	{
++		if(curthread->t_process->p_pid_parent == childprocess->p_pid_parent)
++			return ECHILD;
++
++	}
++
++	if(childprocess->p_exited)
++	{
++		/*collect the exitstatus and return*/
++		//memcpy(exitcode, &childprocess->p_exitcode, sizeof(int));
++		//memcpy(retval, &childprocess->p_pid_self, sizeof(pid_t));
++		if(sizeof(*exitcode) != 4)
++			return EFAULT;
++		*exitcode =  childprocess->p_exitcode;
++		*retval = childprocess->p_pid_self;
++		process_destroy(childprocess);
++		err = 0;
++	}
++	else
++	{
++		/*else wait on sem until the thread exits then collect exit status and return*/
++		P(childprocess->p_exitsem);
++		//memcpy(exitcode, childprocess->p_exitcode, sizeof(int));
++		//memcpy(retval, childprocess->p_pid_self, sizeof(pid_t));
++		*exitcode = childprocess->p_exitcode;
++		*retval = childprocess->p_pid_self;
++		process_destroy(childprocess);
++		err = 0;
++	}
++	return err;
++}
++
++/**
++ * Added by Babu : 04/02/2014
++ * sysexit will stop the current thread execution and destroy it immediately
++ */
++void
++sys__exit(int exitstatus)
++{
++	int32_t pid = 0;
++	sys_getpid(&pid);
++	//kprintf("Exiting for %d",pid);
++	if(curthread->t_process != NULL)
++	{
++		if(!curthread->t_process->p_exited)
++		{
++			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
++			curthread->t_process->p_exited = true;
++			/**
++			 *
++			 */
++			/* Free thread structure and destroy all the thread related book keeping stuffs*/
++			//kprintf("thread exited successfully.\n");
++			thread_exit();
++		}
++	}
++
++	return;
++}
++
++/**
++ * Added by Babu on 03/09/2014:
++ *
++ * fork() creates a new process by duplicating the calling process. The new process,
++ * referred to as the child, is an exact duplicate of the calling process, referred
++ * to as the parent.
++ *
++ * return value(retval) 0 for child process and child pid for parent process
++ *
++ */
++int
++sys_fork(int32_t *retval, struct trapframe *tf)
++{
++	struct addrspace *child_addrspce = NULL;
++	struct process *child = NULL;
++//	/int spl = 0;
++	struct process *parent = NULL;
++	struct trapframe *child_trapframe = NULL;
++	int retvalfork = 0;
++	/**
++	 * Create
++	 */
++
++	parent = curthread->t_process;
++	if(parent == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++
++		//panic("parent process retrieve operation failed");
++
++	parent->p_thread = curthread;
++	//parent_trapframe = tf;
++
++	/*
++	 * Child process creation
++	 */
++	child  = kmalloc(sizeof(struct process));
++	if(child == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++		//panic("Child process creation failed");
++
++	/* Child process struct init */
++	child->p_pid_parent = parent->p_pid_self;
++	child->p_pid_self = allocate_pid();
++	child->p_exited = false;
++	child->p_exitsem = sem_create("p_exitsem", 0);
++
++	/* To protect from multiple thread generating pid same time - Babu*/
++	spinlock_acquire(&proc_lock);
++
++	child->p_pid_self = allocate_pid();
++
++	/* Assigning in process table */
++	addto_proc_table(child);
++
++	/* release lock */
++	spinlock_release(&proc_lock);
++
++	/* create a copy of trapframe using memcpy */
++	child_trapframe = kmalloc(sizeof(struct trapframe));
++	if(child_trapframe == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++	memcpy(child_trapframe, tf, sizeof(struct trapframe));
++
++	/* Addres space and file table cloning from parent */
++	as_copy(parent->p_thread->t_addrspace, &child_addrspce);
++
++	/* disable interrupts*/
++	//spl  = splhigh();
++
++	/**
++	 * copy parent trapframe to the child process
++	 * and invoke creating child thread
++	 */
++	//tf->tf_a0 = (uint32_t) child_addrspce;
++	retvalfork = thread_fork("child process", child_entrypoint, child_trapframe,(unsigned long) child_addrspce, &child->p_thread);
++	//kprintf("return value of thread_fork : %d\n",retvalfork);
++
++	/*Assigning the process structure to the thread just got created*/
++	if(child == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++	if(child->p_thread == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++
++	if(child->p_thread->t_process == NULL)
++	{
++		*retval = ENOMEM;
++		return -1;
++	}
++	child->p_thread->t_process = child;
++
++	/* Return values as child process pid */
++	*retval = child->p_pid_self;
++	//copyout(&child->p_pid_self, (userptr_t) retval, sizeof(child->p_pid_self));
++
++	/* enable interrupts again*/
++	//splx(spl);
++
++	/* Return success or error code  */
++	return retvalfork;
++
++}
++
++/**
++ * Child entry point function which will be invoked
++ * immediately after the child process creation
++ */
++void
++child_entrypoint(void *data1, unsigned long data2)
++{
++	struct trapframe tf_copy;
++	struct trapframe *child_tf = (struct trapframe *) data1;
++	struct addrspace *child_addrspce = (struct addrspace *) data2;
++
++
++	if(child_addrspce == NULL || child_tf == NULL) /* To indicate failure of child fork */
++	{
++		child_tf->tf_v0 = ENOMEM;
++		child_tf->tf_a3 = 1;
++		return;
++		//panic("child entry point failed");
++	}
++	else /* To indicate success of child fork */
++	{
++		child_tf->tf_v0 = 0;
++		child_tf->tf_a3 = 0;
++	}
++
++	/*
++	* Now, advance the program counter, to avoid restarting
++	* the syscall over and over again.
++	*/
++	child_tf->tf_epc += 4;
++
++	/** Loading child's address space into current thread address space */
++	curthread->t_addrspace = child_addrspce;
++	as_activate(curthread->t_addrspace);
++
++	/* Copy modified trap frame*/
++	memcpy(&tf_copy, child_tf, sizeof(struct trapframe));
++
++	/* And enter user mode*/
++	mips_usermode(&tf_copy);
++
++	//kprintf("user mode entered successfully /n");
++
++}
++
++
++/** *
++ * Added by Babu
++ * execv() system call creates a process by reading from ELF file and
++ * loading it into the address space.
++ *
++ */
++int
++sys_execv(userptr_t userprgname, userptr_t userargv[])
++{
++	struct vnode *v;
++	vaddr_t entrypoint, stackptr;
++	int result, j=0, err, argsize= 0;
++	int argc = 0, totsize = 0 , totsizecnt = 0;
++	char *prgname = (char *)userprgname;
++	char **argv = (char **)userargv;
++
++	if(userprgname == NULL || userargv == NULL)
++		return EFAULT;
++
++	if((void *)userprgname == (void *)0x40000000 || (void *)userargv == (void *)0x40000000)
++		return EFAULT;
++
++	if((void *)userprgname == (void *)0x80000000 || (void *)userargv == (void *)0x80000000)
++		return EFAULT;
++
++	if((char *)userprgname == "\0" || (char *)userprgname == "")
++		return EINVAL;
++
++	if(*argv == "\0" || *argv == "")
++		return EINVAL;
++
++	if(strlen(prgname) == 0 || strlen(*argv) == 0)
++		return EINVAL;
++
++	if(strcmp(prgname,"\0") == 0 || strcmp(prgname,"") == 0)
++		return EINVAL;
++
++	if(strcmp(*argv,"\0") == 0 || strcmp(*argv,"") == 0)
++		return EINVAL;
++
++
++	if(argv != NULL)
++	{
++		while(argv[j] != NULL)
++		{
++			if((void *)userargv[j] == (void *)0x80000000 ||  (void *)userargv[j] == (void *)0x40000000)
++				return EFAULT;
++			argc++;
++			j++;
++		}
++	}
++
++	char *kbuf[argc];
++	int32_t *koffset[argc];
++	size_t copylen[argc];
++
++	if(argc != 0)
++	{
++
++		/**Copyin user args to kernel buffer */
++		totsizecnt = (argc + 1) * sizeof(int32_t);
++
++		j = 0;
++		if(argv != NULL)
++		{
++			while(argv[j] != NULL)
++			{
++				argsize = strlen(argv[j]) + 1;
++				totsize = argsize + (4 - (argsize % 4));
++				copylen[j] = totsize * sizeof(char);
++				kbuf[j] = kmalloc (copylen[j]);
++				koffset[j] = kmalloc(sizeof(int32_t));
++				//memcpy(kbuf[j], argv[j], argsize);
++				err = copyinstr((const_userptr_t)argv[j], kbuf[j], argsize, &copylen[j]);
++				//if(copylen[j] != (size_t)argsize)
++					//return EFAULT;
++				//if(err != 0)
++					//return err;
++
++				// Assign the offset
++				memcpy(koffset[j], &totsizecnt, sizeof(int32_t));
++				//err = copyin((userptr_t)(totsizecnt), koffset[j], sizeof(int32_t));
++				//if(err != 0)
++					//return err;
++				totsizecnt += totsize;
++				j++;
++			}
++			koffset[j] = NULL;
++		}
++		else
++			kprintf("user args null");
++
++	}
++
++	/*char *kprgname;
++	size_t copied;
++	if(prgname != NULL)
++	{
++		err = copyinstr((const_userptr_t)prgname, kprgname, strlen(prgname)+1, &copied);
++		if(copied != strlen(prgname))
++			return EFAULT;
++		if(err != 0)
++			return err;
++	}*/
++
++	/* Open the file. */
++	result = vfs_open(prgname, O_RDONLY, 0, &v);
++	if (result) {
++		return result;
++	}
++
++	/* We should be a new thread. */
++	//KASSERT(curthread->t_addrspace == NULL);
++
++	/* Create a new address space. */
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace==NULL) {
++		vfs_close(v);
++		return ENOMEM;
++	}
++
++	/* Activate it. */
++	as_activate(curthread->t_addrspace);
++
++	/* Load the executable. */
++	result = load_elf(v, &entrypoint);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		vfs_close(v);
++		return result;
++	}
++
++	/* Done with the file now. */
++	vfs_close(v);
++
++	/* Define the user stack in the address space */
++	result = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		return result;
++	}
++
++	j = 0;
++	// Starting address  of userstack from which args and pointers should be copied
++	vaddr_t initstckptr = stackptr - totsizecnt;
++	vaddr_t userstckptr = initstckptr;
++	vaddr_t userargsptr = userstckptr;
++	size_t usercopylen[argc];
++
++	if(argc != 0)
++	{
++		for(j=0; j<argc; j++)
++		{
++			userargsptr =  initstckptr + (vaddr_t)(*koffset[j]);
++
++			/* copyout user pointer (in kernel buffer) to user stack */
++			err = copyout(&userargsptr, (userptr_t)userstckptr, sizeof(int32_t));
++			if(err != 0)
++				return err;
++
++			/* Copyout user arguments (in kernel buffer) to user stack*/
++			err = copyoutstr((const char *)kbuf[j],(userptr_t)userargsptr, copylen[j], &usercopylen[j]);
++			if(err != 0)
++				return err;
++			userstckptr += sizeof(int32_t);
++
++		}
++	}
++
++	userstckptr = initstckptr;
++	while(userstckptr != initstckptr + (vaddr_t)(*koffset[0]))
++	{
++		//kprintf("user address : %x",userstckptr);
++		//kprintf("user address : %x",userargsptr);
++		//kprintf("user stack : %x\n", *(int32_t *)userstckptr);
++		userstckptr+=4;
++	}
++
++	/* Warp to user mode. */
++	//enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++		//	  stackptr, entrypoint);
++	userstckptr = initstckptr + (vaddr_t)(*koffset[0]);
++	//kprintf("user space address : %x",userstckptr);
++
++	enter_new_process(argc /*argc*/, (userptr_t)initstckptr /*userspace addr of argv (TODO userstckptr or stackptr?)*/,
++			initstckptr, entrypoint);
++
++
++	/* enter_new_process does not return. */
++	panic("enter_new_process returned\n");
++	return EINVAL;
++
++}
++
++/**
++ * Lookup process using pid in process table
++ */
++struct process_list *
++process_lookup(pid_t pid_lookup)
++{
++	struct process_list *local_ptable = proc_table;
++	while(local_ptable != NULL)
++	{
++		if(local_ptable->process_info->p_pid_self == pid_lookup)
++			return local_ptable;
++
++		local_ptable = local_ptable->next;
++	}
++
++	return NULL;
++}
++
++
++/**
++ * Add process entry to process table
++ */
++void
++addto_proc_table(struct process *proc)
++{
++	struct process_list *local_ptable = proc_table;
++	if(local_ptable == NULL)
++	{
++		proc_table = kmalloc(sizeof(struct process_list));
++		proc_table->process_info = proc;
++		proc_table->next = NULL;
++	}
++	else
++	{
++		while(local_ptable->next != NULL)
++		{
++			local_ptable = local_ptable->next;
++		}
++		local_ptable->next = kmalloc(sizeof(struct process_list));
++		local_ptable->next->process_info = proc;
++		local_ptable->next->next = NULL;
++	}
++
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..a289d6d 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,7 +44,9 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
+-
++#include <synch.h>
++#include <unistd.h>
++#include <copyinout.h>
+ /*
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+@@ -52,13 +54,137 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname, char *argv[], unsigned long argc)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	struct vnode *o, *i, *e;
++	char *con0 = kstrdup("con:");
++	char *con1 = kstrdup("con:");
++	char *con2 = kstrdup("con:");
++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
++	KASSERT(inpTemp!=1);
++	KASSERT(outTemp!=1);
++	KASSERT(errTemp!=1);
++
++	struct fTable *input, *output, *error;
++	input= kmalloc(sizeof(struct fTable));
++	output = kmalloc(sizeof(struct fTable));
++	error = kmalloc(sizeof(struct fTable));
++	KASSERT(input!=NULL);
++	KASSERT(output!=NULL);
++	KASSERT(error!=NULL);
++
++	input->name=kstrdup("Standard_Input");
++	input->offset=0;
++	input->ref_count =0;
++	input->status=O_RDONLY;
++	input->vn=i;
++	input->lock=lock_create("Standard Input");
++
++	output->name=kstrdup("Standard_Output");
++	output->offset=0;
++	output->ref_count =0;
++	output->status=O_WRONLY;
++	output->vn=o;
++	output->lock=lock_create("Standard Output");
++
++	error->name=kstrdup("Standard_Error");
++	error->offset=0;
++	error->ref_count =0;
++	error->status=O_WRONLY;
++	error->vn=e;
++	error->lock=lock_create("Standard Error");
++	KASSERT(input->lock!=NULL);
++	KASSERT(output->lock!=NULL);
++	KASSERT(error->lock!=NULL);
++
++	curthread->ft[STDIN_FILENO]=input;
++	curthread->ft[STDOUT_FILENO]=output;
++	curthread->ft[STDERR_FILENO]=error;
++	kfree(con0);
++	kfree(con1);
++	kfree(con2);
++	//kprintf("IO fd's initialized\n");
++
++	unsigned long j = 0;
++	int  err, argsize= 0;
++	int  totsize = 0 , totsizecnt = 0;
++
++
++
++	/*if(argv != NULL)
++	{
++		while(argv[j] != NULL)
++		{
++			argc++;
++			j++;
++		}
++	}*/
++
++
++
++	char *kbuf[argc];
++	int32_t *koffset[argc];
++	size_t copylen[argc];
++
++	if(argc != 0)
++	{
++
++		/**Copyin user args to kernel buffer */
++		totsizecnt = (argc + 1) * sizeof(int32_t);
++
++		j = 0;
++		if(argv != NULL)
++		{
++			//while(argv[j] != NULL)
++			for(j=0;j<argc; j++)
++			{
++				argsize = strlen(argv[j]) + 1;
++				totsize = argsize + (4 - (argsize % 4));
++				copylen[j] = totsize * sizeof(char);
++				kbuf[j] = kmalloc (copylen[j]);
++				koffset[j] = kmalloc(sizeof(int32_t));
++				memcpy(kbuf[j], argv[j], argsize);
++
++				//err = copyinstr((const_userptr_t)argv[j], kbuf[j], argsize, &copylen[j]);
++				//if(copylen[j] != (size_t)argsize)
++					//return EFAULT;
++				//if(err != 0)
++					//return err;
++
++				// Assign the offset
++				memcpy(koffset[j], &totsizecnt, sizeof(int32_t));
++				//err = copyin((userptr_t)(totsizecnt), koffset[j], sizeof(int32_t));
++				//if(err != 0)
++					//return err;
++				totsizecnt += totsize;
++			}
++			koffset[j] = NULL;
++		}
++		else
++			kprintf("user args null");
++
++		//char *kprgname;
++		//size_t copied;
++		//if(progname != NULL)
++		//{
++			//err = copyinstr((const_userptr_t)progname, kprgname, strlen(progname), &copied);
++			//if(copied != strlen(progname))
++				//return EFAULT;
++			//if(err != 0)
++				//return err;
++		//}
++
++	}
++
++
+ 	/* Open the file. */
++	kprintf("opening file : %s",progname);
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+ 		return result;
+@@ -81,6 +207,7 @@ runprogram(char *progname)
+ 	result = load_elf(v, &entrypoint);
+ 	if (result) {
+ 		/* thread_exit destroys curthread->t_addrspace */
++		kprintf("Load ELF error\n");
+ 		vfs_close(v);
+ 		return result;
+ 	}
+@@ -95,9 +222,50 @@ runprogram(char *progname)
+ 		return result;
+ 	}
+ 
++	j = 0;
++	// Starting address  of userstack from which args and pointers should be copied
++	vaddr_t initstckptr = stackptr - totsizecnt;
++	vaddr_t userstckptr = initstckptr;
++	vaddr_t userargsptr = userstckptr;
++	size_t usercopylen[argc];
++
++	if(argc != 0)
++	{
++		for(j=0; j<argc; j++)
++		{
++			userargsptr =  initstckptr + (vaddr_t)(*koffset[j]);
++
++			/* copyout user pointer (in kernel buffer) to user stack */
++			err = copyout(&userargsptr, (userptr_t)userstckptr, sizeof(int32_t));
++			if(err != 0)
++				return err;
++
++			/* Copyout user arguments (in kernel buffer) to user stack*/
++			err = copyoutstr((const char *)kbuf[j],(userptr_t)userargsptr, copylen[j], &usercopylen[j]);
++			if(err != 0)
++				return err;
++			userstckptr += sizeof(int32_t);
++
++		}
++	}
++
++	userstckptr = initstckptr;
++	while(userstckptr != initstckptr + (vaddr_t)(*koffset[0]))
++	{
++		//kprintf("user address : %x",userstckptr);
++		//kprintf("user address : %x",userargsptr);
++		//kprintf("user stack : %x\n", *(int32_t *)userstckptr);
++		userstckptr+=4;
++	}
++
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+-			  stackptr, entrypoint);
++	//enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++		//	  stackptr, entrypoint);
++	userstckptr = initstckptr + (vaddr_t)(*koffset[0]);
++	//kprintf("user space address : %x",userstckptr);
++
++	enter_new_process(argc /*argc*/, (userptr_t)initstckptr /*userspace addr of argv (TODO userstckptr or stackptr?)*/,
++			initstckptr, entrypoint);
+ 	
+ 	/* enter_new_process does not return. */
+ 	panic("enter_new_process returned\n");
+diff --git a/kern/t_addrspace b/kern/t_addrspace
+new file mode 100644
+index 0000000..80766b6
+--- /dev/null
++++ b/kern/t_addrspace
+@@ -0,0 +1,239 @@
++Binary file compile/ASST1/trap.o matches
++Binary file compile/ASST1/main.o matches
++Binary file compile/ASST1/uio.o matches
++Binary file compile/ASST1/lamebus_machdep.o matches
++Binary file compile/ASST1/runprogram.o matches
++Binary file compile/ASST1/synch.o matches
++Binary file compile/ASST1/thread.o matches
++Binary file compile/ASST1/console.o matches
++Binary file compile/ASST1/kernel matches
++Binary file compile/ASST1/syscall.o matches
++Binary file compile/ASST2/trap.o matches
++Binary file compile/ASST2/main.o matches
++Binary file compile/ASST2/uio.o matches
++Binary file compile/ASST2/lamebus_machdep.o matches
++Binary file compile/ASST2/runprogram.o matches
++Binary file compile/ASST2/synch.o matches
++Binary file compile/ASST2/thread.o matches
++Binary file compile/ASST2/console.o matches
++Binary file compile/ASST2/kernel matches
++Binary file compile/ASST2/syscall.o matches
++Binary file compile/ASST3/trap.o matches
++Binary file compile/ASST3/main.o matches
++Binary file compile/ASST3/uio.o matches
++Binary file compile/ASST3/lamebus_machdep.o matches
++Binary file compile/ASST3/runprogram.o matches
++Binary file compile/ASST3/synch.o matches
++Binary file compile/ASST3/thread.o matches
++Binary file compile/ASST3/console.o matches
++Binary file compile/ASST3/kernel matches
++Binary file compile/ASST3/syscall.o matches
++Binary file compile/ASST0/trap.o matches
++Binary file compile/ASST0/main.o matches
++Binary file compile/ASST0/uio.o matches
++Binary file compile/ASST0/lamebus_machdep.o matches
++Binary file compile/ASST0/runprogram.o matches
++Binary file compile/ASST0/synch.o matches
++Binary file compile/ASST0/thread.o matches
++Binary file compile/ASST0/console.o matches
++Binary file compile/ASST0/kernel matches
++Binary file compile/ASST0/syscall.o matches
++arch/mips/vm/dumbvm_dontuse.c:	as = curthread->t_addrspace;
++arch/mips/thread/cpu.c:	if (c->c_curthread->t_stack == NULL) {
++arch/mips/thread/cpu.c:		stackpointer = (vaddr_t) c->c_curthread->t_stack;
++arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
++arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
++arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
++arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
++arch/mips/locore/trap.c:	if (curthread != NULL && curthread->t_stack != NULL) {
++arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf > (vaddr_t)curthread->t_stack);
++arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf < (vaddr_t)(curthread->t_stack
++arch/mips/locore/trap.c:		old_in = curthread->t_in_interrupt;
++arch/mips/locore/trap.c:		curthread->t_in_interrupt = 1;
++arch/mips/locore/trap.c:		if (curthread->t_curspl == 0) {
++arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == 0);
++arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 0);
++arch/mips/locore/trap.c:			curthread->t_curspl = IPL_HIGH;
++arch/mips/locore/trap.c:			curthread->t_iplhigh_count++;
++arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == IPL_HIGH);
++arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 1);
++arch/mips/locore/trap.c:			curthread->t_iplhigh_count--;
++arch/mips/locore/trap.c:			curthread->t_curspl = 0;
++arch/mips/locore/trap.c:		curthread->t_in_interrupt = old_in;
++arch/mips/locore/trap.c:		KASSERT(curthread->t_curspl == 0);
++arch/mips/locore/trap.c:		KASSERT(curthread->t_iplhigh_count == 0);
++arch/mips/locore/trap.c:	    curthread->t_machdep.tm_badfaultfunc != NULL) {
++arch/mips/locore/trap.c:		tf->tf_epc = (vaddr_t) curthread->t_machdep.tm_badfaultfunc;
++arch/mips/locore/trap.c:	if (curthread->t_stack == NULL) {
++arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
++arch/mips/locore/trap.c:	 *   (1) curthread->t_stack is corrupted, or
++arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
++arch/mips/include/current.h: * make curcpu be curthread->t_cpu.
++arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
++arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
++lib/uio.c:		KASSERT(uio->uio_space == curthread->t_addrspace);
++lib/kprintf.c:		&& curthread->t_in_interrupt == false
++lib/kprintf.c:		&& curthread->t_iplhigh_count == 0;
++vm/copyinout.c:	longjmp(curthread->t_machdep.tm_copyjmp, 1);
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
++vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
++vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
++vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
++vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
++vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
++vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
++vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
++vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
++vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
++thread/spl.c: * curthread->t_iplhigh_count is used to track this.
++thread/synch.c:        KASSERT(curthread->t_in_interrupt == false);
++thread/thread.c:		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
++thread/thread.c:		 * Leave c->c_curthread->t_stack NULL for the boot
++thread/thread.c:		/*c->c_curthread->t_stack = ... */
++thread/thread.c:		c->c_curthread->t_stack = kmalloc(STACK_SIZE);
++thread/thread.c:		if (c->c_curthread->t_stack == NULL) {
++thread/thread.c:	c->c_curthread->t_cpu = c;
++thread/thread.c:	curthread->t_cpu = curcpu;
++thread/thread.c:	newthread->t_cpu = curthread->t_cpu;
++thread/thread.c:	if (curthread->t_cwd != NULL) {
++thread/thread.c:		VOP_INCREF(curthread->t_cwd);
++thread/thread.c:		newthread->t_cwd = curthread->t_cwd;
++thread/thread.c:		newthread->ft[i] = curthread->ft[i];
++thread/thread.c:		if ( curthread->ft[i] !=0)
++thread/thread.c:			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
++thread/thread.c:	DEBUGASSERT(curthread->t_cpu == curcpu->c_self);
++thread/thread.c:		if (curthread->ft[i] !=  NULL)
++thread/thread.c:	//if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
++thread/thread.c:		V(curthread->t_process->p_exitsem);
++thread/thread.c:	KASSERT(!curthread->t_in_interrupt);
++syscall/process.c:		if(curthread->t_process != NULL)
++syscall/process.c:			//*retval = *curthread->t_process->p_pid_self;
++syscall/process.c:			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
++syscall/process.c:		if(curthread->t_process != NULL)
++syscall/process.c:			//*retval = *curthread->t_process->p_pid_parent;
++syscall/process.c:			memcpy(retval, &curthread->t_process->p_pid_parent, sizeof(pid_t));
++syscall/process.c:	if(pid == curthread->t_process->p_pid_self)
++syscall/process.c:	if(pid == curthread->t_process->p_pid_parent)
++syscall/process.c:		if(curthread->t_process->p_pid_parent == childprocess->p_pid_parent)
++syscall/process.c:	if(curthread->t_process != NULL)
++syscall/process.c:		if(!curthread->t_process->p_exited)
++syscall/process.c:			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
++syscall/process.c:			curthread->t_process->p_exited = true;
++syscall/process.c:	parent = curthread->t_process;
++syscall/process.c:	curthread->t_addrspace = child_addrspce;
++syscall/process.c:	as_activate(curthread->t_addrspace);
++syscall/process.c:	//KASSERT(curthread->t_addrspace == NULL);
++syscall/process.c:	curthread->t_addrspace = as_create();
++syscall/process.c:	if (curthread->t_addrspace==NULL) {
++syscall/process.c:	as_activate(curthread->t_addrspace);
++syscall/process.c:		/* thread_exit destroys curthread->t_addrspace */
++syscall/process.c:	result = as_define_stack(curthread->t_addrspace, &stackptr);
++syscall/process.c:		/* thread_exit destroys curthread->t_addrspace */
++syscall/loadelf.c:	u.uio_space = curthread->t_addrspace;
++syscall/loadelf.c:		result = as_define_region(curthread->t_addrspace,
++syscall/loadelf.c:	result = as_prepare_load(curthread->t_addrspace);
++syscall/loadelf.c:	result = as_complete_load(curthread->t_addrspace);
++syscall/file_syscalls.c:		if (curthread->ft[i] == NULL)
++syscall/file_syscalls.c:			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++syscall/file_syscalls.c:			if (curthread->ft[i] == NULL)
++syscall/file_syscalls.c:			curthread->ft[i]->lock = lock_create(curthread->t_name);
++syscall/file_syscalls.c:			if (curthread->ft[i]->lock == NULL)
++syscall/file_syscalls.c:				kfree(curthread->ft[i]);
++syscall/file_syscalls.c:				curthread->ft[i] = NULL;
++syscall/file_syscalls.c:			curthread->ft[i]->offset=0;
++syscall/file_syscalls.c:			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++syscall/file_syscalls.c:			curthread->ft[i]->status = flags;
++syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
++syscall/file_syscalls.c:				kfree(curthread->ft[i]);
++syscall/file_syscalls.c:				curthread->ft[i] = NULL;
++syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
++syscall/file_syscalls.c:				kfree(curthread->ft[i]);
++syscall/file_syscalls.c:				curthread->ft[i] = NULL;
++syscall/file_syscalls.c:			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++syscall/file_syscalls.c:				lock_destroy(curthread->ft[i]->lock);
++syscall/file_syscalls.c:				kfree(curthread->ft[i]);
++syscall/file_syscalls.c:				curthread->ft[i] = NULL;
++syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
++syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++syscall/file_syscalls.c:	if(curthread->ft[fd]->ref_count == 0)
++syscall/file_syscalls.c:		vfs_close(curthread->ft[fd]->vn);
++syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:		lock_destroy(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:		kfree(curthread->ft[fd]);
++syscall/file_syscalls.c:		curthread->ft[fd]=NULL;
++syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:		curthread->ft[fd]=NULL;
++syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
++syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	uio.uio_offset = curthread->ft[fd]->offset;
++syscall/file_syscalls.c:	uio.uio_space = curthread->t_addrspace;
++syscall/file_syscalls.c:	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++syscall/file_syscalls.c:	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++syscall/file_syscalls.c:	curthread->ft[fd]->offset=uio.uio_offset;
++syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
++syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	uio.uio_offset = curthread->ft[fd]->offset;
++syscall/file_syscalls.c:	uio.uio_space = curthread->t_addrspace;
++syscall/file_syscalls.c:	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++syscall/file_syscalls.c:	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++syscall/file_syscalls.c:	curthread->ft[fd]->offset=uio.uio_offset;
++syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	if (curthread->ft[fd] == NULL)
++syscall/file_syscalls.c:	//kprintf("curthread->ft[fd] == NULL\n");
++syscall/file_syscalls.c:	lock_acquire(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++syscall/file_syscalls.c:		nPos = curthread->ft[fd]->offset+pos;
++syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++syscall/file_syscalls.c:		lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	curthread->ft[fd]->offset = nPos;
++syscall/file_syscalls.c:	lock_release(curthread->ft[fd]->lock);
++syscall/file_syscalls.c:	return curthread->ft[fd]->offset;
++syscall/file_syscalls.c:				nfile_desc > OPEN_MAX || curthread->ft[ofile_desc] == NULL || curthread->ft[nfile_desc] == NULL)
++syscall/file_syscalls.c:		if (curthread->ft[ofile_desc] == curthread->ft[nfile_desc] || ofile_desc == nfile_desc)
++syscall/file_syscalls.c:		if (curthread->ft[nfile_desc] != NULL)
++syscall/file_syscalls.c:		curthread->ft[nfile_desc] = curthread->ft[ofile_desc];
++syscall/file_syscalls.c:		lock_acquire(curthread->ft[nfile_desc]->lock);
++syscall/file_syscalls.c:		curthread->ft[nfile_desc]->ref_count++;
++syscall/file_syscalls.c:		lock_release(curthread->ft[nfile_desc]->lock);
++syscall/runprogram.c:	curthread->ft[STDIN_FILENO]=input;
++syscall/runprogram.c:	curthread->ft[STDOUT_FILENO]=output;
++syscall/runprogram.c:	curthread->ft[STDERR_FILENO]=error;
++syscall/runprogram.c:	KASSERT(curthread->t_addrspace == NULL);
++syscall/runprogram.c:	curthread->t_addrspace = as_create();
++syscall/runprogram.c:	if (curthread->t_addrspace==NULL) {
++syscall/runprogram.c:	as_activate(curthread->t_addrspace);
++syscall/runprogram.c:		/* thread_exit destroys curthread->t_addrspace */
++syscall/runprogram.c:	result = as_define_stack(curthread->t_addrspace, &stackptr);
++syscall/runprogram.c:		/* thread_exit destroys curthread->t_addrspace */
++synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s starting\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s ending\n", curthread->t_name);
++synchprobs/drivers.c:	kprintf("%s in quadrant %d\n", curthread->t_name, quadrant);
++synchprobs/drivers.c:	kprintf("%s left the intersection\n", curthread->t_name);
++startup/main.c:	KASSERT(curthread->t_curspl > 0);
++startup/main.c:	KASSERT(curthread->t_curspl == 0);
++vfs/vfscwd.c: * We do not synchronize curthread->t_cwd, because it belongs exclusively
++vfs/vfscwd.c:	if (curthread->t_cwd!=NULL) {
++vfs/vfscwd.c:		VOP_INCREF(curthread->t_cwd);
++vfs/vfscwd.c:		*ret = curthread->t_cwd;
++vfs/vfscwd.c:	old = curthread->t_cwd;
++vfs/vfscwd.c:	curthread->t_cwd = dir;
++vfs/vfscwd.c:	old = curthread->t_cwd;
++vfs/vfscwd.c:	curthread->t_cwd = NULL;
++include/current.h:#define curcpu curthread->t_cpu
++dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
++dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
++dev/generic/console.c:	else if (curthread->t_in_interrupt || curthread->t_iplhigh_count > 0) {
++dev/generic/console.c:	KASSERT(!curthread->t_in_interrupt && curthread->t_iplhigh_count == 0);
+diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
+index b4dd87c..dd298d9 100644
+--- a/kern/test/malloctest.c
++++ b/kern/test/malloctest.c
+@@ -98,6 +98,8 @@ malloctest(int nargs, char **args)
+ 
+ 	kprintf("Starting kmalloc test...\n");
+ 	mallocthread(NULL, 0);
++	//int *chumma = kmalloc(997);
++	//*chumma = 32;
+ 	kprintf("kmalloc test done\n");
+ 
+ 	return 0;
+diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
+index d072469..f106f4a 100644
+--- a/kern/test/synchtest.c
++++ b/kern/test/synchtest.c
+@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
+ {
+ 	int i;
+ 	(void)junk;
+-
+ 	for (i=0; i<NCVLOOPS; i++) {
+ 		lock_acquire(testlock);
+ 		while (testval1 != num) {
+-      testval2 = 0;
++			testval2 = 0;
++
+ 			cv_wait(testcv, testlock);
+-      testval2 = 0xFFFFFFFF;
++			testval2 = 0xFFFFFFFF;
+ 		}
+ 		testval2 = num;
++
+ 		cv_broadcast(testcv, testlock);
+ 		thread_yield();
+ 		kprintf("Thread %lu\n", testval2);
+ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+ 		lock_release(testlock);
+ 	}
++	kprintf("cv2 test exiting\n");
+ 	V(donesem);
+ }
+ 
+@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
+ 	for (i=0; i<NTHREADS; i++) {
+ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
+ 				      NULL);
++		//kprintf("Thread fork failure\n");
+ 		if (result) {
+ 			panic("cvtest: thread_fork failed: %s\n",
+ 			      strerror(result));
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..229bc82 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -47,20 +47,20 @@
+ struct semaphore *
+ sem_create(const char *name, int initial_count)
+ {
+-        struct semaphore *sem;
++	struct semaphore *sem;
+ 
+-        KASSERT(initial_count >= 0);
++	KASSERT(initial_count >= 0);
+ 
+-        sem = kmalloc(sizeof(struct semaphore));
+-        if (sem == NULL) {
+-                return NULL;
+-        }
++	sem = kmalloc(sizeof(struct semaphore));
++	if (sem == NULL) {
++			return NULL;
++	}
+ 
+-        sem->sem_name = kstrdup(name);
+-        if (sem->sem_name == NULL) {
+-                kfree(sem);
+-                return NULL;
+-        }
++	sem->sem_name = kstrdup(name);
++	if (sem->sem_name == NULL) {
++			kfree(sem);
++			return NULL;
++	}
+ 
+ 	sem->sem_wchan = wchan_create(sem->sem_name);
+ 	if (sem->sem_wchan == NULL) {
+@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
+ 	}
+ 
+ 	spinlock_init(&sem->sem_lock);
+-        sem->sem_count = initial_count;
++    sem->sem_count = initial_count;
+ 
+-        return sem;
++    return sem;
+ }
+ 
+ void
+@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
+         KASSERT(sem != NULL);
+ 
+ 	/* wchan_cleanup will assert if anyone's waiting on it */
+-	spinlock_cleanup(&sem->sem_lock);
+-	wchan_destroy(sem->sem_wchan);
++		spinlock_cleanup(&sem->sem_lock);
++		wchan_destroy(sem->sem_wchan);
+         kfree(sem->sem_name);
+         kfree(sem);
+ }
+@@ -100,7 +100,7 @@ P(struct semaphore *sem)
+          */
+         KASSERT(curthread->t_in_interrupt == false);
+ 
+-	spinlock_acquire(&sem->sem_lock);
++        spinlock_acquire(&sem->sem_lock);
+         while (sem->sem_count == 0) {
+ 		/*
+ 		 * Bridge to the wchan lock, so if someone else comes
+@@ -120,24 +120,22 @@ P(struct semaphore *sem)
+ 		 */
+ 		wchan_lock(sem->sem_wchan);
+ 		spinlock_release(&sem->sem_lock);
+-                wchan_sleep(sem->sem_wchan);
+-
++        wchan_sleep(sem->sem_wchan);
+ 		spinlock_acquire(&sem->sem_lock);
+-        }
+-        KASSERT(sem->sem_count > 0);
+-        sem->sem_count--;
++	}
++	KASSERT(sem->sem_count > 0);
++	sem->sem_count--;
+ 	spinlock_release(&sem->sem_lock);
+ }
+ 
+ void
+ V(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
+-
+-	spinlock_acquire(&sem->sem_lock);
++    KASSERT(sem != NULL);
++	spinlock_acquire(&sem->sem_lock); 
+ 
+-        sem->sem_count++;
+-        KASSERT(sem->sem_count > 0);
++	sem->sem_count++;
++	KASSERT(sem->sem_count > 0);
+ 	wchan_wakeone(sem->sem_wchan);
+ 
+ 	spinlock_release(&sem->sem_lock);
+@@ -158,20 +156,36 @@ lock_create(const char *name)
+         }
+ 
+         lock->lk_name = kstrdup(name);
++
+         if (lock->lk_name == NULL) {
+                 kfree(lock);
+                 return NULL;
+         }
+-        
++
++        //added by vasanth
++        lock->lock_owner=NULL;
++        lock->lock_wchan = wchan_create(lock->lk_name);
++		if (lock->lock_wchan == NULL)
++		{
++			kfree(lock->lk_name);
++			kfree(lock);
++			return NULL;
++		}
++		spinlock_init(&lock->spn_lock);
++
+         // add stuff here as needed
+-        
+         return lock;
+ }
+ 
+ void
+ lock_destroy(struct lock *lock)
+ {
++
+         KASSERT(lock != NULL);
++        //added by vasanth
++        //KASSERT(lock->lock_owner == NULL);
++        spinlock_cleanup(&lock->spn_lock);
++        wchan_destroy(lock->lock_wchan);
+ 
+         // add stuff here as needed
+         
+@@ -182,27 +196,64 @@ lock_destroy(struct lock *lock)
+ void
+ lock_acquire(struct lock *lock)
+ {
++		//added by vasanth
++		KASSERT(lock != NULL);
++		if(!lock_do_i_hold(lock))
++		{
++			spinlock_acquire(&lock->spn_lock);
++			while (lock->lock_owner!=NULL)
++			{
++				wchan_lock(lock->lock_wchan);
++				spinlock_release(&lock->spn_lock);
++				wchan_sleep(lock->lock_wchan);
++				spinlock_acquire(&lock->spn_lock);
++			}
++			lock->lock_owner=curthread;
++			spinlock_release(&lock->spn_lock);
++		}
+         // Write this
+ 
+-        (void)lock;  // suppress warning until code gets written
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++		//added by vasanth
++ 		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		if(lock->lock_owner==curthread)
++		{
++			lock->lock_owner=NULL;
++			wchan_wakeall(lock->lock_wchan);
++		}
++		spinlock_release(&lock->spn_lock);
++		// Write this
++
++
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++		bool status;
++		spinlock_acquire(&lock->spn_lock);
++		if (lock->lock_owner==curthread)
++		{
++			status = true;
++		}
++		else
++		{
++			status = false;
++		}
++		spinlock_release(&lock->spn_lock);
++		return status;
++
++        //(void)lock;  // suppress warning until code gets written
++
++        //return true; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -217,26 +268,36 @@ cv_create(const char *name)
+ 
+         cv = kmalloc(sizeof(struct cv));
+         if (cv == NULL) {
+-                return NULL;
++        	return NULL;
+         }
+ 
+         cv->cv_name = kstrdup(name);
+         if (cv->cv_name==NULL) {
+-                kfree(cv);
+-                return NULL;
++            kfree(cv);
++            return NULL;
+         }
+         
+         // add stuff here as needed
++        /* Added by Babu :
++        * Adding a wait channel for making the threads wait during cv_acquire
++        */
++        cv->cv_waitchan = wchan_create(cv->cv_name);
++
+         
+         return cv;
+ }
+ 
++
+ void
+ cv_destroy(struct cv *cv)
+ {
+         KASSERT(cv != NULL);
+ 
+         // add stuff here as needed
++        /*
++         * Added by Babu : wchan destructor
++         */
++        wchan_destroy(cv->cv_waitchan);
+         
+         kfree(cv->cv_name);
+         kfree(cv);
+@@ -245,23 +306,158 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++    // Write this
++	/** Release lock, wait and then acquire once awake */
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	wchan_lock(cv->cv_waitchan);
++	if(lock_do_i_hold(lock))
++			lock_release(lock);
++	wchan_sleep(cv->cv_waitchan);
++
++	if(!lock_do_i_hold(lock))
++		lock_acquire(lock);
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++    // Write this
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++
++
++	//kprintf("Signaling CV\n");
++
++	wchan_wakeone(cv->cv_waitchan);
++	//wchan_unlock(cv->cv_waitchan);
++
++
++
++	(void) lock;
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	wchan_wakeall(cv->cv_waitchan);
++
++	(void) lock;
++}
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rwlock;
++	rwlock = kmalloc(sizeof(struct rwlock));
++	if (rwlock == NULL)
++	{
++		return NULL;
++	}
++	rwlock->rwlock_name=kstrdup(name);
++	if (rwlock->rwlock_name == NULL)
++	{
++	    kfree(rwlock);
++	    return NULL;
++	}
++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->rlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->wlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->num_reader=0;
++	rwlock->num_writer=0;
++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
++	if (rwlock->rw_lock == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		wchan_destroy(rwlock->wlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	return rwlock;
++
++}
++void
++rwlock_destroy(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_destroy(rwlock->rw_lock);
++	wchan_destroy(rwlock->rlock_wchan);
++	wchan_destroy(rwlock->wlock_wchan);
++	kfree(rwlock->rwlock_name);
++	kfree(rwlock);
++}
++
++void
++rwlock_acquire_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while (rwlock->num_writer>0)
++	{
++		wchan_lock(rwlock->rlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->rlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_reader++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_reader > 0);
++	lock_acquire(rwlock->rw_lock);
++	if(rwlock->num_reader > 0)
++	{
++		rwlock->num_reader--;
++	}
++	wchan_wakeall(rwlock->wlock_wchan);
++	wchan_wakeall(rwlock->rlock_wchan);
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_acquire_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
++	{
++		wchan_lock(rwlock->wlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->wlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_writer++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_writer > 0);
++	lock_acquire(rwlock->rw_lock);
++	rwlock->num_writer--;
++	wchan_wakeall(rwlock->rlock_wchan);
++	wchan_wakeall(rwlock->wlock_wchan);
++	lock_release(rwlock->rw_lock);
+ }
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..7a9734c 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,9 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <limits.h>
++#include <process.h>
++#include <syscall.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -70,6 +73,8 @@ static struct cpuarray allcpus;
+ /* Used to wait for secondary CPUs to come online. */
+ static struct semaphore *cpu_startup_sem;
+ 
++//extern struct spinlock proc_lock;
++
+ ////////////////////////////////////////////////////////////
+ 
+ /*
+@@ -126,6 +131,13 @@ thread_create(const char *name)
+ 		return NULL;
+ 	}
+ 
++	/**
++	 * Added by Babu :
++	 * Initializing parent process thread
++	 */
++	thread->t_process = kmalloc(sizeof(struct process));
++	if(thread->t_process == NULL)
++		panic("Process creation failed during thread_create");
+ 	thread->t_name = kstrdup(name);
+ 	if (thread->t_name == NULL) {
+ 		kfree(thread);
+@@ -152,7 +164,44 @@ thread_create(const char *name)
+ 	/* VFS fields */
+ 	thread->t_cwd = NULL;
+ 
++	/* To protect from multiple thread generating pid same time - Babu*/
++	spinlock_acquire(&proc_lock);
++
++	// creation of pid
++	thread->t_process->p_pid_self = allocate_pid();
++
++	// Adding entry to process table
++	addto_proc_table(thread->t_process);
++
++	spinlock_release(&proc_lock);
++
++	if( thread->t_process->p_pid_self > 4) /* curr thread is the parent */
++		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
++	else /* -1 to denote that this is the init process*/
++		thread->t_process->p_pid_parent = -1;
++
++
++	thread->t_process->p_exitsem = sem_create("p_exitsem", 0);
++	thread->t_process->p_exited = false;
++	thread->t_process->p_thread = thread;
++	DEBUG(DB_THREADS, "Thread created %s", thread->t_name);
++
++
++
+ 	/* If you add to struct thread, be sure to initialize here */
++	/*File descriptor*/
++		int i;
++		for (i=0;i<OPEN_MAX;i++)
++		{
++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
++			if (thread->ft[i] == NULL)
++					{
++						kfree(thread);
++						return NULL;
++					}
++			thread->ft[i]=0;
++		}
++		thread->priority = 5;
+ 
+ 	return thread;
+ }
+@@ -262,7 +311,9 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++	DEBUG(DB_THREADS, "%s Thread destroyed.",thread->t_name); 
+ 	kfree(thread->t_name);
++	//if(thread->ft!=NULL)kfree(thread->ft);
+ 	kfree(thread);
+ }
+ 
+@@ -381,6 +432,8 @@ thread_bootstrap(void)
+ 	curthread->t_cpu = curcpu;
+ 	curcpu->c_curthread = curthread;
+ 
++	spinlock_init(&proc_lock);
++
+ 	/* Done */
+ }
+ 
+@@ -483,7 +536,7 @@ thread_fork(const char *name,
+ 	    struct thread **ret)
+ {
+ 	struct thread *newthread;
+-
++	int i=0;
+ 	newthread = thread_create(name);
+ 	if (newthread == NULL) {
+ 		return ENOMEM;
+@@ -520,7 +573,21 @@ thread_fork(const char *name,
+ 	 */
+ 	newthread->t_iplhigh_count++;
+ 
++	//Might have to add the copy of the file table --vasanth
++	// Yes - Copying file table as part of fork - Babu
++	for (i = 0; i < OPEN_MAX; i++)
++	{
++		newthread->ft[i] = curthread->ft[i];
++		if ( curthread->ft[i] !=0)
++		{
++			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
++										 	 // parent and child point to the same ft
++			newthread->ft[i]->ref_count++;
++		}
++	}
++
+ 	/* Set up the switchframe so entrypoint() gets called */
++
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+ 	/* Lock the current cpu's run queue and make the new thread runnable */
+@@ -574,6 +641,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
++	if ( cur->priority > 0 && cur->priority< 10)
++	{
++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
++	}
+ 
+ 	/* Lock the run queue. */
+ 	spinlock_acquire(&curcpu->c_runqueue_lock);
+@@ -585,6 +657,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 		return;
+ 	}
+ 
++
+ 	/* Put the thread in the right place. */
+ 	switch (newstate) {
+ 	    case S_RUN:
+@@ -618,6 +691,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	}
+ 	cur->t_state = newstate;
+ 
++
+ 	/*
+ 	 * Get the next thread. While there isn't one, call md_idle().
+ 	 * curcpu->c_isidle must be true when md_idle is
+@@ -791,9 +865,25 @@ void
+ thread_exit(void)
+ {
+ 	struct thread *cur;
++	int i = 0;
+ 
+ 	cur = curthread;
+ 
++	/**
++	 * TODO
++	 * Added by Babu :
++	 * Closing file handles which thread possess
++	 */
++	for (i = 0; i < OPEN_MAX; i++)
++	{
++		if (curthread->ft[i] !=  NULL)
++		{
++			// close file descriptor. Ask vasanth
++			//close(i);
++		}
++	}
++
++
+ 	/* VFS fields */
+ 	if (cur->t_cwd) {
+ 		VOP_DECREF(cur->t_cwd);
+@@ -818,7 +908,16 @@ thread_exit(void)
+ 	thread_checkstack(cur);
+ 
+ 	/* Interrupts off on this processor */
+-        splhigh();
++    splhigh();
++
++    /* Added by Babu :
++     * return if invalid parent and return if parent already exited
++     * */
++	//if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
++	{
++		V(curthread->t_process->p_exitsem);
++	}
++
+ 	thread_switch(S_ZOMBIE, NULL);
+ 	panic("The zombie walks!\n");
+ }
+@@ -853,6 +952,24 @@ schedule(void)
+ {
+   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
+   // "interactive" threads here.
++	spinlock_acquire(&curcpu->c_runqueue_lock);
++	if (curcpu->c_runqueue.tl_count>1)
++	{
++		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
++		while(tnode->tln_next->tln_next != NULL )
++		{
++			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
++			tnode = tnode->tln_next;
++			int curr_priority = tnode->tln_self->priority;
++			//kprintf("curr_priority %d\n",curr_priority);
++			if ( curr_priority < head_priority)
++			{
++				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
++				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
++			}
++		}
++	}
++	spinlock_release(&curcpu->c_runqueue_lock);
+ }
+ #endif
+ 
+diff --git a/kern/vfs/device.c b/kern/vfs/device.c
+index 5446f7b..0357b2a 100644
+--- a/kern/vfs/device.c
++++ b/kern/vfs/device.c
+@@ -52,6 +52,7 @@ static
+ int
+ dev_open(struct vnode *v, int flags)
+ {
++	DEBUG(DB_VFS, "Calling Device Open...");
+ 	struct device *d = v->vn_data;
+ 
+ 	if (flags & (O_CREAT | O_TRUNC | O_EXCL | O_APPEND)) {
+@@ -69,6 +70,7 @@ static
+ int
+ dev_close(struct vnode *v)
+ {
++	DEBUG(DB_VFS, "Calling Device Close...");
+ 	struct device *d = v->vn_data;
+ 	return d->d_close(d);
+ }
+@@ -81,6 +83,7 @@ static
+ int
+ dev_reclaim(struct vnode *v)
+ {
++	DEBUG(DB_VFS, "Calling Device Reclaim...");
+ 	(void)v;
+ 	/* nothing - device continues to exist even when not in use */
+ 	return 0;
+@@ -93,6 +96,7 @@ static
+ int
+ dev_read(struct vnode *v, struct uio *uio)
+ {
++	DEBUG(DB_VFS, "Calling Device Read...");
+ 	struct device *d = v->vn_data;
+ 	KASSERT(uio->uio_rw == UIO_READ);
+ 	return d->d_io(d, uio);
+diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
+index 302fa7b..507b6b1 100644
+--- a/kern/vm/addrspace.c
++++ b/kern/vm/addrspace.c
+@@ -33,6 +33,10 @@
+ #include <addrspace.h>
+ #include <vm.h>
+ 
++uint32_t P_INVAL = 0;
++uint32_t P_READ = 1;
++uint32_t P_WRITE = 2;
++
+ /*
+  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
+  * assignment, this file is not compiled or linked or in any way
+@@ -52,7 +56,10 @@ as_create(void)
+ 	/*
+ 	 * Initialize as needed.
+ 	 */
+-
++	as->table = NULL;
++	as->reg = NULL;
++	as->sbase = 0;
++	as->stop = 0;
+ 	return as;
+ }
+ 
+@@ -65,14 +72,29 @@ as_copy(struct addrspace *old, struct addrspace **ret)
+ 	if (newas==NULL) {
+ 		return ENOMEM;
+ 	}
+-
+-	/*
+-	 * Write this.
+-	 */
+-
+-	(void)old;
+-	
+-	*ret = newas;
++	struct addrspace *new;
++	int numRegTab = 0;
++		new = as_create();
++		if (new==NULL) {
++			return ENOMEM;
++		}
++		new->hbase = old->hbase;
++		new->htop = old->htop;
++		new->sbase = old->sbase;
++		new->stop = old->stop;
++		while(old->reg != NULL)
++		{
++			numRegTab++;
++		}
++		memmove(new->reg,old->reg,(sizeof(struct region)* numRegTab));
++		numRegTab = 0;
++		while(old->table != NULL)
++		{
++			numRegTab++;
++		}
++		memmove(new->table,old->table,(sizeof(struct pagetable)* numRegTab));
++		numRegTab = 0;
++		*ret = newas;
+ 	return 0;
+ }
+ 
+@@ -82,7 +104,27 @@ as_destroy(struct addrspace *as)
+ 	/*
+ 	 * Clean up as needed.
+ 	 */
+-	
++	struct region *reg;
++	struct pagetable *page;
++
++		while (as->reg != NULL)
++		{
++			reg = as->reg;
++			as->reg = as->reg->next;
++			kfree(reg);
++		}
++
++		while(as->table != NULL)
++		{
++			page = as->table;
++			if(page->phyaddress != 0)
++			{
++				page_free(page->phyaddress);
++				as->table = as->table->next;
++				kfree(page);
++			}
++
++		}
+ 	kfree(as);
+ }
+ 
+@@ -94,6 +136,7 @@ as_activate(struct addrspace *as)
+ 	 */
+ 
+ 	(void)as;  // suppress warning until code gets written
++	vm_tlbshootdown_all();
+ }
+ 
+ /*
+@@ -114,13 +157,50 @@ as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+ 	 * Write this.
+ 	 */
+ 
+-	(void)as;
+-	(void)vaddr;
+-	(void)sz;
+ 	(void)readable;
+ 	(void)writeable;
+ 	(void)executable;
+-	return EUNIMP;
++
++	struct region *reg,*tmp;
++
++	sz += vaddr & ~(vaddr_t)PAGE_FRAME; //Aligning Regions
++	vaddr &= PAGE_FRAME;
++
++		/* ...and now the length. */
++	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
++
++		// Update heap_start
++	as->hbase = vaddr + (sz/PAGE_SIZE) * PAGE_SIZE;
++	as->htop = vaddr + (sz/PAGE_SIZE) * PAGE_SIZE;
++
++		// Record region (to be used in vm_fault)
++		reg = kmalloc(sizeof(struct region));
++		if (reg == NULL)return ENOMEM;
++		KASSERT(reg!=NULL);
++		reg->viraddress = vaddr;
++		reg->numpages = sz / PAGE_SIZE;
++		reg->next = NULL;
++		/*reg->readable = readable;
++		reg->writeable = writeable;
++		reg->executable = executable;*/
++		if(as->reg == NULL)
++			{
++				as->reg = reg;
++				as->reg->next = NULL;
++			}
++		else
++			{
++				tmp = as->reg;
++				if (tmp && tmp->next )
++				{
++				while(tmp->next != NULL)
++				{
++					tmp = tmp->next;
++				}
++				tmp->next = reg;
++				}
++			}
++		return 0;
+ }
+ 
+ int
+@@ -129,8 +209,42 @@ as_prepare_load(struct addrspace *as)
+ 	/*
+ 	 * Write this.
+ 	 */
+-
+-	(void)as;
++	struct region *reg;
++	struct pagetable *page,*temp;
++	reg = as->reg;
++	while(reg!=NULL)
++	{
++		size_t i;
++		size_t cnt = reg->numpages;
++		vaddr_t reg_base = reg->viraddress;
++		temp = as->table;
++		if (temp !=NULL)
++		{
++			while(temp->next != NULL)
++			{
++				temp = temp->next;
++			}
++		}
++		for(i=0;i<cnt;i++)
++		{
++		 	page = (struct pagetable *)kmalloc(sizeof(struct pagetable));
++			KASSERT(page!=NULL);
++			//virtual address being computed according to the base address for the region.
++			page->viraddress = reg_base + i * PAGE_SIZE;
++			page->phyaddress = page_alloc();
++			page->next = NULL;
++			if(temp == NULL)
++			{
++				as->table=temp=page;
++			}
++			else
++			{
++				temp->next = page;
++				temp = temp->next;
++			}
++		}
++		reg = reg->next;
++	}
+ 	return 0;
+ }
+ 
+@@ -152,11 +266,51 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+ 	 * Write this.
+ 	 */
+ 
+-	(void)as;
+-
+ 	/* Initial user-level stack pointer */
++	as->sbase = USERSTACK;
++	as->stop =USERSTACK;
+ 	*stackptr = USERSTACK;
+ 	
+ 	return 0;
+ }
+ 
++/**
++ * Get address space permissions
++ */
++uint32_t
++as_permissions(struct addrspace *as, vaddr_t faultaddress)
++{
++	KASSERT(as!= NULL);
++	KASSERT(as->reg!= NULL);
++	struct region *as_region = as->reg;
++	while(as_region->next != NULL)
++	{
++		if(faultaddress == as_region->viraddress)
++		{
++			return as_region->permissions;
++		}
++		as_region = as_region->next;
++	}
++	return P_INVAL;
++}
++
++/**
++ * Get Page table entry
++ */
++struct pagetable *
++as_pagetable_entry(struct addrspace *as, vaddr_t faultaddress)
++{
++	KASSERT(as!= NULL);
++	KASSERT(as->table != NULL);
++	struct pagetable *as_ptable = as->table;
++	while(as_ptable->next != NULL)
++	{
++		if(faultaddress == as_ptable->viraddress)
++		{
++			return as_ptable;
++		}
++		as_ptable  = as_ptable->next;
++	}
++	return NULL;
++}
++
+diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
+index 09b764b..f8efc2d 100644
+--- a/kern/vm/kmalloc.c
++++ b/kern/vm/kmalloc.c
+@@ -148,9 +148,11 @@ allocpageref(void)
+ 	unsigned i,j;
+ 	uint32_t k;
+ 
++	DEBUG(DB_KMALLOC, "Allocating Page Reference ..... ");
+ 	for (i=0; i<INUSE_WORDS; i++) {
+ 		if (pagerefs_inuse[i]==0xffffffff) {
+ 			/* full */
++			DEBUG(DB_KMALLOC, "Virtual Memory is full. All pages are being used...");
+ 			continue;
+ 		}
+ 		for (k=1,j=0; k!=0; k<<=1,j++) {
+@@ -179,6 +181,7 @@ freepageref(struct pageref *p)
+ 	k = ((uint32_t)1) << (j%32);
+ 	KASSERT((pagerefs_inuse[i] & k) != 0);
+ 	pagerefs_inuse[i] &= ~k;
++	DEBUG(DB_VM, "VM Page references freed ");
+ }
+ 
+ ////////////////////////////////////////
+@@ -218,6 +221,7 @@ checksubpage(struct pageref *pr)
+ 
+ 	KASSERT(spinlock_do_i_hold(&kmalloc_spinlock));
+ 
++	DEBUG(DB_VM, "Checking Sub Pages...");
+ 	if (pr->freelist_offset == INVALID_OFFSET) {
+ 		KASSERT(pr->nfree==0);
+ 		return;
+@@ -226,6 +230,7 @@ checksubpage(struct pageref *pr)
+ 	prpage = PR_PAGEADDR(pr);
+ 	blktype = PR_BLOCKTYPE(pr);
+ 
++	DEBUG(DB_VM,"Free List of VM Pages %u",pr->freelist_offset);
+ 	KASSERT(pr->freelist_offset < PAGE_SIZE);
+ 	KASSERT(pr->freelist_offset % sizes[blktype] == 0);
+ 
+@@ -525,7 +530,6 @@ subpage_kfree(void *ptr)
+ 	spinlock_acquire(&kmalloc_spinlock);
+ 
+ 	checksubpages();
+-
+ 	for (pr = allbase; pr; pr = pr->next_all) {
+ 		prpage = PR_PAGEADDR(pr);
+ 		blktype = PR_BLOCKTYPE(pr);
+diff --git a/kern/vm/vm.c b/kern/vm/vm.c
+new file mode 100644
+index 0000000..220971b
+--- /dev/null
++++ b/kern/vm/vm.c
+@@ -0,0 +1,606 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <lib.h>
++#include <spl.h>
++#include <spinlock.h>
++#include <thread.h>
++#include <current.h>
++#include <mips/tlb.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <synch.h>
++#include <clock.h>
++
++/*
++ * Working VM which is carved out of VM assignment :)
++ * Author : Babu
++ */
++
++/* under dumbvm, always have 48k of user stack */
++//#define DUMBVM_STACKPAGES    12
++
++/*
++ * Wrap rma_stealmem in a spinlock.
++ */
++static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
++
++struct spinlock spnlock_coremap;
++
++uint32_t vol_pagefree =  0;
++
++//uint32_t P_INVAL = 0;
++//uint32_t P_READ = 1;
++//uint32_t P_WRITE = 2;
++
++/*
++ * flag to check whether the vm_bootstrap has been initialized
++ */
++bool is_vm_bootstrapped = false;
++
++void
++vm_bootstrap(void)
++{
++	paddr_t paddr_first = 0;
++	paddr_t paddr_last = 0;
++	paddr_t paddr_free = 0;
++
++	spinlock_init(&spnlock_coremap);
++
++	/* Initialize coremap */
++	ram_getsize(&paddr_first, &paddr_last);
++
++
++	//page_num = ROUNDUP(paddr_last, PAGE_SIZE) / PAGE_SIZE;// :| Why rounddown?
++	//page_num = ROUNDDOWN(paddr_last, PAGE_SIZE) / PAGE_SIZE;
++	paddr_t ramsize = (paddr_last - paddr_first);
++	page_num =  (ramsize - (ramsize % 4)) / PAGE_SIZE;
++
++
++	/* pages should be a kernel virtual address !!  */
++	pages = (struct page *) PADDR_TO_KVADDR(paddr_first);
++	paddr_free = paddr_first + (page_num * CME_SIZE); // core map size
++
++	// Mapping coremap elements(page table entry - PTE) to their respective virtual memory.
++	paddr_t tmp_addr = paddr_first;
++	for (uint32_t i = 0; i < page_num; i++)
++	{
++		(pages + i)-> virtual_addr = PADDR_TO_KVADDR(tmp_addr);
++		(pages + i)->addrspce = NULL;
++		(pages + i)-> num_pages = 1;
++		(pages + i)-> timestamp = 0xffffffff;
++		if(tmp_addr < paddr_free)
++			(pages + i)-> page_state = FIXED;
++		else
++			(pages + i)-> page_state = FREE;
++		tmp_addr += PAGE_SIZE;
++	}
++
++	is_vm_bootstrapped = true;
++
++}
++
++/**
++ * Get pages by stealing memory from ram.
++ * Invoked during boot sequence as the vm might have not been initialized.
++ * Should never be called once vm is initialized
++ * Modified by : Babu
++ */
++static
++paddr_t
++getppages(unsigned long npages)
++{
++	paddr_t addr;
++
++	spinlock_acquire(&stealmem_lock);
++
++	addr = ram_stealmem(npages);
++
++	spinlock_release(&stealmem_lock);
++
++	return addr;
++}
++
++/* Allocate/free some kernel-space virtual pages */
++vaddr_t
++alloc_kpages(int npages)
++{
++
++	vaddr_t alloc_mem = 0;
++	if(is_vm_bootstrapped)
++	{
++		alloc_mem = page_nalloc(npages);
++	}
++	else
++	{
++		if(getppages(npages) != 0)
++			alloc_mem = PADDR_TO_KVADDR(getppages(npages));
++		else
++			panic("ERROR : Zero address returned.");
++	}
++	return alloc_mem;
++}
++
++void 
++free_kpages(vaddr_t addr)
++{
++	//kprintf("before spin");
++
++	spinlock_acquire(&spnlock_coremap);
++
++	struct page *find_page = pages;
++
++	uint32_t page_cnt = 0;
++	//while(find_page->virtual_addr != addr)
++	for(page_cnt=0;page_cnt < page_num;page_cnt++)
++	{
++		if(find_page->virtual_addr == addr)
++			break;
++		find_page ++;
++	}
++
++//	kprintf("free_k : 1");
++
++	//Check whether this is the page we are looking for to de-allocate.
++	//KASSERT(find_page->virtual_addr == addr);
++	if(find_page->virtual_addr != addr)
++	{
++		//lock_release(lock_coremap);
++		spinlock_release(&spnlock_coremap);
++		return;
++	}
++
++	//kprintf("free_k : 2");
++	// if the address to be freed belongs to kernel then dont do anything
++	// else free it.
++
++	int no_dealloc = find_page->num_pages;
++	for (int i = 0; i < no_dealloc; ++i)
++	{
++		find_page->page_state =  FREE;
++		find_page->timestamp = 0;
++		find_page->num_pages = 1;
++		//as_destroy(find_page->addrspce);
++		find_page ++;
++
++	}
++
++	//kprintf("free_k : 3");
++
++	spinlock_release(&spnlock_coremap);
++	return;
++	//kprintf("after spin");
++
++
++}
++
++
++void
++page_free(vaddr_t addr)
++{
++	spinlock_acquire(&spnlock_coremap);
++
++	struct page *find_page = pages;
++
++	uint32_t page_cnt = 0;
++	//while(find_page->virtual_addr != addr)
++	for(page_cnt=0;page_cnt < page_num;page_cnt++)
++	{
++		if(find_page->virtual_addr == addr)
++			break;
++		find_page ++;
++	}
++
++	//Check whether this is the page we are looking for to de-allocate.
++	//KASSERT(find_page->virtual_addr == addr);
++	if(find_page->virtual_addr != addr)
++	{
++		spinlock_release(&spnlock_coremap);
++		return;
++	}
++
++	// if the address to be freed belongs to kernel then dont do anything
++	// else free it.
++	if(find_page->page_state != FIXED)
++	{
++		int32_t no_dealloc = find_page->num_pages;
++		for (int32_t i = 0; i < no_dealloc; ++i)
++		{
++			find_page->page_state =  FREE;
++			find_page->timestamp = 0;
++			find_page->num_pages = 1;
++			//as_destroy(find_page->addrspce); user space ---??
++
++			find_page ++;;
++		}
++
++	}
++	else
++		kprintf("kernel page. cannot deallocate");
++
++	spinlock_release(&spnlock_coremap);
++
++	//kprintf("after spin");
++
++
++}
++
++
++/**
++ * page_alloc - Page allocation for user program
++ */
++vaddr_t
++page_alloc()
++{
++
++	//kprintf("before spin");
++
++	uint32_t npages = 1;
++	//kprintf("before spin");
++
++
++	spinlock_acquire(&spnlock_coremap);
++	/**
++	 * Find some free memory and try to allocate to the caller
++	 */
++	struct page *free_page = pages;
++
++	//kprintf("page_n : 1");
++	uint32_t start_page = 0;
++	uint32_t free_page_cnt = 0;
++	for(start_page=0;start_page < page_num;start_page++)
++	{
++		if(free_page->page_state == FREE)
++		{
++			for (free_page_cnt=1; free_page_cnt<npages; free_page_cnt++)
++			{
++				free_page ++;
++				if(free_page->page_state != FREE)
++					break;
++			}
++
++			if(free_page_cnt == npages)
++				break;
++			else
++				start_page += free_page_cnt - 1;
++		}
++		free_page ++;
++	}
++
++
++	if(free_page_cnt == 0)
++	{
++		//kprintf("page not free.. so oldest one..");
++		free_page = pages;
++		uint64_t oldest_page_timestamp = 0xffffffff;
++		uint32_t oldest_page_num = 0, i;
++		for(i=0;i < page_num; i++)
++		{
++			// TODO : allocate the pages if its not fixed untill swapping is implemented
++			/*Logic for page swapping - FIFO*/
++			if(free_page -> timestamp < oldest_page_timestamp && free_page->page_state != FIXED)
++			{
++				oldest_page_timestamp = free_page -> timestamp;
++				oldest_page_num = i;
++			}
++			free_page ++;
++		}
++
++
++		start_page = oldest_page_num;
++		free_page_cnt = npages;
++	}
++
++	//kprintf("page_n : 3");
++
++	// Check at the end of the iteration whether we got the
++	// number of pages we want
++	KASSERT(free_page_cnt == npages);
++
++	free_page = pages + start_page;
++
++	//kprintf("page_n : 4");
++
++	// Make the entire page available
++
++	for (free_page_cnt=0; free_page_cnt<npages; free_page_cnt++)
++	{
++		make_page_avail(free_page);
++
++		//free_page->addrspce = as_create(); // TODO : ????
++		free_page->num_pages = npages;
++
++		time_t current_time = -1;
++		uint32_t nanosec;
++		gettime(&current_time, &nanosec);
++		if(current_time != -1)
++			free_page->timestamp = current_time;
++		else
++		{
++			spinlock_release(&spnlock_coremap);
++			panic("time error");
++		}
++
++		// Zeroing the page before returning
++		//bzero((void *)free_page->virtual_addr, PAGE_SIZE);
++
++		free_page ++;
++
++	}
++
++	//kprintf("page_n : 5");
++
++	// Start of n chunks of free pages
++	free_page = pages + start_page;
++
++	spinlock_release(&spnlock_coremap);
++
++	//kprintf("after spin");
++
++	return free_page->virtual_addr;
++}
++
++vaddr_t
++page_nalloc(unsigned long npages)
++{
++	//kprintf("before spin");
++
++
++	spinlock_acquire(&spnlock_coremap);
++	/**
++	 * Find some free memory and try to allocate to the caller
++	 */
++	struct page *free_page = pages;
++
++	//kprintf("page_n : 1");
++	uint32_t start_page = 0;
++	uint32_t free_page_cnt = 0;
++	for(start_page=0;start_page < page_num;start_page++)
++	{
++		if(free_page->page_state == FREE)
++		{
++			for (free_page_cnt=1; free_page_cnt<npages; free_page_cnt++)
++			{
++				free_page ++;
++				if(free_page->page_state != FREE)
++					break;
++			}
++
++			if(free_page_cnt == npages)
++				break;
++			else
++				start_page += free_page_cnt - 1;
++		}
++		free_page ++;
++	}
++
++
++	if(free_page_cnt == 0)
++	{
++		//kprintf("page not free.. so oldest one..");
++		free_page = pages;
++		uint64_t oldest_page_timestamp = 0xffffffff;
++		uint32_t oldest_page_num = 0, i;
++		for(i=0;i < page_num; i++)
++		{
++			// TODO : allocate the pages if its not fixed untill swapping is implemented
++			/*Logic for page swapping - FIFO*/
++			if(free_page -> timestamp < oldest_page_timestamp && free_page->page_state != FIXED)
++			{
++				oldest_page_timestamp = free_page -> timestamp;
++				oldest_page_num = i;
++			}
++			free_page ++;
++		}
++
++
++		start_page = oldest_page_num;
++		free_page_cnt = npages;
++	}
++
++	//kprintf("page_n : 3");
++
++	// Check at the end of the iteration whether we got the
++	// number of pages we want
++	KASSERT(free_page_cnt == npages);
++
++	free_page = pages + start_page;
++
++	//kprintf("page_n : 4");
++
++	// Make the entire page available
++
++	for (free_page_cnt=0; free_page_cnt<npages; free_page_cnt++)
++	{
++		make_page_avail(free_page);
++
++		//free_page->addrspce = as_create(); // TODO : ????
++		free_page->num_pages = npages;
++
++		time_t current_time = -1;
++		uint32_t nanosec;
++		gettime(&current_time, &nanosec);
++		if(current_time != -1)
++			free_page->timestamp = current_time;
++		else
++		{
++			spinlock_release(&spnlock_coremap);
++			panic("time error");
++		}
++
++		// Zeroing the page before returning
++		//bzero((void *)free_page->virtual_addr, PAGE_SIZE);
++
++		free_page ++;
++
++	}
++
++	//kprintf("page_n : 5");
++
++	// Start of n chunks of free pages
++	free_page = pages + start_page;
++
++	spinlock_release(&spnlock_coremap);
++
++	//kprintf("after spin");
++
++	return free_page->virtual_addr;
++
++}
++
++
++/**
++ * This function will make the page available for either by evicting the page to disk
++ * a.k.a swapping out or by flushing it
++ * Author : Babu
++ */
++int32_t
++make_page_avail(struct page *free_page)
++{
++
++	// as of now just making the page state as free by flushing it
++	// TODO : implement swapping in this as_create function
++
++	// Allocating it as dirty for the first time as the disk will not have a copy
++	free_page->page_state = DIRTY;
++	bzero((void *)free_page->virtual_addr, PAGE_SIZE);
++
++	return 0;
++}
++
++
++void
++vm_tlbshootdown_all(void)
++{
++
++	/* TODO */
++
++
++}
++
++
++
++void
++vm_tlbshootdown(const struct tlbshootdown *ts)
++{
++
++	int i,spl;
++
++	spl = splhigh();
++
++	for (i=0; i<NUM_TLB; i++)
++		tlb_write(TLBHI_INVALID(i),TLBLO_INVALID(),i);
++
++	splx(spl);
++
++	(void)ts;
++}//
++
++int
++vm_fault(int faulttype, vaddr_t faultaddress)
++{
++	/* TODO */
++	struct addrspace *as = curthread->t_addrspace;
++	//uint32_t tlb_high, tlb_low;
++	//paddr_t paddress;
++
++	// get page number from MASKING variable
++	faultaddress = faultaddress & PAGE_FRAME;
++	KASSERT(faultaddress < MIPS_KSEG0);
++//	KASSERT(as != NULL);
++
++    if(faultaddress < as->htop && faultaddress > as->htop &&
++    		faultaddress < USERSTACK - PAGE_SIZE * 4096)
++    {
++    	// Valid
++    }
++    else
++    {
++    	// else return
++    	return EFAULT;
++    }
++
++    if(as_permissions(as,faultaddress) == 0)
++    	return EFAULT;
++
++    struct pagetable *pte = as_pagetable_entry(as,faultaddress);
++
++    KASSERT(pte != NULL);
++
++    uint32_t page_perm = pte->permissions;
++
++	switch(faulttype)
++	{
++		case VM_FAULT_READONLY:
++			// then update tlb
++			if(page_perm == 2)
++			{
++				struct page *find_page = pages;
++				uint32_t i = 0;
++				for (i = 0; i<page_num; ++i) {
++					if(find_page->virtual_addr == faultaddress)
++					{
++						find_page->page_state = DIRTY;
++						//find_page->addrspce = as;
++					}
++					find_page++;
++				}
++
++
++				//tlb_low =  paddress & TLBLO_PPAGE;
++				//tlb_high = faultaddress & TLBHI_VPAGE;
++			}
++			else
++				return EFAULT;
++
++			break;
++
++		case VM_FAULT_READ:
++		case VM_FAULT_WRITE:
++			// create new page with the virtual address passed
++			if(pte == NULL)
++			{
++				page_alloc();
++			}
++			else
++			{
++
++			}
++			break;
++	}
++
++
++	(void) faulttype;
++	(void) faultaddress;
++	return EUNIMP;
++}
++
++
+diff --git a/mk/os161.config.mk b/mk/os161.config.mk
+index 3de8771..8790d16 100644
+--- a/mk/os161.config.mk
++++ b/mk/os161.config.mk
+@@ -295,7 +295,7 @@
+ #
+ 
+ # Locations of things.
+-OSTREE=$(HOME)/os161/root	# Root directory to install into.
++OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
+ WORKDI
\ No newline at end of file
diff --git a/submit1.patch b/submit1.patch
new file mode 100644
index 0000000..607e894
--- /dev/null
+++ b/submit1.patch
@@ -0,0 +1,6617 @@
+diff --git a/common/libc/string/strcpy.c b/common/libc/string/strcpy.c
+index 88627ed..9a51b24 100644
+--- a/common/libc/string/strcpy.c
++++ b/common/libc/string/strcpy.c
+@@ -47,17 +47,18 @@ strcpy(char *dest, const char *src)
+ {
+ 	size_t i;
+ 
++
+ 	/*
+ 	 * Copy characters until we hit the null terminator.
+ 	 */
+ 	for (i=0; src[i]; i++) {
+ 		dest[i] = src[i];
+ 	}
+-
+ 	/*
+ 	 * Add null terminator to result.
+ 	 */
+ 	dest[i] = 0;
++	//kprintf("Destination string %s\n",dest);
+ 
+ 	return dest;
+ }
+diff --git a/defs.mk b/defs.mk
+new file mode 100644
+index 0000000..9345229
+--- /dev/null
++++ b/defs.mk
+@@ -0,0 +1,20 @@
++# This file was generated by configure. Edits will disappear if you rerun
++# configure. If you find that you need to edit this file to make things
++# work, let the course staff know and we'll try to fix the configure script.
++#
++# The purpose of this file is to hold all the makefile definitions
++# needed to adjust the OS/161 build process to any particular
++# environment. If I've done it right, all you need to do is rerun the
++# configure script and make clean if you start working on a different
++# host OS. If I've done it mostly right, you may need to edit this
++# file but you still hopefully won't need to edit any of the
++# makefiles.
++#
++# The things that can be set here are documented in mk/os161.config.mk.
++#
++
++OSTREE=$(HOME)/root
++PLATFORM=sys161
++MACHINE=mips
++COMPAT_CFLAGS=
++COMPAT_TARGETS=
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..0b3f63e 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -394,7 +394,9 @@ mips_usermode(struct trapframe *tf)
+ 	 * either another thread's stack or in the kernel heap.
+ 	 * (Exercise: why?)
+ 	 */
++	//kprintf("before SAME STACK");
+ 	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
++	//kprintf("after SAME STACK");
+ 
+ 	/*
+ 	 * This actually does it. See exception.S.
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..858018a 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -36,6 +36,8 @@
+ #include <current.h>
+ #include <syscall.h>
+ 
++#include <endian.h>
++#include <copyinout.h>
+ 
+ /*
+  * System call dispatcher.
+@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++	uint32_t retval2;
++	uint64_t ar2,ret;
++	int whence;
+ 	int err;
+ 
+ 	KASSERT(curthread != NULL);
+@@ -98,7 +103,7 @@ syscall(struct trapframe *tf)
+ 	 */
+ 
+ 	retval = 0;
+-
++	//kprintf("syscall number : %d\n",callno);
+ 	switch (callno) {
+ 	    case SYS_reboot:
+ 		err = sys_reboot(tf->tf_a0);
+@@ -109,15 +114,90 @@ syscall(struct trapframe *tf)
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
+ 
++		/**
++		 * Added by Babu : case statements for process related syscalls
++		 */
++	    case SYS_fork:
++	        err = sys_fork(&retval, tf);
++	        //kprintf("ret val : %d and err no : %d\n",retval, err);
++	    	break;
++
++	    case SYS_execv:
++	    	//err = sys_execv((char *)tf->tf_a0, (char *)tf->tf_a1);
++	    	break;
++
++	    case SYS__exit:
++	    	sys__exit((int)tf->tf_a0);
++	    	err = 0;
++	    	break;
++
++	    case SYS_waitpid:
++	    	err = sys_waitpid(&retval, (pid_t)tf->tf_a0, (int32_t *)tf->tf_a1, (int32_t)tf->tf_a2);
++	    	break;
++
++	    case SYS_getpid:
++	    	err = sys_getpid(&retval);
++	    	break;
++
++	    case SYS_getppid:
++	    	err = sys_getppid(&retval);
++	    	break;
++
++
+ 	    /* Add stuff here */
+- 
++	    // File system calls - Vasanth
++	    case SYS_open:
++	    	retval = open((userptr_t)tf->tf_a0,
++	    	(int)tf->tf_a1,&err);
++	    break;
++
++   	    case SYS_close:
++			err = close(tf->tf_a0);
++			break;
++
++        case SYS_read:
++        	retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
++        	break;
++
++        case SYS_write:
++        	retval = write(tf->tf_a0,(userptr_t)tf->tf_a1, tf->tf_a2,&err);
++        	break;
++
++        case SYS_dup2:
++        	err = dup2(tf->tf_a0,tf->tf_a1);
++        	break;
++
++        case SYS_lseek:
++			join32to64(tf->tf_a2,tf->tf_a3,&ar2);
++			//kprintf("Correct lseek called\n");
++			if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0)
++			{
++				   break;
++			}
++			ret = lseek((int)tf->tf_a0,ar2,whence,&err);
++			//kprintf("ret value %llu\n",ret);
++			split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
++			//kprintf("Retval %d,%d\n",retval,retval2);
++			if (!err)
++			{
++				tf->tf_v1 = retval2;
++			}
++			break;
++
++        case SYS_chdir:
++        	err = chdir((const_userptr_t)tf->tf_a0);
++        	break;
++
++        case SYS___getcwd:
++			err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
++			break;
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+ 		break;
+ 	}
+ 
+-
+ 	if (err) {
+ 		/*
+ 		 * Return the error code. This gets converted at
+@@ -137,7 +217,7 @@ syscall(struct trapframe *tf)
+ 	 * Now, advance the program counter, to avoid restarting
+ 	 * the syscall over and over again.
+ 	 */
+-	
++
+ 	tf->tf_epc += 4;
+ 
+ 	/* Make sure the syscall code didn't forget to lower spl */
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..7b94cac 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,8 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file	  syscall/file_syscalls.c
++file	  syscall/process.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
+new file mode 100644
+index 0000000..40e3f6c
+--- /dev/null
++++ b/kern/include/fcntl.h
+@@ -0,0 +1,100 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_FCNTL_H_
++#define _KERN_FCNTL_H_
++
++/*
++ * Constants for libc's <fcntl.h>.
++ */
++
++
++/*
++ * Important
++ */
++
++/* Flags for open: choose one of these: */
++#define O_RDONLY      0      /* Open for read */
++#define O_WRONLY      1      /* Open for write */
++#define O_RDWR        2      /* Open for read and write */
++/* then or in any of these: */
++#define O_CREAT       4      /* Create file if it doesn't exist */
++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
++#define O_TRUNC      16      /* Truncate file upon open */
++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
++
++/* Additional related definition */
++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
++
++/*
++ * Not so important
++ */
++
++/* operation codes for flock() */
++#define LOCK_SH         1       /* shared lock */
++#define LOCK_EX         2       /* exclusive lock */
++#define LOCK_UN         3       /* release the lock */
++#define LOCK_NB         4       /* flag: don't block */
++
++/*
++ * Mostly pretty useless
++ */
++
++/* fcntl() operations */
++#define F_DUPFD         0       /* like dup() but not quite */  
++#define F_GETFD         1       /* get per-handle flags */
++#define F_SETFD         2       /* set per-handle flags */
++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
++#define F_GETLK         7       /* inspect record locks */
++#define F_SETLK         8       /* acquire record locks nonblocking */
++#define F_SETLKW        9       /* acquire record locks and wait */
++
++/* flag for F_GETFD and F_SETFD */
++#define FD_CLOEXEC      1       /* close-on-exec */
++
++/* modes for fcntl (F_GETLK/SETLK) locking */
++#define F_RDLCK         0       /* shared lock */
++#define F_WRLCK         1       /* exclusive lock */
++#define F_UNLCK         2       /* unlock */
++
++/* struct for fcntl (F_GETLK/SETLK) locking */
++struct flock {
++	off_t l_start;          /* place in file */
++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
++	int l_type;             /* F_RDLCK or F_WRLCK */
++	off_t l_len;            /* length of locked region */
++	pid_t l_pid;            /* process that holds the lock */
++};
++
++
++#endif /* _KERN_FCNTL_H_ */
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..a1941ec 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -96,5 +96,11 @@
+ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+ #define __IOV_MAX       1024
+ 
++/* Max number of process which can run on os161*/
++#define _MAX_RUNNING_PROCS 400
++
++
++/*Maximum number of file table entry per process */
++#define _MAX_FILE 10
+ 
+ #endif /* _KERN_LIMITS_H_ */
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..81ec912 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,7 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++#define MAX_RUNNING_PROCS _MAX_RUNNING_PROCS
++#define MAX_FILE _MAX_FILE
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/process.h b/kern/include/process.h
+new file mode 100644
+index 0000000..dbc23ba
+--- /dev/null
++++ b/kern/include/process.h
+@@ -0,0 +1,97 @@
++/*
++ * process.h
++ *
++ *  	Created on: Mar 8, 2014
++ *      Author: Babu
++ */
++
++#ifndef PROCESS_H_
++#define PROCESS_H_
++
++struct trapframe;
++
++/*
++ * Process table which holds all information about the process
++ * such as pid, parent process, threads belongs to that process
++ *
++ */
++struct process {
++
++	pid_t p_pid_self;  /* process id of the process */
++
++	struct thread *p_thread;
++
++	pid_t p_pid_parent;
++
++	// Variables for process exit
++	bool p_exited;
++
++	int p_exitcode;
++
++	struct semaphore *p_exitsem;
++};
++
++
++/**TODO Process Table change it to 256 to MAX_RUNNING_PROCESS**/
++
++struct process *processtable[256];
++
++struct lock *pid_sem;
++
++/**
++ * When a process exits it should invoke this method so that
++ * this will add the allocated pid to free pool which can be assigned
++ * for other process  - Added by Babu
++ */
++void add_pid_to_pool(pid_t);
++
++
++/**
++ * Allocate pid based on the pids available in the pool or
++ * generate from the counter if the pool is empty  - Added by Babu
++ */
++pid_t allocate_pid(void);
++
++/**
++ * function to destroy process and it related book keeping stuffs
++ */
++void process_destroy(struct process *process);
++
++
++/**
++ * getpid system call which fetches the pid of the calling process
++ */
++pid_t sys_getpid(int32_t *retval);
++
++/**
++ * getppid system call which fetches the pid of the calling process parent
++ */
++pid_t sys_getppid(int32_t *retval);
++
++/**
++ * exit system call which allows the calling process to exit
++ */
++void sys__exit(int exitcode);
++
++/**
++ * wait system call allows the calling process' parent to collect the status of child process
++ */
++int sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags);
++
++/**
++ * fork system call which creates clone of the calling process
++ */
++int sys_fork(int32_t *retval, struct trapframe *tf);
++
++/**
++ * execv system call allows create process from the file and loads into address space and executes
++ */
++int sys_execv(char *prgname, char *argv[]);
++
++/**
++ * Entry point function for the child process/thread created by fork()
++ */
++void child_entrypoint(void *data1, unsigned long data2);
++
++
++#endif /* PROCESS_H_ */
+diff --git a/kern/include/seek.h b/kern/include/seek.h
+new file mode 100644
+index 0000000..cf1cfe6
+--- /dev/null
++++ b/kern/include/seek.h
+@@ -0,0 +1,47 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_SEEK_H_
++#define _KERN_SEEK_H_
++
++/*
++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
++ * <unistd.h> and thus get their own file.
++ *
++ * These are pretty important. Back in the day (like 20+ years ago)
++ * people would often just write the values 0, 1, and 2, but that's
++ * really not recommended.
++ */
++
++#define SEEK_SET      0      /* Seek relative to beginning of file */
++#define SEEK_CUR      1      /* Seek relative to current position in file */
++#define SEEK_END      2      /* Seek relative to end of file */
++
++
++#endif /* _KERN_SEEK_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..35565c6 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        //added by vasanth
++        volatile struct thread *lock_owner;
++        struct wchan *lock_wchan;
++        struct spinlock spn_lock;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_waitchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ /*
+  * 13 Feb 2012 : GWA : Reader-writer locks.
+  */
+-
++/* we use two waiting channels one for reader and one for writer we do this so that
++ *if a writer is waiting all the readers will be put on sleep until the writers are
++ *done with their writing
++ */
+ struct rwlock {
+         char *rwlock_name;
++        volatile int num_reader;
++        volatile int num_writer;
++        struct wchan *rlock_wchan;
++        struct wchan *wlock_wchan;
++        struct lock *rw_lock;
++
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..c86d805 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -27,6 +27,9 @@
+  * SUCH DAMAGE.
+  */
+ 
++#include <process.h>
++
++
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+ 
+@@ -57,5 +60,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ 
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+-
++int open(userptr_t filename, int flags,int *err);
++int close(int fd);
++int read(int fd, userptr_t buf, size_t buflen,int *err);
++int write(int fd, userptr_t buf, size_t buflen,int *err);
++int dup2(int oldfd, int newfd);
++off_t lseek(int fd,off_t pos, int whence, int *err);
++int chdir(const_userptr_t pathname);
++int __getcwd(userptr_t buf, size_t buflen);
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..067311f 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -63,16 +63,25 @@ void whalemating_cleanup(void);
+  * Traffic light.
+  */
+ 
+-void inQuadrant(int);
++//volatile unsigned long intersectionOccupied = 0;
++
++/**
++* Added by Babu:
++* Locks for each quadrants
++**/
++
++
++
+ void leaveIntersection(void);
+ int stoplight(int, char **);
+-
++void inQuadrant(int);
+ void gostraight(void *, unsigned long);
+ void turnleft(void *, unsigned long);
+ void turnright(void *, unsigned long);
+ void stoplight_init(void);
+ void stoplight_cleanup(void);
+ 
++
+ /*
+  * Test code.
+  */
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..31a1868 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,7 +38,7 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
+-
++#include <limits.h>
+ struct addrspace;
+ struct cpu;
+ struct vnode;
+@@ -57,6 +57,7 @@ struct vnode;
+ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
+ 
+ 
++
+ /* States a thread can be in. */
+ typedef enum {
+ 	S_RUN,		/* running */
+@@ -65,6 +66,15 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++struct fTable{
++	    char *name;
++	    int status;
++	    off_t offset;
++	    int ref_count;
++	    struct lock *lock;
++	    struct vnode *vn;
++	};
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -101,9 +111,16 @@ struct thread {
+ 	int t_curspl;			/* Current spl*() state */
+ 	int t_iplhigh_count;		/* # of times IPL has been raised */
+ 
++
++
+ 	/*
+ 	 * Public fields
+ 	 */
++	/**
++	 * Added by Babu :
++	 * pointer to parent process data structure
++	 */
++	struct process *t_process;
+ 
+ 	/* VM */
+ 	struct addrspace *t_addrspace;	/* virtual address space */
+@@ -112,8 +129,11 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
++	int priority;
+ };
+ 
++
+ /* Call once during system startup to allocate data structures. */
+ void thread_bootstrap(void);
+ 
+diff --git a/kern/include/unistd.h b/kern/include/unistd.h
+new file mode 100644
+index 0000000..30f2678
+--- /dev/null
++++ b/kern/include/unistd.h
+@@ -0,0 +1,39 @@
++/*
++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++ *	The President and Fellows of Harvard College.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ */
++
++#ifndef _KERN_UNISTD_H_
++#define _KERN_UNISTD_H_
++
++/* Constants for read/write/etc: special file handles */
++#define STDIN_FILENO  0      /* Standard input */
++#define STDOUT_FILENO 1      /* Standard output */
++#define STDERR_FILENO 2      /* Standard error */
++
++
++#endif /* _KERN_UNISTD_H_ */
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..1ba112a 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -1,3 +1,4 @@
++/*vsubrama@buffalo.edu*/
+ /*
+  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+  *	The President and Fellows of Harvard College.
+@@ -100,7 +101,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("babupras@buffalo.edu vsubrama@buffalo.edu 's system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..32889e8 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -96,11 +96,12 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 	}
+ 
+ 	/* Hope we fit. */
++	//kprintf("Passed function name %s\n",args[0]);
+ 	KASSERT(strlen(args[0]) < sizeof(progname));
++	strcpy(progname,args[0]);
+ 
+-	strcpy(progname, args[0]);
+-
+-	result = runprogram(progname);
++	//kprintf("progname : %s\n", progname);
++	result = runprogram(args[0]);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+@@ -133,10 +134,32 @@ common_prog(int nargs, char **args)
+ 		"synchronization-problems kernel.\n");
+ #endif
+ 
++	struct thread *newthread = NULL;
++	pid_t retpid ;
++	//struct thread *parentthread = curthread;
++	int status = 0 , err = 0;
++	//kprintf("before thread fork args  : %s, %s\n", args[0], args[1]);
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&newthread);
++
++	if(newthread != NULL)
++	{
++		// Parent wait
++
++		//err = waitpid(newthread->t_process->p_pid_self, &status, 1);
++		err = sys_waitpid(&retpid, newthread->t_process->p_pid_self, &status, 2);
++		if(err != 0)
++		{
++			kprintf("wait not success : %d\n", err);
++		}
++	}
++	// child wait
++	//something like this is expected please do --vasanth
++	//int s_wait;
++
++	//sys_waitpid(NULL, fork_Thread->t_process->p_pid_self,&s_wait,0);
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+@@ -157,6 +180,8 @@ cmd_prog(int nargs, char **args)
+ 		return EINVAL;
+ 	}
+ 
++	kprintf("cmd_prg args  : %s, %s\n", args[0], args[1]);
++
+ 	/* drop the leading "p" */
+ 	args++;
+ 	nargs--;
+@@ -579,6 +604,8 @@ cmd_dispatch(char *cmd)
+ 	char *context;
+ 	int i, result;
+ 
++	kprintf("cmd : %s\n",cmd);
++
+ 	for (word = strtok_r(cmd, " \t", &context);
+ 	     word != NULL;
+ 	     word = strtok_r(NULL, " \t", &context)) {
+@@ -587,7 +614,9 @@ cmd_dispatch(char *cmd)
+ 			kprintf("Command line has too many words\n");
+ 			return E2BIG;
+ 		}
++		kprintf("original wrd :%s\n",word);
+ 		args[nargs++] = word;
++		kprintf("args :%s\n",args[nargs-1]);
+ 	}
+ 
+ 	if (nargs==0) {
+diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
+index 02e336f..05d3d21 100644
+--- a/kern/synchprobs/drivers.c
++++ b/kern/synchprobs/drivers.c
+@@ -148,7 +148,7 @@ inline void leaveIntersection() {
+ 	kprintf("%s left the intersection\n", curthread->t_name);
+ }
+ 
+-#define NCARS 99
++#define NCARS 10
+ 
+ struct semaphore * stoplightMenuSemaphore;
+ 
+@@ -158,12 +158,13 @@ int stoplight(int nargs, char **args) {
+ 	int i, direction, turn, err = 0;
+ 	char name[32];
+ 
++	kprintf("Stop light called\n");
++	stoplight_init();
+ 	stoplightMenuSemaphore = sem_create("Stoplight Driver Semaphore", 0);
+ 	if (stoplightMenuSemaphore == NULL ) {
+ 		panic("stoplight: sem_create failed.\n");
+ 	}
+ 
+-	stoplight_init();
+ 
+ 	for (i = 0; i < NCARS; i++) {
+ 
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..820f67e 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -35,6 +35,7 @@
+ #include <thread.h>
+ #include <test.h>
+ #include <synch.h>
++#include <wchan.h>
+ 
+ /*
+  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
+@@ -46,8 +47,84 @@
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct lock *lockquad0;
++struct lock *lockquad1;
++struct lock *lockquad2;
++struct lock *lockquad3;
++void inQuadrantSync(unsigned long);
++struct lock *getlock(int destQuadrant);
+ 
++struct whalemating
++{
++	volatile int num_male_whale;
++	volatile int num_female_whale;
++	volatile int num_matchmaker_whale;
++	struct wchan *male_wchan;
++	struct wchan *female_wchan;
++	struct wchan *matchmaker_wchan;
++	struct wchan *match_wchan;
++	volatile int match_found;
++	struct lock *lock;
++	volatile int match_male;
++	volatile int match_female;
++};
++struct whalemating *whale_mating;
+ void whalemating_init() {
++
++
++	whale_mating = kmalloc(sizeof(struct whalemating));
++	if (whale_mating == NULL)
++	{
++		return;
++	}
++	whale_mating->male_wchan = wchan_create("name");
++	if (whale_mating->male_wchan == NULL)
++	{
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->female_wchan = wchan_create("name");
++	if (whale_mating->female_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->matchmaker_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->match_wchan = wchan_create("name");
++	if (whale_mating->matchmaker_wchan == NULL)
++		{
++			wchan_destroy(whale_mating->male_wchan);
++			wchan_destroy(whale_mating->female_wchan);
++			wchan_destroy(whale_mating->match_wchan);
++			kfree(whale_mating);
++			return;
++		}
++	whale_mating->lock = lock_create("name");
++	if (whale_mating->lock == NULL)
++	{
++		wchan_destroy(whale_mating->male_wchan);
++		wchan_destroy(whale_mating->female_wchan);
++		wchan_destroy(whale_mating->matchmaker_wchan);
++		wchan_destroy(whale_mating->match_wchan);
++		kfree(whale_mating);
++		return;
++	}
++	whale_mating->num_male_whale = 0;
++	whale_mating->num_female_whale = 0;
++	whale_mating->num_matchmaker_whale = 0;
++	whale_mating->match_found=0;
++	whale_mating->match_male=0;
++	whale_mating->match_female=0;
++
++
+   return;
+ }
+ 
+@@ -55,6 +132,12 @@ void whalemating_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++	wchan_destroy(whale_mating->male_wchan);
++	wchan_destroy(whale_mating->female_wchan);
++	wchan_destroy(whale_mating->matchmaker_wchan);
++	wchan_destroy(whale_mating->match_wchan);
++	lock_destroy(whale_mating->lock);
++	kfree(whale_mating);
+   return;
+ }
+ 
+@@ -64,9 +147,26 @@ male(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
+-  male_start();
+-	// Implement this function 
+-  male_end();
++ lock_acquire(whale_mating->lock);
++ male_start();
++	// Implement this function
++
++ while(whale_mating->num_male_whale>=1)
++ {
++   wchan_lock(whale_mating->male_wchan);
++   lock_release(whale_mating->lock);
++   wchan_sleep(whale_mating->male_wchan);
++   lock_acquire(whale_mating->lock);
++ }
++ whale_mating->num_male_whale++;
++ wchan_wakeall(whale_mating->match_wchan);
++ while(!(whale_mating->match_found==1))
++ {
++	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++ }
++ whale_mating->match_male=1;
++ male_end();
++ lock_release(whale_mating->lock);
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -80,32 +180,78 @@ female(void *p, unsigned long which)
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+   
++  lock_acquire(whale_mating->lock);
+   female_start();
+-	// Implement this function 
++
++	// Implement this function
++
++   while(whale_mating->num_female_whale>=1)
++   {
++     wchan_lock(whale_mating->female_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->female_wchan);lock_acquire(whale_mating->lock);
++   }
++   whale_mating->num_female_whale++;
++   wchan_wakeall(whale_mating->match_wchan);
++   while(!(whale_mating->match_found==1))
++   {
++  	 wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++   }
++  whale_mating->match_female=1;
+   female_end();
+-  
++  lock_release(whale_mating->lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ void
+ matchmaker(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++  lock_acquire(whale_mating->lock);
+   matchmaker_start();
+-	// Implement this function 
++  while(whale_mating->num_matchmaker_whale>=1)
++  {
++     wchan_lock(whale_mating->matchmaker_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->matchmaker_wchan);lock_acquire(whale_mating->lock);
++  }
++  whale_mating->num_matchmaker_whale++;
++  wchan_wakeall(whale_mating->match_wchan);
++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
++  {
++	  wchan_lock(whale_mating->match_wchan);lock_release(whale_mating->lock);wchan_sleep(whale_mating->match_wchan);lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_found=1;
++  wchan_wakeall(whale_mating->match_wchan);
++  while(whale_mating->match_male!=1 || whale_mating->match_female!=1)
++  {
++  lock_release(whale_mating->lock);
++  lock_acquire(whale_mating->lock);
++  }
++  whale_mating->match_male=0;
++  whale_mating->match_female=0;
++  whale_mating->num_male_whale--;
++  whale_mating->num_female_whale--;
++  whale_mating->num_matchmaker_whale--;
++
++  wchan_wakeall(whale_mating->male_wchan);
++  wchan_wakeall(whale_mating->female_wchan);
++  wchan_wakeall(whale_mating->matchmaker_wchan);
++
++	// Implement this function
++  whale_mating->match_found=0;
+   matchmaker_end();
+-  
++  lock_release(whale_mating->lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -133,27 +279,55 @@ matchmaker(void *p, unsigned long which)
+  * functions in drivers.c.
+  */
+ 
++/**
++ * Added by Babu : 27 Feb 2012
++ * Solving Stop light problem with the help
++ * of locks and predefined semaphores.
++ */
++
++
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
+ void stoplight_init() {
+-  return;
++
++	lockquad0 = lock_create("quad0lk");
++	lockquad1 = lock_create("quad1lk");
++	lockquad2 = lock_create("quad2lk");
++	lockquad3 = lock_create("quad3lk");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	lock_destroy(lockquad0);
++	lock_destroy(lockquad1);
++	lock_destroy(lockquad2);
++	lock_destroy(lockquad3);
++	return;
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	kprintf("go straight....\n");
++
++	lock_acquire(getlock(destQuadrant1));
++	lock_acquire(getlock(destQuadrant2));
++
++	inQuadrant(destQuadrant1);
++	inQuadrant(destQuadrant2);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant2));
++	lock_release(getlock(destQuadrant1));
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -163,8 +337,24 @@ gostraight(void *p, unsigned long direction)
+ void
+ turnleft(void *p, unsigned long direction)
+ {
++	kprintf("turn left....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++	unsigned long destQuadrant2 = (direction + 3) % 4;
++	unsigned long destQuadrant3 = (direction + 2) % 4;
++
++	lock_acquire(getlock(destQuadrant1));
++	lock_acquire(getlock(destQuadrant2));
++	lock_acquire(getlock(destQuadrant3));
++
++	inQuadrant(destQuadrant1);
++	inQuadrant(destQuadrant2);
++	inQuadrant(destQuadrant3);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant3));
++	lock_release(getlock(destQuadrant2));
++	lock_release(getlock(destQuadrant1));
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -175,11 +365,91 @@ turnleft(void *p, unsigned long direction)
+ void
+ turnright(void *p, unsigned long direction)
+ {
++	kprintf("turn right....\n");
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
++	unsigned long destQuadrant1 = direction;
++
++	lock_acquire(getlock(destQuadrant1));
++
++	inQuadrant(destQuadrant1);
++	leaveIntersection();
++
++	lock_release(getlock(destQuadrant1));
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+   return;
+ }
++
++/*
++ * Added by Babu
++ * Function which serve as a wrapper to inQuadrant operations
++ * along with synchronization primitive like lock
++ */
++void
++inQuadrantSync(unsigned long destQuadrant)
++{
++	struct lock *lockquad;
++	switch (destQuadrant)
++	{
++		case 0:
++			lockquad = lockquad0;
++			break;
++		case 1:
++			lockquad = lockquad1;
++			break;
++		case 2:
++			lockquad = lockquad2;
++			break;
++		case 3:
++			lockquad = lockquad3;
++			break;
++		default:
++			panic("unknown direction");
++			break;
++	}
++
++	/* If the lock is not held before, then acquire it */
++	if(!lock_do_i_hold(lockquad))
++	{
++		lock_acquire(lockquad);
++		inQuadrant(destQuadrant);
++		lock_release(lockquad);
++	}
++	return;
++}
++
++struct lock *
++getlock(int destQuadrant)
++{
++	struct lock *lockquad;
++	switch (destQuadrant)
++	{
++		case 0:
++			lockquad = lockquad0;
++			break;
++		case 1:
++			lockquad = lockquad1;
++			break;
++		case 2:
++			lockquad = lockquad2;
++			break;
++		case 3:
++			lockquad = lockquad3;
++			break;
++		default:
++			panic("unknown direction");
++			break;
++	}
++
++	/* If the lock is not held before, then acquire it */
++	/*if(lock_do_i_hold(lockquad))
++	{
++		lock_acquire(lockquad);
++		inQuadrant(destQuadrant);
++		lock_release(lockquad);
++	}*/
++	return lockquad;
++
++}
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..83f4d58
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,341 @@
++/*
++ * file_syscalls.c
++ *
++ *  Created on: Mar 8, 2014
++ *      Author: trinity
++ */
++#include <types.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <thread.h>
++#include <syscall.h>
++#include <vfs.h>
++#include <vnode.h>
++#include <fcntl.h>
++#include <current.h>
++#include <synch.h>
++
++#include <uio.h>
++#include <kern/iovec.h>
++#include <seek.h>
++#include <stat.h>
++#include <kern/errno.h>
++
++int
++open(userptr_t filename, int flags,int *err)
++{
++	char *iobuff;
++	int rFlag,vfs_ret;
++	size_t aSize;
++	if (filename == NULL)
++	{
++		*err = EFAULT;
++		 return -1;
++	}
++	int tflags = flags & O_ACCMODE;
++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
++	{
++		kprintf("Failing in arguments\n");
++		*err = EINVAL;
++		return -1;
++	}
++	int i;
++	for ( i=0;i<OPEN_MAX;i++)
++	{
++		if (curthread->ft[i] == NULL)
++		{
++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++			if (curthread->ft[i] == NULL)
++			{
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->lock = lock_create(curthread->t_name);
++			if (curthread->ft[i]->lock == NULL)
++			{
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			curthread->ft[i]->offset=0;
++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++			curthread->ft[i]->status = flags;
++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
++			if (iobuff == NULL)
++			{
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = ENOMEM;
++				return -1;
++			}
++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
++			if(rFlag)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = EFAULT;
++				return -1;
++			}
++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++			if(vfs_ret)
++			{
++				kfree(iobuff);
++				lock_destroy(curthread->ft[i]->lock);
++				kfree(curthread->ft[i]);
++				curthread->ft[i] = NULL;
++				*err = vfs_ret;
++				return -1;
++			}
++			*err = vfs_ret;
++			return i;
++		}
++	}
++	return 0;
++}
++int close(int fd)
++{
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		return EBADF;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		return EBADF;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++	if(curthread->ft[fd]->ref_count == 0)
++	{
++		vfs_close(curthread->ft[fd]->vn);
++		lock_release(curthread->ft[fd]->lock);
++		lock_destroy(curthread->ft[fd]->lock);
++		kfree(curthread->ft[fd]);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	else
++	{
++		lock_release(curthread->ft[fd]->lock);
++		curthread->ft[fd]=NULL;
++		return 0;
++	}
++	return 0;
++}
++
++int
++read(int fd, userptr_t buf, size_t buflen,int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_READ;
++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err = 0;
++	return diff;
++}
++int
++write(int fd, userptr_t buf, size_t buflen, int *err)
++{
++	int ret;
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		return -1;
++	}
++	if (buf == NULL)
++	{
++		*err = EFAULT;
++		return -1;
++	}
++	lock_acquire(curthread->ft[fd]->lock);
++	struct iovec iov;
++	struct uio uio;
++	iov.iov_ubase = buf;
++	iov.iov_len = buflen;
++	uio.uio_iov = &iov;
++	uio.uio_iovcnt = 1;
++	uio.uio_offset = curthread->ft[fd]->offset;
++	uio.uio_resid = buflen;
++	uio.uio_segflg = UIO_USERSPACE;
++	uio.uio_space = curthread->t_addrspace;
++	uio.uio_rw=UIO_WRITE;
++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++	{
++		*err = ret;
++		return -1;
++	}
++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++	curthread->ft[fd]->offset=uio.uio_offset;
++	lock_release(curthread->ft[fd]->lock);
++	*err=0;
++	return diff;
++}
++off_t
++lseek(int fd,off_t pos, int whence,int *err)
++{
++	off_t nPos=0;
++	struct stat eoFILE;
++	//kprintf("lseek entered\n");
++	if (curthread->ft[fd] == NULL)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("curthread->ft[fd] == NULL\n");
++	if ( fd < 0 || fd > OPEN_MAX)
++	{
++		*err = EBADF;
++		 return -1;
++	}
++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
++	{
++		*err = EINVAL;
++		return -1;
++	}
++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
++	//kprintf("Acquiring lock\n");
++	lock_acquire(curthread->ft[fd]->lock);
++	//kprintf("Stat gathering\n");
++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++	if (whence == SEEK_SET)
++	{
++		nPos = pos;
++	}
++	if (whence == SEEK_CUR)
++	{
++		nPos = curthread->ft[fd]->offset+pos;
++	}
++	if (whence == SEEK_END)
++	{
++		nPos = eoFILE.st_size+pos;
++	}
++	if (nPos < 0)
++	{
++		*err = EINVAL;
++		lock_release(curthread->ft[fd]->lock);
++		return -1;
++	}
++	//kprintf("NPos %llu\n",nPos);
++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++	if (*err)
++	{
++		lock_release(curthread->ft[fd]->lock);
++	    return -1;
++	}
++	curthread->ft[fd]->offset = nPos;
++	lock_release(curthread->ft[fd]->lock);
++	//kprintf("New position  %llu\n",nPos);
++	return curthread->ft[fd]->offset;
++}
++int
++dup2(int oldfd, int newfd)
++{
++	int ret;
++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
++		{
++			return -1;
++		}
++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
++		{
++		    return oldfd;
++		}
++		if (curthread->ft[newfd] != NULL)
++		{
++		   ret = close(newfd);
++		   if (ret)
++		      return -1;
++		}
++		curthread->ft[newfd] = curthread->ft[oldfd];
++		lock_acquire(curthread->ft[newfd]->lock);
++		curthread->ft[newfd]->ref_count++;
++		lock_release(curthread->ft[newfd]->lock);
++		return newfd;
++}
++
++int
++chdir(const_userptr_t pathname)
++{
++	char new_path[PATH_MAX];
++	size_t get;
++
++	if (pathname == NULL)
++	{
++		return -1;
++	}
++
++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
++
++	if (ret)
++	{
++		return -1;
++	}
++
++	return vfs_chdir(new_path);
++}
++int
++__getcwd(userptr_t buf, size_t buflen)
++{
++	char path[PATH_MAX];
++	int ret;
++	struct iovec iov;
++	struct uio uio;
++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
++	ret = vfs_getcwd(&uio);
++	if (ret)
++	{
++		return -1;
++	}
++	ret = copyout((userptr_t)path,buf,buflen);
++	if (ret)
++	{
++		return -1;
++	}
++	return uio.uio_offset;
++}
+diff --git a/kern/syscall/process.c b/kern/syscall/process.c
+new file mode 100644
+index 0000000..e1b8b0d
+--- /dev/null
++++ b/kern/syscall/process.c
+@@ -0,0 +1,384 @@
++/*
++ * process.c
++ *
++ *  Created on: Mar 8, 2014
++ *  Author: Babu
++ */
++
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/syscall.h>
++#include <lib.h>
++#include <mips/trapframe.h>
++#include <thread.h>
++#include <current.h>
++#include <syscall.h>
++#include <addrspace.h>
++#include <spl.h>
++#include <synch.h>
++#include <limits.h>
++#include <kern/fcntl.h>
++#include <copyinout.h>
++#include <vfs.h>
++#include <kern/wait.h>
++#include <process.h>
++
++/**
++ * Added by Babu:
++ * Pid pool to maintain the free available pids
++ */
++struct pid_pool
++{
++	pid_t pid_avail; // Available pid
++	struct pid_pool *next; // Point to next available pid
++};
++
++
++// Golbal PID counter
++pid_t global_pid_count = 1;
++
++/* Head and tail pointer for query and insert operation from pool which
++ * follows FIFO approach - Added by Babu
++ */
++struct pid_pool *head = NULL;
++struct pid_pool *tail = NULL;
++
++
++
++/**
++ * When a process exits it should invoke this method so that
++ * this will add the allocated pid to free pool which can be assigned
++ * for other process  - Added by Babu
++ */
++void
++add_pid_to_pool(pid_t pid_free)
++{
++	if(tail == NULL)
++	{
++		tail = kmalloc(sizeof(struct pid_pool));
++		if(tail == NULL)
++			panic("Unable to create pid pool.");
++		else
++			tail->pid_avail = pid_free;
++	}
++	else
++	{
++		tail->next = kmalloc(sizeof(struct pid_pool));
++		if(tail->next == NULL)
++			panic("Unable to create pid pool element.");
++		else
++		{
++			tail = tail->next;
++			tail->pid_avail = pid_free;
++		}
++	}
++	if(head == NULL)
++		head = tail;
++
++}
++
++/**
++ * Allocate pid based on the pids available in the pool or
++ * generate from the counter if the pool is empty  - Added by Babu
++ */
++pid_t
++allocate_pid()
++{
++	pid_t pid_alloc;
++	struct pid_pool *temp;
++	if(head == NULL)
++	{
++		if(global_pid_count < MAX_RUNNING_PROCS)
++			pid_alloc = global_pid_count++;
++		else
++			panic("Maximum number of process reached");
++	}
++	else
++	{
++		pid_alloc = head->pid_avail;
++		temp = head;
++		if(head == tail)
++		{
++			head = NULL;
++			tail = NULL;
++		}
++		else
++			head = head->next;
++		kfree(temp);
++	}
++	return pid_alloc;
++}
++
++/**
++ * Added by Babu : 04/02/2014
++ * Function to destroy process structure
++ */
++void
++process_destroy(struct process *process)
++{
++   //int retval = -1;
++	/* Adding pid to available pool so that it can be allocated to other processes	 */
++	add_pid_to_pool(process->p_pid_self);
++	sem_destroy(process->p_exitsem);
++	processtable[(int)process->p_pid_self] = NULL;
++	kfree(process);
++	return;
++}
++
++/**
++ * Added by Babu on : 04/01/2014
++ * Get pid of the calling process
++ */
++pid_t
++sys_getpid(int32_t *retval)
++{
++	if(curthread != NULL)
++	{
++		if(curthread->t_process != NULL)
++		{
++			memcpy(retval, &curthread->t_process->p_pid_self, sizeof(pid_t));
++			return 0;
++		}
++	}
++	return 1;
++}
++
++/**
++ * Added by Babu on : 04/01/2014
++ * Get pid of the calling process
++ */
++pid_t
++sys_getppid(int32_t *retval)
++{
++	if(curthread != NULL)
++	{
++		if(curthread->t_process != NULL)
++		{
++			retval = &curthread->t_process->p_pid_parent;
++			return 0;
++		}
++	}
++	return 1;
++}
++
++/**
++ * Added by Babu : 04/02/2014warn
++ * Waitpid will wait for the process to change status/destroyed and collect the return status
++ * process which are not collected the return status remain as 'zombies'
++ */
++int
++sys_waitpid(int32_t *retval, pid_t pid, int32_t *exitcode, int32_t flags)
++{
++	struct process *childprocess = processtable[(int)pid];
++	int err = -1;
++
++	if(pid < 1)
++		return EINVAL;
++
++	if(childprocess == NULL)
++		return EINVAL;
++
++    if(exitcode == NULL)
++    	return EFAULT;
++
++    if(exitcode == (void *)0x80000000) // Kernel pointer check
++        return EFAULT;
++
++    if(exitcode == (void *)0x40000000)  // Invalid pointer check
++        return EFAULT;
++
++    // if exitcode alignment is not proper ?
++	if(exitcode == (int32_t *)0x7fffff9d)
++		return EFAULT;
++
++	// if flags are not proper
++	//if(flags != WNOHANG && flags != WUNTRACED)
++	if(flags < 0 || flags > 2)
++		return EINVAL;
++
++	/*if(flags != 0)
++		return EINVAL;*/
++
++	if(childprocess->p_exited)
++	{
++		/*collect the exitstatus and return*/
++		//memcpy(exitcode, &childprocess->p_exitcode, sizeof(int));
++		//memcpy(retval, &childprocess->p_pid_self, sizeof(pid_t));
++		*exitcode =  childprocess->p_exitcode;
++		*retval = childprocess->p_pid_self;
++		process_destroy(childprocess);
++		err = 0;
++	}
++	else
++	{
++		/*else wait on sem until the thread exits then collect exit status and return*/
++		P(childprocess->p_exitsem);
++		//memcpy(exitcode, childprocess->p_exitcode, sizeof(int));
++		//memcpy(retval, childprocess->p_pid_self, sizeof(pid_t));
++		*exitcode = childprocess->p_exitcode;
++		*retval = childprocess->p_pid_self;
++		process_destroy(childprocess);
++		err = 0;
++	}
++	return err;
++}
++
++/**
++ * Added by Babu : 04/02/2014
++ * sysexit will stop the current thread execution and destroy it immediately
++ */
++void
++sys__exit(int exitstatus)
++{
++	if(curthread->t_process != NULL)
++	{
++		if(!curthread->t_process->p_exited)
++		{
++			curthread->t_process->p_exitcode = _MKWAIT_EXIT(exitstatus);
++			curthread->t_process->p_exited = true;
++			/**
++			 *
++			 */
++			/* Free thread structure and destroy all the thread related book keeping stuffs*/
++			//kprintf("thread exited successfully.\n");
++			thread_exit();
++		}
++	}
++
++	return;
++}
++
++/**
++ * Added by Babu on 03/09/2014:
++ *
++ * fork() creates a new process by duplicating the calling process. The new process,
++ * referred to as the child, is an exact duplicate of the calling process, referred
++ * to as the parent.
++ *
++ * return value(retval) 0 for child process and child pid for parent process
++ *
++ */
++int
++sys_fork(int32_t *retval, struct trapframe *tf)
++{
++	struct addrspace *child_addrspce = NULL;
++	struct process *child = NULL;
++//	/int spl = 0;
++	struct process *parent = NULL;
++	struct trapframe *child_trapframe = NULL;
++	int retvalfork = 0;
++	/**
++	 * Create
++	 */
++
++	parent = curthread->t_process;
++	if(parent == NULL)
++		panic("parent process retrieve operation failed");
++
++	parent->p_thread = curthread;
++	//parent_trapframe = tf;
++
++	/*
++	 * Child process creation
++	 */
++	child  = kmalloc(sizeof(struct process));
++	if(child == NULL)
++		panic("Child process creation failed");
++
++	/* Child process struct init */
++	child->p_pid_parent = parent->p_pid_self;
++	child->p_pid_self = allocate_pid();
++	child->p_exited = false;
++	child->p_exitsem = sem_create("p_exitsem", 0);
++
++	/* Assigning in process table */
++	processtable[(int)child->p_pid_self] = child;
++
++	/* create a copy of trapframe using memcpy */
++	child_trapframe = kmalloc(sizeof(struct trapframe));
++	memcpy(child_trapframe, tf, sizeof(struct trapframe));
++
++	/* Addres space and file table cloning from parent */
++	as_copy(parent->p_thread->t_addrspace, &child_addrspce);
++
++	// File table moved to Thread structure
++	/* TODO :file table as array now change it to ptr if possible*/
++	/*for (i = 0; i < MAX_FILE; i++) {
++		child->p_filetable[i] =  parent->p_filetable;
++		child->p_filetable[i].ref_count++;
++
++	}*/
++
++	/* disable interrupts*/
++	//spl  = splhigh();
++
++	/**
++	 * copy parent trapframe to the child process
++	 * and invoke creating child thread
++	 */
++	//tf->tf_a0 = (uint32_t) child_addrspce;
++	retvalfork = thread_fork("child process", child_entrypoint, child_trapframe,(unsigned long) child_addrspce, &child->p_thread);
++	//kprintf("return value of thread_fork : %d\n",retvalfork);
++
++	/*Assigning the process structure to the thread just got created*/
++	child->p_thread->t_process = child;
++
++	/* Return values as child process pid */
++	*retval = child->p_pid_self;
++	//copyout(&child->p_pid_self, (userptr_t) retval, sizeof(child->p_pid_self));
++
++	/* enable interrupts again*/
++	//splx(spl);
++
++	/* Return success or error code  */
++	return retvalfork;
++
++}
++
++/**
++ * Child entry point function which will be invoked
++ * immediately after the child process creation
++ */
++void
++child_entrypoint(void *data1, unsigned long data2)
++{
++	struct trapframe tf_copy;
++	struct trapframe *child_tf = (struct trapframe *) data1;
++	struct addrspace *child_addrspce = (struct addrspace *) data2;
++
++	/*if(child_addrspce == NULL)
++		child_addrspce = (struct addrspace *) child_tf->tf_a0;*/
++
++
++	if(child_addrspce == NULL || child_tf == NULL) /* To indicate failure of child fork */
++	{
++		child_tf->tf_v0 = 15;
++		child_tf->tf_a3 = 1;
++		panic("child entry point failed");
++	}
++	else /* To indicate success of child fork */
++	{
++		child_tf->tf_v0 = 0;
++		child_tf->tf_a3 = 0;
++	}
++
++	/*
++	* Now, advance the program counter, to avoid restarting
++	* the syscall over and over again.
++	*/
++	child_tf->tf_epc += 4;
++
++	/** Loading child's address space into current thread address space */
++	curthread->t_addrspace = child_addrspce;
++	as_activate(curthread->t_addrspace);
++
++	/* Copy modified trap frame*/
++	memcpy(&tf_copy, child_tf, sizeof(struct trapframe));
++
++	/* And enter user mode*/
++	mips_usermode(&tf_copy);
++
++	//kprintf("user mode entered successfully /n");
++
++}
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..7c515d8 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,7 +44,8 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
+-
++#include <synch.h>
++#include <unistd.h>
+ /*
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+@@ -58,7 +59,58 @@ runprogram(char *progname)
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	struct vnode *o, *i, *e;
++	char *con0 = kstrdup("con:");
++	char *con1 = kstrdup("con:");
++	char *con2 = kstrdup("con:");
++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
++	KASSERT(inpTemp!=1);
++	KASSERT(outTemp!=1);
++	KASSERT(errTemp!=1);
++
++	struct fTable *input, *output, *error;
++	input= kmalloc(sizeof(struct fTable));
++	output = kmalloc(sizeof(struct fTable));
++	error = kmalloc(sizeof(struct fTable));
++	KASSERT(input!=NULL);
++	KASSERT(output!=NULL);
++	KASSERT(error!=NULL);
++
++	input->name=kstrdup("Standard_Input");
++	input->offset=0;
++	input->ref_count =0;
++	input->status=O_RDONLY;
++	input->vn=i;
++	input->lock=lock_create("Standard Input");
++
++	output->name=kstrdup("Standard_Output");
++	output->offset=0;
++	output->ref_count =0;
++	output->status=O_WRONLY;
++	output->vn=o;
++	output->lock=lock_create("Standard Output");
++
++	error->name=kstrdup("Standard_Error");
++	error->offset=0;
++	error->ref_count =0;
++	error->status=O_WRONLY;
++	error->vn=e;
++	error->lock=lock_create("Standard Error");
++	KASSERT(input->lock!=NULL);
++	KASSERT(output->lock!=NULL);
++	KASSERT(error->lock!=NULL);
++
++	curthread->ft[STDIN_FILENO]=input;
++	curthread->ft[STDOUT_FILENO]=output;
++	curthread->ft[STDERR_FILENO]=error;
++	kfree(con0);
++	kfree(con1);
++	kfree(con2);
++	//kprintf("IO fd's initialized\n");
+ 	/* Open the file. */
++	kprintf("opening file : %s",progname);
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+ 		return result;
+diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
+index b4dd87c..a8e4ba8 100644
+--- a/kern/test/malloctest.c
++++ b/kern/test/malloctest.c
+@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
+ 	void *oldptr=NULL;
+ 	void *oldptr2=NULL;
+ 	int i;
+-
+ 	for (i=0; i<NTRIES; i++) {
+ 		ptr = kmalloc(ITEMSIZE);
+ 		if (ptr==NULL) {
+diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
+index d072469..f106f4a 100644
+--- a/kern/test/synchtest.c
++++ b/kern/test/synchtest.c
+@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
+ {
+ 	int i;
+ 	(void)junk;
+-
+ 	for (i=0; i<NCVLOOPS; i++) {
+ 		lock_acquire(testlock);
+ 		while (testval1 != num) {
+-      testval2 = 0;
++			testval2 = 0;
++
+ 			cv_wait(testcv, testlock);
+-      testval2 = 0xFFFFFFFF;
++			testval2 = 0xFFFFFFFF;
+ 		}
+ 		testval2 = num;
++
+ 		cv_broadcast(testcv, testlock);
+ 		thread_yield();
+ 		kprintf("Thread %lu\n", testval2);
+ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+ 		lock_release(testlock);
+ 	}
++	kprintf("cv2 test exiting\n");
+ 	V(donesem);
+ }
+ 
+@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
+ 	for (i=0; i<NTHREADS; i++) {
+ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
+ 				      NULL);
++		//kprintf("Thread fork failure\n");
+ 		if (result) {
+ 			panic("cvtest: thread_fork failed: %s\n",
+ 			      strerror(result));
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..624f7a5 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -47,20 +47,20 @@
+ struct semaphore *
+ sem_create(const char *name, int initial_count)
+ {
+-        struct semaphore *sem;
++	struct semaphore *sem;
+ 
+-        KASSERT(initial_count >= 0);
++	KASSERT(initial_count >= 0);
+ 
+-        sem = kmalloc(sizeof(struct semaphore));
+-        if (sem == NULL) {
+-                return NULL;
+-        }
++	sem = kmalloc(sizeof(struct semaphore));
++	if (sem == NULL) {
++			return NULL;
++	}
+ 
+-        sem->sem_name = kstrdup(name);
+-        if (sem->sem_name == NULL) {
+-                kfree(sem);
+-                return NULL;
+-        }
++	sem->sem_name = kstrdup(name);
++	if (sem->sem_name == NULL) {
++			kfree(sem);
++			return NULL;
++	}
+ 
+ 	sem->sem_wchan = wchan_create(sem->sem_name);
+ 	if (sem->sem_wchan == NULL) {
+@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
+ 	}
+ 
+ 	spinlock_init(&sem->sem_lock);
+-        sem->sem_count = initial_count;
++    sem->sem_count = initial_count;
+ 
+-        return sem;
++    return sem;
+ }
+ 
+ void
+@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
+         KASSERT(sem != NULL);
+ 
+ 	/* wchan_cleanup will assert if anyone's waiting on it */
+-	spinlock_cleanup(&sem->sem_lock);
+-	wchan_destroy(sem->sem_wchan);
++		spinlock_cleanup(&sem->sem_lock);
++		wchan_destroy(sem->sem_wchan);
+         kfree(sem->sem_name);
+         kfree(sem);
+ }
+@@ -100,7 +100,7 @@ P(struct semaphore *sem)
+          */
+         KASSERT(curthread->t_in_interrupt == false);
+ 
+-	spinlock_acquire(&sem->sem_lock);
++        spinlock_acquire(&sem->sem_lock);
+         while (sem->sem_count == 0) {
+ 		/*
+ 		 * Bridge to the wchan lock, so if someone else comes
+@@ -120,24 +120,22 @@ P(struct semaphore *sem)
+ 		 */
+ 		wchan_lock(sem->sem_wchan);
+ 		spinlock_release(&sem->sem_lock);
+-                wchan_sleep(sem->sem_wchan);
+-
++        wchan_sleep(sem->sem_wchan);
+ 		spinlock_acquire(&sem->sem_lock);
+-        }
+-        KASSERT(sem->sem_count > 0);
+-        sem->sem_count--;
++	}
++	KASSERT(sem->sem_count > 0);
++	sem->sem_count--;
+ 	spinlock_release(&sem->sem_lock);
+ }
+ 
+ void
+ V(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
+-
+-	spinlock_acquire(&sem->sem_lock);
++    KASSERT(sem != NULL);
++	spinlock_acquire(&sem->sem_lock); 
+ 
+-        sem->sem_count++;
+-        KASSERT(sem->sem_count > 0);
++	sem->sem_count++;
++	KASSERT(sem->sem_count > 0);
+ 	wchan_wakeone(sem->sem_wchan);
+ 
+ 	spinlock_release(&sem->sem_lock);
+@@ -158,20 +156,35 @@ lock_create(const char *name)
+         }
+ 
+         lock->lk_name = kstrdup(name);
++
+         if (lock->lk_name == NULL) {
+                 kfree(lock);
+                 return NULL;
+         }
+-        
++        //added by vasanth
++        lock->lock_owner=NULL;
++        lock->lock_wchan = wchan_create(lock->lk_name);
++		if (lock->lock_wchan == NULL)
++		{
++			kfree(lock->lk_name);
++			kfree(lock);
++			return NULL;
++		}
++		spinlock_init(&lock->spn_lock);
++
+         // add stuff here as needed
+-        
+         return lock;
+ }
+ 
+ void
+ lock_destroy(struct lock *lock)
+ {
++
+         KASSERT(lock != NULL);
++        //added by vasanth
++        //KASSERT(lock->lock_owner == NULL);
++        spinlock_cleanup(&lock->spn_lock);
++        wchan_destroy(lock->lock_wchan);
+ 
+         // add stuff here as needed
+         
+@@ -182,27 +195,64 @@ lock_destroy(struct lock *lock)
+ void
+ lock_acquire(struct lock *lock)
+ {
++		//added by vasanth
++		KASSERT(lock != NULL);
++		if(!lock_do_i_hold(lock))
++		{
++			spinlock_acquire(&lock->spn_lock);
++			while (lock->lock_owner!=NULL)
++			{
++				wchan_lock(lock->lock_wchan);
++				spinlock_release(&lock->spn_lock);
++				wchan_sleep(lock->lock_wchan);
++				spinlock_acquire(&lock->spn_lock);
++			}
++			lock->lock_owner=curthread;
++			spinlock_release(&lock->spn_lock);
++		}
+         // Write this
+ 
+-        (void)lock;  // suppress warning until code gets written
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++		//added by vasanth
++ 		KASSERT(lock != NULL);
++		spinlock_acquire(&lock->spn_lock);
++		if(lock->lock_owner==curthread)
++		{
++			lock->lock_owner=NULL;
++			wchan_wakeall(lock->lock_wchan);
++		}
++		spinlock_release(&lock->spn_lock);
++		// Write this
++
++
++        //(void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++		bool status;
++		spinlock_acquire(&lock->spn_lock);
++		if (lock->lock_owner==curthread)
++		{
++			status = true;
++		}
++		else
++		{
++			status = false;
++		}
++		spinlock_release(&lock->spn_lock);
++		return status;
++
++        //(void)lock;  // suppress warning until code gets written
++
++        //return true; // dummy until code gets written
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -217,26 +267,36 @@ cv_create(const char *name)
+ 
+         cv = kmalloc(sizeof(struct cv));
+         if (cv == NULL) {
+-                return NULL;
++        	return NULL;
+         }
+ 
+         cv->cv_name = kstrdup(name);
+         if (cv->cv_name==NULL) {
+-                kfree(cv);
+-                return NULL;
++            kfree(cv);
++            return NULL;
+         }
+         
+         // add stuff here as needed
++        /* Added by Babu :
++        * Adding a wait channel for making the threads wait during cv_acquire
++        */
++        cv->cv_waitchan = wchan_create(cv->cv_name);
++
+         
+         return cv;
+ }
+ 
++
+ void
+ cv_destroy(struct cv *cv)
+ {
+         KASSERT(cv != NULL);
+ 
+         // add stuff here as needed
++        /*
++         * Added by Babu : wchan destructor
++         */
++        wchan_destroy(cv->cv_waitchan);
+         
+         kfree(cv->cv_name);
+         kfree(cv);
+@@ -245,23 +305,158 @@ cv_destroy(struct cv *cv)
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++    // Write this
++	/** Release lock, wait and then acquire once awake */
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	wchan_lock(cv->cv_waitchan);
++	if(lock_do_i_hold(lock))
++			lock_release(lock);
++	wchan_sleep(cv->cv_waitchan);
++
++	if(!lock_do_i_hold(lock))
++		lock_acquire(lock);
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++    // Write this
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++
++
++	//kprintf("Signaling CV\n");
++
++	wchan_wakeone(cv->cv_waitchan);
++	//wchan_unlock(cv->cv_waitchan);
++
++
++
++	(void) lock;
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv != NULL);
++	KASSERT(lock != NULL);
++
++	wchan_wakeall(cv->cv_waitchan);
++
++	(void) lock;
++}
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rwlock;
++	rwlock = kmalloc(sizeof(struct rwlock));
++	if (rwlock == NULL)
++	{
++		return NULL;
++	}
++	rwlock->rwlock_name=kstrdup(name);
++	if (rwlock->rwlock_name == NULL)
++	{
++	    kfree(rwlock);
++	    return NULL;
++	}
++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->rlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
++	if (rwlock->wlock_wchan == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	rwlock->num_reader=0;
++	rwlock->num_writer=0;
++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
++	if (rwlock->rw_lock == NULL)
++	{
++		kfree(rwlock->rwlock_name);
++		wchan_destroy(rwlock->rlock_wchan);
++		wchan_destroy(rwlock->wlock_wchan);
++		kfree(rwlock);
++		return NULL;
++	}
++	return rwlock;
++
++}
++void
++rwlock_destroy(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_destroy(rwlock->rw_lock);
++	wchan_destroy(rwlock->rlock_wchan);
++	wchan_destroy(rwlock->wlock_wchan);
++	kfree(rwlock->rwlock_name);
++	kfree(rwlock);
++}
++
++void
++rwlock_acquire_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while (rwlock->num_writer>0)
++	{
++		wchan_lock(rwlock->rlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->rlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_reader++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_read(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_reader > 0);
++	lock_acquire(rwlock->rw_lock);
++	if(rwlock->num_reader > 0)
++	{
++		rwlock->num_reader--;
++	}
++	wchan_wakeall(rwlock->wlock_wchan);
++	wchan_wakeall(rwlock->rlock_wchan);
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_acquire_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	lock_acquire(rwlock->rw_lock);
++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
++	{
++		wchan_lock(rwlock->wlock_wchan);
++		lock_release(rwlock->rw_lock);
++		wchan_sleep(rwlock->wlock_wchan);
++		lock_acquire(rwlock->rw_lock);
++	}
++	rwlock->num_writer++;
++	lock_release(rwlock->rw_lock);
++}
++void
++rwlock_release_write(struct rwlock *rwlock)
++{
++	KASSERT(rwlock != NULL);
++	KASSERT(rwlock->num_writer > 0);
++	lock_acquire(rwlock->rw_lock);
++	rwlock->num_writer--;
++	wchan_wakeall(rwlock->rlock_wchan);
++	wchan_wakeall(rwlock->wlock_wchan);
++	lock_release(rwlock->rw_lock);
+ }
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..bdd6e47 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,6 +47,8 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++#include <limits.h>
++#include <process.h>
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+@@ -126,6 +128,13 @@ thread_create(const char *name)
+ 		return NULL;
+ 	}
+ 
++	/**
++	 * Added by Babu :
++	 * Initializing parent process thread
++	 */
++	thread->t_process = kmalloc(sizeof(struct process));
++	if(thread->t_process == NULL)
++		panic("Process creation failed during thread_create");
+ 	thread->t_name = kstrdup(name);
+ 	if (thread->t_name == NULL) {
+ 		kfree(thread);
+@@ -151,8 +160,45 @@ thread_create(const char *name)
+ 
+ 	/* VFS fields */
+ 	thread->t_cwd = NULL;
++	if(pid_sem == NULL)
++		//pid_sem = sem_create("pid_sem",1);
++		pid_sem = lock_create("pid_sem");
++
++	/* To protect from multiple thread generating pid same time - Babu*/
++	lock_acquire(pid_sem);
++	//P(pid_sem);
++	thread->t_process->p_pid_self = allocate_pid();
++	//V(pid_sem);
++	lock_release(pid_sem);
++
++	if( thread->t_process->p_pid_self > 4) /* curr thread is the parent */
++		thread->t_process->p_pid_parent = curthread->t_process->p_pid_self;
++	else /* -1 to denote that this is the init process*/
++		thread->t_process->p_pid_parent = -1;
++
++
++	thread->t_process->p_exitsem = sem_create("p_exitsem", 0);
++	thread->t_process->p_exited = false;
++	thread->t_process->p_thread = thread;
++	DEBUG(DB_THREADS, "Thread created %s", thread->t_name);
++
++	// Adding entry to process table
++	processtable[(int)thread->t_process->p_pid_self] = thread->t_process;
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
++	/*File descriptor*/
++		int i;
++		for (i=0;i<OPEN_MAX;i++)
++		{
++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
++			if (thread->ft[i] == NULL)
++					{
++						kfree(thread);
++						return NULL;
++					}
++			thread->ft[i]=0;
++		}
++		thread->priority = 5;
+ 
+ 	return thread;
+ }
+@@ -262,7 +308,9 @@ thread_destroy(struct thread *thread)
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
+ 
++	DEBUG(DB_THREADS, "%s Thread destroyed.",thread->t_name); 
+ 	kfree(thread->t_name);
++	//if(thread->ft!=NULL)kfree(thread->ft);
+ 	kfree(thread);
+ }
+ 
+@@ -483,7 +531,7 @@ thread_fork(const char *name,
+ 	    struct thread **ret)
+ {
+ 	struct thread *newthread;
+-
++	int i=0;
+ 	newthread = thread_create(name);
+ 	if (newthread == NULL) {
+ 		return ENOMEM;
+@@ -520,7 +568,21 @@ thread_fork(const char *name,
+ 	 */
+ 	newthread->t_iplhigh_count++;
+ 
++	//Might have to add the copy of the file table --vasanth
++	// Yes - Copying file table as part of fork - Babu
++	for (i = 0; i < OPEN_MAX; i++)
++	{
++		newthread->ft[i] = curthread->ft[i];
++		if ( curthread->ft[i] !=0)
++		{
++			//curthread->ft[i]->ref_count++; // Not required as ft is a pointer and both
++										 	 // parent and child point to the same ft
++			newthread->ft[i]->ref_count++;
++		}
++	}
++
+ 	/* Set up the switchframe so entrypoint() gets called */
++
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+ 	/* Lock the current cpu's run queue and make the new thread runnable */
+@@ -574,6 +636,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
++	if ( cur->priority > 0 && cur->priority< 10)
++	{
++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
++	}
+ 
+ 	/* Lock the run queue. */
+ 	spinlock_acquire(&curcpu->c_runqueue_lock);
+@@ -585,6 +652,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 		return;
+ 	}
+ 
++
+ 	/* Put the thread in the right place. */
+ 	switch (newstate) {
+ 	    case S_RUN:
+@@ -618,6 +686,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 	}
+ 	cur->t_state = newstate;
+ 
++
+ 	/*
+ 	 * Get the next thread. While there isn't one, call md_idle().
+ 	 * curcpu->c_isidle must be true when md_idle is
+@@ -791,9 +860,24 @@ void
+ thread_exit(void)
+ {
+ 	struct thread *cur;
++	int i = 0;
+ 
+ 	cur = curthread;
+ 
++	/**
++	 * TODO
++	 * Added by Babu :
++	 * Closing file handles which thread possess
++	 */
++	for (i = 0; i < OPEN_MAX; i++)
++	{
++		if (curthread->ft[i] !=  NULL)
++		{
++			// close file descriptor. Ask vasanth
++		}
++	}
++
++
+ 	/* VFS fields */
+ 	if (cur->t_cwd) {
+ 		VOP_DECREF(cur->t_cwd);
+@@ -818,7 +902,21 @@ thread_exit(void)
+ 	thread_checkstack(cur);
+ 
+ 	/* Interrupts off on this processor */
+-        splhigh();
++    splhigh();
++
++    /* Added by Babu :
++     * return if invalid parent and return if parent already exited
++     * */
++	if(curthread->t_process->p_pid_parent > 0 && processtable[(int)curthread->t_process->p_pid_parent] != NULL)
++	{
++//<<<<<<< HEAD
++		//kprintf("parent might be waiting...");
++//=======
++//		kprintf("parent might be waiting...");
++//>>>>>>> f924a75cb832bb362d6d87c3eb4f71cc8097d5ab
++		V(curthread->t_process->p_exitsem);
++	}
++
+ 	thread_switch(S_ZOMBIE, NULL);
+ 	panic("The zombie walks!\n");
+ }
+@@ -853,6 +951,24 @@ schedule(void)
+ {
+   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
+   // "interactive" threads here.
++	spinlock_acquire(&curcpu->c_runqueue_lock);
++	if (curcpu->c_runqueue.tl_count>1)
++	{
++		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
++		while(tnode->tln_next->tln_next != NULL )
++		{
++			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
++			tnode = tnode->tln_next;
++			int curr_priority = tnode->tln_self->priority;
++			//kprintf("curr_priority %d\n",curr_priority);
++			if ( curr_priority < head_priority)
++			{
++				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
++				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
++			}
++		}
++	}
++	spinlock_release(&curcpu->c_runqueue_lock);
+ }
+ #endif
+ 
+diff --git a/kern/vfs/device.c b/kern/vfs/device.c
+index 5446f7b..0357b2a 100644
+--- a/kern/vfs/device.c
++++ b/kern/vfs/device.c
+@@ -52,6 +52,7 @@ static
+ int
+ dev_open(struct vnode *v, int flags)
+ {
++	DEBUG(DB_VFS, "Calling Device Open...");
+ 	struct device *d = v->vn_data;
+ 
+ 	if (flags & (O_CREAT | O_TRUNC | O_EXCL | O_APPEND)) {
+@@ -69,6 +70,7 @@ static
+ int
+ dev_close(struct vnode *v)
+ {
++	DEBUG(DB_VFS, "Calling Device Close...");
+ 	struct device *d = v->vn_data;
+ 	return d->d_close(d);
+ }
+@@ -81,6 +83,7 @@ static
+ int
+ dev_reclaim(struct vnode *v)
+ {
++	DEBUG(DB_VFS, "Calling Device Reclaim...");
+ 	(void)v;
+ 	/* nothing - device continues to exist even when not in use */
+ 	return 0;
+@@ -93,6 +96,7 @@ static
+ int
+ dev_read(struct vnode *v, struct uio *uio)
+ {
++	DEBUG(DB_VFS, "Calling Device Read...");
+ 	struct device *d = v->vn_data;
+ 	KASSERT(uio->uio_rw == UIO_READ);
+ 	return d->d_io(d, uio);
+diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
+index 09b764b..f8efc2d 100644
+--- a/kern/vm/kmalloc.c
++++ b/kern/vm/kmalloc.c
+@@ -148,9 +148,11 @@ allocpageref(void)
+ 	unsigned i,j;
+ 	uint32_t k;
+ 
++	DEBUG(DB_KMALLOC, "Allocating Page Reference ..... ");
+ 	for (i=0; i<INUSE_WORDS; i++) {
+ 		if (pagerefs_inuse[i]==0xffffffff) {
+ 			/* full */
++			DEBUG(DB_KMALLOC, "Virtual Memory is full. All pages are being used...");
+ 			continue;
+ 		}
+ 		for (k=1,j=0; k!=0; k<<=1,j++) {
+@@ -179,6 +181,7 @@ freepageref(struct pageref *p)
+ 	k = ((uint32_t)1) << (j%32);
+ 	KASSERT((pagerefs_inuse[i] & k) != 0);
+ 	pagerefs_inuse[i] &= ~k;
++	DEBUG(DB_VM, "VM Page references freed ");
+ }
+ 
+ ////////////////////////////////////////
+@@ -218,6 +221,7 @@ checksubpage(struct pageref *pr)
+ 
+ 	KASSERT(spinlock_do_i_hold(&kmalloc_spinlock));
+ 
++	DEBUG(DB_VM, "Checking Sub Pages...");
+ 	if (pr->freelist_offset == INVALID_OFFSET) {
+ 		KASSERT(pr->nfree==0);
+ 		return;
+@@ -226,6 +230,7 @@ checksubpage(struct pageref *pr)
+ 	prpage = PR_PAGEADDR(pr);
+ 	blktype = PR_BLOCKTYPE(pr);
+ 
++	DEBUG(DB_VM,"Free List of VM Pages %u",pr->freelist_offset);
+ 	KASSERT(pr->freelist_offset < PAGE_SIZE);
+ 	KASSERT(pr->freelist_offset % sizes[blktype] == 0);
+ 
+@@ -525,7 +530,6 @@ subpage_kfree(void *ptr)
+ 	spinlock_acquire(&kmalloc_spinlock);
+ 
+ 	checksubpages();
+-
+ 	for (pr = allbase; pr; pr = pr->next_all) {
+ 		prpage = PR_PAGEADDR(pr);
+ 		blktype = PR_BLOCKTYPE(pr);
+diff --git a/mk/os161.config.mk b/mk/os161.config.mk
+index 3de8771..8790d16 100644
+--- a/mk/os161.config.mk
++++ b/mk/os161.config.mk
+@@ -295,7 +295,7 @@
+ #
+ 
+ # Locations of things.
+-OSTREE=$(HOME)/os161/root	# Root directory to install into.
++OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
+ WORKDIR=$(TOP)/build		# Top of tree to build into.
+ BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
+ 
+diff --git a/submit.patch b/submit.patch
+new file mode 100644
+index 0000000..8ffe10c
+--- /dev/null
++++ b/submit.patch
+@@ -0,0 +1,3695 @@
++diff --git a/defs.mk b/defs.mk
++new file mode 100644
++index 0000000..f62cde1
++--- /dev/null
+++++ b/defs.mk
++@@ -0,0 +1,20 @@
+++# This file was generated by configure. Edits will disappear if you rerun
+++# configure. If you find that you need to edit this file to make things
+++# work, let the course staff know and we'll try to fix the configure script.
+++#
+++# The purpose of this file is to hold all the makefile definitions
+++# needed to adjust the OS/161 build process to any particular
+++# environment. If I've done it right, all you need to do is rerun the
+++# configure script and make clean if you start working on a different
+++# host OS. If I've done it mostly right, you may need to edit this
+++# file but you still hopefully won't need to edit any of the
+++# makefiles.
+++#
+++# The things that can be set here are documented in mk/os161.config.mk.
+++#
+++
+++OSTREE=$(HOME)/root-team
+++PLATFORM=sys161
+++MACHINE=mips
+++COMPAT_CFLAGS=
+++COMPAT_TARGETS=
++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
++index 0f773bd..d205710 100644
++--- a/kern/arch/mips/syscall/syscall.c
+++++ b/kern/arch/mips/syscall/syscall.c
++@@ -36,6 +36,8 @@
++ #include <current.h>
++ #include <syscall.h>
++ 
+++#include <endian.h>
+++#include <copyinout.h>
++ 
++ /*
++  * System call dispatcher.
++@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
++ {
++ 	int callno;
++ 	int32_t retval;
+++	uint32_t retval2;
+++	uint64_t ar2,ret;
+++	int whence;
++ 	int err;
++ 
++ 	KASSERT(curthread != NULL);
++@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
++ 		break;
++ 
++ 	    /* Add stuff here */
++- 
+++	    case SYS_open:
+++	    retval = open((userptr_t)tf->tf_a0,
+++	    		(int)tf->tf_a1,&err);
+++	    break;
+++
+++   	    case SYS_close:
+++   	    err = close(tf->tf_a0);
+++        break;
+++
+++        case SYS_read:
+++        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
+++        break;
+++
+++        case SYS_write:
+++        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
+++        		tf->tf_a2,&err);
+++        break;
+++
+++        case SYS_dup2:
+++        err = dup2(tf->tf_a0,tf->tf_a1);
+++        break;
+++
+++        case SYS_lseek:
+++        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
+++        //kprintf("Correct lseek called\n");
+++           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
+++               break;
+++           }
+++        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
+++        //kprintf("ret value %llu\n",ret);
+++        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
+++        //kprintf("Retval %d,%d\n",retval,retval2);
+++        if (!err)
+++        {
+++        tf->tf_v1 = retval2;
+++        }
+++        break;
+++
+++        case SYS_chdir:
+++        err = chdir((const_userptr_t)tf->tf_a0);
+++        break;
+++
+++        case SYS___getcwd:
+++        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
+++        break;
+++
++ 	    default:
++ 		kprintf("Unknown syscall %d\n", callno);
++ 		err = ENOSYS;
++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
++index d527f61..4f9c76f 100644
++--- a/kern/conf/conf.kern
+++++ b/kern/conf/conf.kern
++@@ -367,6 +367,7 @@ file      vfs/devnull.c
++ file      syscall/loadelf.c
++ file      syscall/runprogram.c
++ file      syscall/time_syscalls.c
+++file	  syscall/file_syscalls.c
++ 
++ #
++ # Startup and initialization
++diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
++new file mode 100644
++index 0000000..40e3f6c
++--- /dev/null
+++++ b/kern/include/fcntl.h
++@@ -0,0 +1,100 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_FCNTL_H_
+++#define _KERN_FCNTL_H_
+++
+++/*
+++ * Constants for libc's <fcntl.h>.
+++ */
+++
+++
+++/*
+++ * Important
+++ */
+++
+++/* Flags for open: choose one of these: */
+++#define O_RDONLY      0      /* Open for read */
+++#define O_WRONLY      1      /* Open for write */
+++#define O_RDWR        2      /* Open for read and write */
+++/* then or in any of these: */
+++#define O_CREAT       4      /* Create file if it doesn't exist */
+++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+++#define O_TRUNC      16      /* Truncate file upon open */
+++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
+++
+++/* Additional related definition */
+++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+++
+++/*
+++ * Not so important
+++ */
+++
+++/* operation codes for flock() */
+++#define LOCK_SH         1       /* shared lock */
+++#define LOCK_EX         2       /* exclusive lock */
+++#define LOCK_UN         3       /* release the lock */
+++#define LOCK_NB         4       /* flag: don't block */
+++
+++/*
+++ * Mostly pretty useless
+++ */
+++
+++/* fcntl() operations */
+++#define F_DUPFD         0       /* like dup() but not quite */  
+++#define F_GETFD         1       /* get per-handle flags */
+++#define F_SETFD         2       /* set per-handle flags */
+++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
+++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
+++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
+++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
+++#define F_GETLK         7       /* inspect record locks */
+++#define F_SETLK         8       /* acquire record locks nonblocking */
+++#define F_SETLKW        9       /* acquire record locks and wait */
+++
+++/* flag for F_GETFD and F_SETFD */
+++#define FD_CLOEXEC      1       /* close-on-exec */
+++
+++/* modes for fcntl (F_GETLK/SETLK) locking */
+++#define F_RDLCK         0       /* shared lock */
+++#define F_WRLCK         1       /* exclusive lock */
+++#define F_UNLCK         2       /* unlock */
+++
+++/* struct for fcntl (F_GETLK/SETLK) locking */
+++struct flock {
+++	off_t l_start;          /* place in file */
+++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
+++	int l_type;             /* F_RDLCK or F_WRLCK */
+++	off_t l_len;            /* length of locked region */
+++	pid_t l_pid;            /* process that holds the lock */
+++};
+++
+++
+++#endif /* _KERN_FCNTL_H_ */
++diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
++index 3fad3f2..b2afe55 100644
++--- a/kern/include/kern/limits.h
+++++ b/kern/include/kern/limits.h
++@@ -96,5 +96,7 @@
++ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
++ #define __IOV_MAX       1024
++ 
+++/*Maximum length of file name */
+++
++ 
++ #endif /* _KERN_LIMITS_H_ */
++diff --git a/kern/include/seek.h b/kern/include/seek.h
++new file mode 100644
++index 0000000..cf1cfe6
++--- /dev/null
+++++ b/kern/include/seek.h
++@@ -0,0 +1,47 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_SEEK_H_
+++#define _KERN_SEEK_H_
+++
+++/*
+++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
+++ * <unistd.h> and thus get their own file.
+++ *
+++ * These are pretty important. Back in the day (like 20+ years ago)
+++ * people would often just write the values 0, 1, and 2, but that's
+++ * really not recommended.
+++ */
+++
+++#define SEEK_SET      0      /* Seek relative to beginning of file */
+++#define SEEK_CUR      1      /* Seek relative to current position in file */
+++#define SEEK_END      2      /* Seek relative to end of file */
+++
+++
+++#endif /* _KERN_SEEK_H_ */
++diff --git a/kern/include/synch.h b/kern/include/synch.h
++index ac3714b..35565c6 100644
++--- a/kern/include/synch.h
+++++ b/kern/include/synch.h
++@@ -74,6 +74,10 @@ void V(struct semaphore *);
++  */
++ struct lock {
++         char *lk_name;
+++        //added by vasanth
+++        volatile struct thread *lock_owner;
+++        struct wchan *lock_wchan;
+++        struct spinlock spn_lock;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
++ 
++ struct cv {
++         char *cv_name;
+++        struct wchan *cv_waitchan;
++         // add what you need here
++         // (don't forget to mark things volatile as needed)
++ };
++@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
++ /*
++  * 13 Feb 2012 : GWA : Reader-writer locks.
++  */
++-
+++/* we use two waiting channels one for reader and one for writer we do this so that
+++ *if a writer is waiting all the readers will be put on sleep until the writers are
+++ *done with their writing
+++ */
++ struct rwlock {
++         char *rwlock_name;
+++        volatile int num_reader;
+++        volatile int num_writer;
+++        struct wchan *rlock_wchan;
+++        struct wchan *wlock_wchan;
+++        struct lock *rw_lock;
+++
++ };
++ 
++ struct rwlock * rwlock_create(const char *);
++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
++index befd3d8..6eb477d 100644
++--- a/kern/include/syscall.h
+++++ b/kern/include/syscall.h
++@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
++ 
++ int sys_reboot(int code);
++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
++-
+++int open(userptr_t filename, int flags,int *err);
+++int close(int fd);
+++int read(int fd, userptr_t buf, size_t buflen,int *err);
+++int write(int fd, userptr_t buf, size_t buflen,int *err);
+++int dup2(int oldfd, int newfd);
+++off_t lseek(int fd,off_t pos, int whence, int *err);
+++int chdir(const_userptr_t pathname);
+++int __getcwd(userptr_t buf, size_t buflen);
++ #endif /* _SYSCALL_H_ */
++diff --git a/kern/include/test.h b/kern/include/test.h
++index 240d583..7e24bde 100644
++--- a/kern/include/test.h
+++++ b/kern/include/test.h
++@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
++  * Traffic light.
++  */
++ 
+++//volatile unsigned long intersectionOccupied = 0;
+++
+++/**
+++* Added by Babu:
+++* Locks for each quadrants
+++**/
+++struct lock *lockquad0;
+++struct lock *lockquad1;
+++struct lock *lockquad2;
+++struct lock *lockquad3;
+++
++ void inQuadrant(int);
++ void leaveIntersection(void);
++ int stoplight(int, char **);
++@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
++ void turnright(void *, unsigned long);
++ void stoplight_init(void);
++ void stoplight_cleanup(void);
+++void inQuadrantSync(unsigned long);
++ 
++ /*
++  * Test code.
++diff --git a/kern/include/thread.h b/kern/include/thread.h
++index 86706ca..65e1f08 100644
++--- a/kern/include/thread.h
+++++ b/kern/include/thread.h
++@@ -38,7 +38,7 @@
++ 
++ #include <spinlock.h>
++ #include <threadlist.h>
++-
+++#include <limits.h>
++ struct addrspace;
++ struct cpu;
++ struct vnode;
++@@ -57,6 +57,7 @@ struct vnode;
++ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
++ 
++ 
+++
++ /* States a thread can be in. */
++ typedef enum {
++ 	S_RUN,		/* running */
++@@ -65,6 +66,15 @@ typedef enum {
++ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
++ } threadstate_t;
++ 
+++struct fTable{
+++	    char *name;
+++	    int status;
+++	    off_t offset;
+++	    int ref_count;
+++	    struct lock *lock;
+++	    struct vnode *vn;
+++	};
+++
++ /* Thread structure. */
++ struct thread {
++ 	/*
++@@ -101,6 +111,8 @@ struct thread {
++ 	int t_curspl;			/* Current spl*() state */
++ 	int t_iplhigh_count;		/* # of times IPL has been raised */
++ 
+++
+++
++ 	/*
++ 	 * Public fields
++ 	 */
++@@ -112,8 +124,11 @@ struct thread {
++ 	struct vnode *t_cwd;		/* current working directory */
++ 
++ 	/* add more here as needed */
+++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
+++	int priority;
++ };
++ 
+++
++ /* Call once during system startup to allocate data structures. */
++ void thread_bootstrap(void);
++ 
++diff --git a/kern/include/unistd.h b/kern/include/unistd.h
++new file mode 100644
++index 0000000..30f2678
++--- /dev/null
+++++ b/kern/include/unistd.h
++@@ -0,0 +1,39 @@
+++/*
+++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
+++ *	The President and Fellows of Harvard College.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ * 3. Neither the name of the University nor the names of its contributors
+++ *    may be used to endorse or promote products derived from this software
+++ *    without specific prior written permission.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+++ * SUCH DAMAGE.
+++ */
+++
+++#ifndef _KERN_UNISTD_H_
+++#define _KERN_UNISTD_H_
+++
+++/* Constants for read/write/etc: special file handles */
+++#define STDIN_FILENO  0      /* Standard input */
+++#define STDOUT_FILENO 1      /* Standard output */
+++#define STDERR_FILENO 2      /* Standard error */
+++
+++
+++#endif /* _KERN_UNISTD_H_ */
++diff --git a/kern/startup/main.c b/kern/startup/main.c
++index be4c4b8..969575b 100644
++--- a/kern/startup/main.c
+++++ b/kern/startup/main.c
++@@ -1,3 +1,4 @@
+++/*vsubrama@buffalo.edu*/
++ /*
++  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
++  *	The President and Fellows of Harvard College.
++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
++index 81d2f0e..b1d2a35 100644
++--- a/kern/synchprobs/problems.c
+++++ b/kern/synchprobs/problems.c
++@@ -35,6 +35,7 @@
++ #include <thread.h>
++ #include <test.h>
++ #include <synch.h>
+++#include <wchan.h>
++ 
++ /*
++  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
++@@ -46,8 +47,71 @@
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
++-
+++struct whalemating{
+++	volatile int num_male_whale;
+++	volatile int num_female_whale;
+++	volatile int num_matchmaker_whale;
+++	struct wchan *male_wchan;
+++	struct wchan *female_wchan;
+++	struct wchan *matchmaker_wchan;
+++	struct wchan *match_wchan;
+++	volatile int match_found;
+++	struct lock *lock;
+++};
+++struct whalemating *whale_mating;
++ void whalemating_init() {
+++
+++
+++	whale_mating = kmalloc(sizeof(struct whalemating));
+++	if (whale_mating == NULL)
+++	{
+++		return;
+++	}
+++	whale_mating->male_wchan = wchan_create("name");
+++	if (whale_mating->male_wchan == NULL)
+++	{
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->female_wchan = wchan_create("name");
+++	if (whale_mating->female_wchan == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->matchmaker_wchan = wchan_create("name");
+++	if (whale_mating->matchmaker_wchan == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		wchan_destroy(whale_mating->female_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->match_wchan = wchan_create("name");
+++	if (whale_mating->matchmaker_wchan == NULL)
+++		{
+++			wchan_destroy(whale_mating->male_wchan);
+++			wchan_destroy(whale_mating->female_wchan);
+++			wchan_destroy(whale_mating->match_wchan);
+++			kfree(whale_mating);
+++			return;
+++		}
+++	whale_mating->lock = lock_create("name");
+++	if (whale_mating->lock == NULL)
+++	{
+++		wchan_destroy(whale_mating->male_wchan);
+++		wchan_destroy(whale_mating->female_wchan);
+++		wchan_destroy(whale_mating->matchmaker_wchan);
+++		wchan_destroy(whale_mating->match_wchan);
+++		kfree(whale_mating);
+++		return;
+++	}
+++	whale_mating->num_male_whale = 0;
+++	whale_mating->num_female_whale = 0;
+++	whale_mating->num_matchmaker_whale = 0;
+++	whale_mating->match_found=0;
+++
++   return;
++ }
++ 
++@@ -55,6 +119,12 @@ void whalemating_init() {
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void whalemating_cleanup() {
+++	wchan_destroy(whale_mating->male_wchan);
+++	wchan_destroy(whale_mating->female_wchan);
+++	wchan_destroy(whale_mating->matchmaker_wchan);
+++	wchan_destroy(whale_mating->match_wchan);
+++	lock_destroy(whale_mating->lock);
+++	kfree(whale_mating);
++   return;
++ }
++ 
++@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
++ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
++   (void)which;
++   
++-  male_start();
++-	// Implement this function 
++-  male_end();
+++ male_start();
+++	// Implement this function
+++ lock_acquire(whale_mating->lock);
+++ while(whale_mating->num_male_whale>1)
+++ {
+++   wchan_lock(whale_mating->male_wchan);
+++   lock_release(whale_mating->lock);
+++   wchan_sleep(whale_mating->male_wchan);
+++   lock_acquire(whale_mating->lock);
+++ }
+++ whale_mating->num_male_whale++;
+++ wchan_wakeall(whale_mating->match_wchan);
+++ while(!(whale_mating->match_found==1))
+++ {
+++	 wchan_lock(whale_mating->match_wchan);
+++	 lock_release(whale_mating->lock);
+++	 wchan_sleep(whale_mating->match_wchan);
+++	 lock_acquire(whale_mating->lock);
+++ }
+++ lock_release(whale_mating->lock);
+++ male_end();
+++
++ 
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
++   (void)which;
++   
++   female_start();
++-	// Implement this function 
+++
+++	// Implement this function
+++  lock_acquire(whale_mating->lock);
+++   while(whale_mating->num_female_whale>1)
+++   {
+++     wchan_lock(whale_mating->female_wchan);
+++     lock_release(whale_mating->lock);
+++     wchan_sleep(whale_mating->female_wchan);
+++     lock_acquire(whale_mating->lock);
+++   }
+++   whale_mating->num_female_whale++;
+++   wchan_wakeall(whale_mating->match_wchan);
+++   while(!(whale_mating->match_found==1))
+++   {
+++  	 wchan_lock(whale_mating->match_wchan);
+++  	 lock_release(whale_mating->lock);
+++  	 wchan_sleep(whale_mating->match_wchan);
+++  	 lock_acquire(whale_mating->lock);
+++   }
+++   lock_release(whale_mating->lock);
++   female_end();
++-  
+++
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
++ void
++ matchmaker(void *p, unsigned long which)
++ {
++@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
++   (void)which;
++   
++   matchmaker_start();
++-	// Implement this function 
+++  lock_acquire(whale_mating->lock);
+++  while(whale_mating->num_matchmaker_whale>1)
+++  {
+++     wchan_lock(whale_mating->matchmaker_wchan);
+++     lock_release(whale_mating->lock);
+++     wchan_sleep(whale_mating->matchmaker_wchan);
+++     lock_acquire(whale_mating->lock);
+++  }
+++  whale_mating->num_matchmaker_whale++;
+++  wchan_wakeall(whale_mating->match_wchan);
+++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
+++  {
+++	  wchan_lock(whale_mating->match_wchan);
+++	  lock_release(whale_mating->lock);
+++	  wchan_sleep(whale_mating->match_wchan);
+++	  lock_acquire(whale_mating->lock);
+++  }
+++  whale_mating->match_found=1;
+++  wchan_wakeall(whale_mating->match_wchan);
+++  whale_mating->num_male_whale--;
+++  whale_mating->num_female_whale--;
+++  whale_mating->num_matchmaker_whale--;
+++  whale_mating->match_found=0;
+++  wchan_wakeall(whale_mating->male_wchan);
+++  wchan_wakeall(whale_mating->female_wchan);
+++  wchan_wakeall(whale_mating->matchmaker_wchan);
+++  lock_release(whale_mating->lock);
+++	// Implement this function
++   matchmaker_end();
++-  
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // whalemating driver can return to the menu cleanly.
++   V(whalematingMenuSemaphore);
++   return;
++ }
++ 
+++
++ /*
++  * You should implement your solution to the stoplight problem below. The
++  * quadrant and direction mappings for reference: (although the problem is,
++@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
++  * functions in drivers.c.
++  */
++ 
+++/**
+++ * Added by Babu : 27 Feb 2012
+++ * Solving Stop light problem with the help
+++ * of locks and predefined semaphores.
+++ */
+++
+++
++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
++ // functions will allow you to do local initialization. They are called at
++ // the top of the corresponding driver code.
++ 
++ void stoplight_init() {
++-  return;
+++	lockquad0 = lock_create("quad0lk");
+++	lockquad1 = lock_create("quad1lk");
+++	lockquad2 = lock_create("quad2lk");
+++	lockquad3 = lock_create("quad3lk");
+++	return;
++ }
++ 
++ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
++ // care if your problems leak memory, but if you do, use this to clean up.
++ 
++ void stoplight_cleanup() {
++-  return;
+++	lock_destroy(lockquad0);
+++	lock_destroy(lockquad1);
+++	lock_destroy(lockquad2);
+++	lock_destroy(lockquad3);
+++	return;
++ }
++ 
++ void
++ gostraight(void *p, unsigned long direction)
++ {
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
++-  
+++	unsigned long destQuadrant1 = direction;
+++	unsigned long destQuadrant2 = (direction + 3) % 4;
+++	kprintf("go straight....\n");
+++
+++	inQuadrantSync(destQuadrant1);
+++	inQuadrantSync(destQuadrant2);
+++	leaveIntersection();
+++
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
++ void
++ turnleft(void *p, unsigned long direction)
++ {
+++	kprintf("turn left....\n");
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
+++	unsigned long destQuadrant1 = direction;
+++	unsigned long destQuadrant2 = (direction + 3) % 4;
+++	unsigned long destQuadrant3 = (direction + 2) % 4;
+++
+++	inQuadrantSync(destQuadrant1);
+++	inQuadrantSync(destQuadrant2);
+++	inQuadrantSync(destQuadrant3);
+++	leaveIntersection();
++   
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
++ void
++ turnright(void *p, unsigned long direction)
++ {
+++	kprintf("turn right....\n");
++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
++-  (void)direction;
+++	unsigned long destQuadrant1 = direction;
+++
+++	inQuadrantSync(destQuadrant1);
+++	leaveIntersection();
++ 
++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++   // stoplight driver can return to the menu cleanly.
++   V(stoplightMenuSemaphore);
++   return;
++ }
+++
+++/*
+++ * Added by Babu
+++ * Function which serve as a wrapper to inQuadrant operations
+++ * along with synchronization primitive like lock
+++ */
+++void
+++inQuadrantSync(unsigned long destQuadrant)
+++{
+++	struct lock *lockquad;
+++	switch (destQuadrant)
+++	{
+++		case 0:
+++			lockquad = lockquad0;
+++			break;
+++		case 1:
+++			lockquad = lockquad1;
+++			break;
+++		case 2:
+++			lockquad = lockquad2;
+++			break;
+++		case 3:
+++			lockquad = lockquad3;
+++			break;
+++		default:
+++			panic("unknown direction");
+++			break;
+++	}
+++
+++	/* If the lock is not held before, then acquire it */
+++	if(lock_do_i_hold(lockquad))
+++	{
+++		lock_acquire(lockquad);
+++		inQuadrant(destQuadrant);
+++		kprintf("Releasing lock 0\n");
+++		lock_release(lockquad);
+++	}
+++	return;
+++}
++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
++new file mode 100644
++index 0000000..83f4d58
++--- /dev/null
+++++ b/kern/syscall/file_syscalls.c
++@@ -0,0 +1,341 @@
+++/*
+++ * file_syscalls.c
+++ *
+++ *  Created on: Mar 8, 2014
+++ *      Author: trinity
+++ */
+++#include <types.h>
+++#include <copyinout.h>
+++#include <lib.h>
+++#include <thread.h>
+++#include <syscall.h>
+++#include <vfs.h>
+++#include <vnode.h>
+++#include <fcntl.h>
+++#include <current.h>
+++#include <synch.h>
+++
+++#include <uio.h>
+++#include <kern/iovec.h>
+++#include <seek.h>
+++#include <stat.h>
+++#include <kern/errno.h>
+++
+++int
+++open(userptr_t filename, int flags,int *err)
+++{
+++	char *iobuff;
+++	int rFlag,vfs_ret;
+++	size_t aSize;
+++	if (filename == NULL)
+++	{
+++		*err = EFAULT;
+++		 return -1;
+++	}
+++	int tflags = flags & O_ACCMODE;
+++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
+++	{
+++		kprintf("Failing in arguments\n");
+++		*err = EINVAL;
+++		return -1;
+++	}
+++	int i;
+++	for ( i=0;i<OPEN_MAX;i++)
+++	{
+++		if (curthread->ft[i] == NULL)
+++		{
+++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
+++			if (curthread->ft[i] == NULL)
+++			{
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			curthread->ft[i]->lock = lock_create(curthread->t_name);
+++			if (curthread->ft[i]->lock == NULL)
+++			{
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			curthread->ft[i]->offset=0;
+++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
+++			curthread->ft[i]->status = flags;
+++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
+++			if (iobuff == NULL)
+++			{
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = ENOMEM;
+++				return -1;
+++			}
+++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
+++			if(rFlag)
+++			{
+++				kfree(iobuff);
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = EFAULT;
+++				return -1;
+++			}
+++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
+++			if(vfs_ret)
+++			{
+++				kfree(iobuff);
+++				lock_destroy(curthread->ft[i]->lock);
+++				kfree(curthread->ft[i]);
+++				curthread->ft[i] = NULL;
+++				*err = vfs_ret;
+++				return -1;
+++			}
+++			*err = vfs_ret;
+++			return i;
+++		}
+++	}
+++	return 0;
+++}
+++int close(int fd)
+++{
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		return EBADF;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		return EBADF;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
+++	if(curthread->ft[fd]->ref_count == 0)
+++	{
+++		vfs_close(curthread->ft[fd]->vn);
+++		lock_release(curthread->ft[fd]->lock);
+++		lock_destroy(curthread->ft[fd]->lock);
+++		kfree(curthread->ft[fd]);
+++		curthread->ft[fd]=NULL;
+++		return 0;
+++	}
+++	else
+++	{
+++		lock_release(curthread->ft[fd]->lock);
+++		curthread->ft[fd]=NULL;
+++		return 0;
+++	}
+++	return 0;
+++}
+++
+++int
+++read(int fd, userptr_t buf, size_t buflen,int *err)
+++{
+++	int ret;
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (buf == NULL)
+++	{
+++		*err = EFAULT;
+++		return -1;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	struct iovec iov;
+++	struct uio uio;
+++
+++	iov.iov_ubase = buf;
+++	iov.iov_len = buflen;
+++
+++	uio.uio_iov = &iov;
+++	uio.uio_iovcnt = 1;
+++	uio.uio_offset = curthread->ft[fd]->offset;
+++	uio.uio_resid = buflen;
+++	uio.uio_segflg = UIO_USERSPACE;
+++	uio.uio_space = curthread->t_addrspace;
+++	uio.uio_rw=UIO_READ;
+++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
+++	{
+++		*err = ret;
+++		return -1;
+++	}
+++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
+++	curthread->ft[fd]->offset=uio.uio_offset;
+++	lock_release(curthread->ft[fd]->lock);
+++	*err = 0;
+++	return diff;
+++}
+++int
+++write(int fd, userptr_t buf, size_t buflen, int *err)
+++{
+++	int ret;
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		return -1;
+++	}
+++	if (buf == NULL)
+++	{
+++		*err = EFAULT;
+++		return -1;
+++	}
+++	lock_acquire(curthread->ft[fd]->lock);
+++	struct iovec iov;
+++	struct uio uio;
+++	iov.iov_ubase = buf;
+++	iov.iov_len = buflen;
+++	uio.uio_iov = &iov;
+++	uio.uio_iovcnt = 1;
+++	uio.uio_offset = curthread->ft[fd]->offset;
+++	uio.uio_resid = buflen;
+++	uio.uio_segflg = UIO_USERSPACE;
+++	uio.uio_space = curthread->t_addrspace;
+++	uio.uio_rw=UIO_WRITE;
+++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
+++	{
+++		*err = ret;
+++		return -1;
+++	}
+++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
+++	curthread->ft[fd]->offset=uio.uio_offset;
+++	lock_release(curthread->ft[fd]->lock);
+++	*err=0;
+++	return diff;
+++}
+++off_t
+++lseek(int fd,off_t pos, int whence,int *err)
+++{
+++	off_t nPos=0;
+++	struct stat eoFILE;
+++	//kprintf("lseek entered\n");
+++	if (curthread->ft[fd] == NULL)
+++	{
+++		*err = EBADF;
+++		 return -1;
+++	}
+++	//kprintf("curthread->ft[fd] == NULL\n");
+++	if ( fd < 0 || fd > OPEN_MAX)
+++	{
+++		*err = EBADF;
+++		 return -1;
+++	}
+++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
+++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
+++	{
+++		*err = EINVAL;
+++		return -1;
+++	}
+++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
+++	//kprintf("Acquiring lock\n");
+++	lock_acquire(curthread->ft[fd]->lock);
+++	//kprintf("Stat gathering\n");
+++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
+++	if (whence == SEEK_SET)
+++	{
+++		nPos = pos;
+++	}
+++	if (whence == SEEK_CUR)
+++	{
+++		nPos = curthread->ft[fd]->offset+pos;
+++	}
+++	if (whence == SEEK_END)
+++	{
+++		nPos = eoFILE.st_size+pos;
+++	}
+++	if (nPos < 0)
+++	{
+++		*err = EINVAL;
+++		lock_release(curthread->ft[fd]->lock);
+++		return -1;
+++	}
+++	//kprintf("NPos %llu\n",nPos);
+++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
+++	if (*err)
+++	{
+++		lock_release(curthread->ft[fd]->lock);
+++	    return -1;
+++	}
+++	curthread->ft[fd]->offset = nPos;
+++	lock_release(curthread->ft[fd]->lock);
+++	//kprintf("New position  %llu\n",nPos);
+++	return curthread->ft[fd]->offset;
+++}
+++int
+++dup2(int oldfd, int newfd)
+++{
+++	int ret;
+++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
+++		{
+++			return -1;
+++		}
+++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
+++		{
+++			return -1;
+++		}
+++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
+++		{
+++		    return oldfd;
+++		}
+++		if (curthread->ft[newfd] != NULL)
+++		{
+++		   ret = close(newfd);
+++		   if (ret)
+++		      return -1;
+++		}
+++		curthread->ft[newfd] = curthread->ft[oldfd];
+++		lock_acquire(curthread->ft[newfd]->lock);
+++		curthread->ft[newfd]->ref_count++;
+++		lock_release(curthread->ft[newfd]->lock);
+++		return newfd;
+++}
+++
+++int
+++chdir(const_userptr_t pathname)
+++{
+++	char new_path[PATH_MAX];
+++	size_t get;
+++
+++	if (pathname == NULL)
+++	{
+++		return -1;
+++	}
+++
+++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
+++
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++
+++	return vfs_chdir(new_path);
+++}
+++int
+++__getcwd(userptr_t buf, size_t buflen)
+++{
+++	char path[PATH_MAX];
+++	int ret;
+++	struct iovec iov;
+++	struct uio uio;
+++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
+++	ret = vfs_getcwd(&uio);
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++	ret = copyout((userptr_t)path,buf,buflen);
+++	if (ret)
+++	{
+++		return -1;
+++	}
+++	return uio.uio_offset;
+++}
++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
++index a6f45c8..d18567f 100644
++--- a/kern/syscall/runprogram.c
+++++ b/kern/syscall/runprogram.c
++@@ -44,7 +44,8 @@
++ #include <vfs.h>
++ #include <syscall.h>
++ #include <test.h>
++-
+++#include <synch.h>
+++#include <unistd.h>
++ /*
++  * Load program "progname" and start running it in usermode.
++  * Does not return except on error.
++@@ -58,6 +59,56 @@ runprogram(char *progname)
++ 	vaddr_t entrypoint, stackptr;
++ 	int result;
++ 
+++	struct vnode *o, *i, *e;
+++	char *con0 = kstrdup("con:");
+++	char *con1 = kstrdup("con:");
+++	char *con2 = kstrdup("con:");
+++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
+++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
+++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
+++	KASSERT(inpTemp!=1);
+++	KASSERT(outTemp!=1);
+++	KASSERT(errTemp!=1);
+++
+++	struct fTable *input, *output, *error;
+++	input= kmalloc(sizeof(struct fTable));
+++	output = kmalloc(sizeof(struct fTable));
+++	error = kmalloc(sizeof(struct fTable));
+++	KASSERT(input!=NULL);
+++	KASSERT(output!=NULL);
+++	KASSERT(error!=NULL);
+++
+++	input->name=kstrdup("Standard_Input");
+++	input->offset=0;
+++	input->ref_count =0;
+++	input->status=O_RDONLY;
+++	input->vn=i;
+++	input->lock=lock_create("Standard Input");
+++
+++	output->name=kstrdup("Standard_Output");
+++	output->offset=0;
+++	output->ref_count =0;
+++	output->status=O_WRONLY;
+++	output->vn=o;
+++	output->lock=lock_create("Standard Output");
+++
+++	error->name=kstrdup("Standard_Error");
+++	error->offset=0;
+++	error->ref_count =0;
+++	error->status=O_WRONLY;
+++	error->vn=e;
+++	error->lock=lock_create("Standard Error");
+++	KASSERT(input->lock!=NULL);
+++	KASSERT(output->lock!=NULL);
+++	KASSERT(error->lock!=NULL);
+++
+++	curthread->ft[STDIN_FILENO]=input;
+++	curthread->ft[STDOUT_FILENO]=output;
+++	curthread->ft[STDERR_FILENO]=error;
+++	kfree(con0);
+++	kfree(con1);
+++	kfree(con2);
+++	//kprintf("IO fd's initialized\n");
++ 	/* Open the file. */
++ 	result = vfs_open(progname, O_RDONLY, 0, &v);
++ 	if (result) {
++diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
++index b4dd87c..a8e4ba8 100644
++--- a/kern/test/malloctest.c
+++++ b/kern/test/malloctest.c
++@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
++ 	void *oldptr=NULL;
++ 	void *oldptr2=NULL;
++ 	int i;
++-
++ 	for (i=0; i<NTRIES; i++) {
++ 		ptr = kmalloc(ITEMSIZE);
++ 		if (ptr==NULL) {
++diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
++index d072469..f106f4a 100644
++--- a/kern/test/synchtest.c
+++++ b/kern/test/synchtest.c
++@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
++ {
++ 	int i;
++ 	(void)junk;
++-
++ 	for (i=0; i<NCVLOOPS; i++) {
++ 		lock_acquire(testlock);
++ 		while (testval1 != num) {
++-      testval2 = 0;
+++			testval2 = 0;
+++
++ 			cv_wait(testcv, testlock);
++-      testval2 = 0xFFFFFFFF;
+++			testval2 = 0xFFFFFFFF;
++ 		}
++ 		testval2 = num;
+++
++ 		cv_broadcast(testcv, testlock);
++ 		thread_yield();
++ 		kprintf("Thread %lu\n", testval2);
++ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
++ 		lock_release(testlock);
++ 	}
+++	kprintf("cv2 test exiting\n");
++ 	V(donesem);
++ }
++ 
++@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
++ 	for (i=0; i<NTHREADS; i++) {
++ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
++ 				      NULL);
+++		//kprintf("Thread fork failure\n");
++ 		if (result) {
++ 			panic("cvtest: thread_fork failed: %s\n",
++ 			      strerror(result));
++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
++index 9a7468c..7828129 100644
++--- a/kern/thread/synch.c
+++++ b/kern/thread/synch.c
++@@ -47,20 +47,20 @@
++ struct semaphore *
++ sem_create(const char *name, int initial_count)
++ {
++-        struct semaphore *sem;
+++	struct semaphore *sem;
++ 
++-        KASSERT(initial_count >= 0);
+++	KASSERT(initial_count >= 0);
++ 
++-        sem = kmalloc(sizeof(struct semaphore));
++-        if (sem == NULL) {
++-                return NULL;
++-        }
+++	sem = kmalloc(sizeof(struct semaphore));
+++	if (sem == NULL) {
+++			return NULL;
+++	}
++ 
++-        sem->sem_name = kstrdup(name);
++-        if (sem->sem_name == NULL) {
++-                kfree(sem);
++-                return NULL;
++-        }
+++	sem->sem_name = kstrdup(name);
+++	if (sem->sem_name == NULL) {
+++			kfree(sem);
+++			return NULL;
+++	}
++ 
++ 	sem->sem_wchan = wchan_create(sem->sem_name);
++ 	if (sem->sem_wchan == NULL) {
++@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
++ 	}
++ 
++ 	spinlock_init(&sem->sem_lock);
++-        sem->sem_count = initial_count;
+++    sem->sem_count = initial_count;
++ 
++-        return sem;
+++    return sem;
++ }
++ 
++ void
++@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
++         KASSERT(sem != NULL);
++ 
++ 	/* wchan_cleanup will assert if anyone's waiting on it */
++-	spinlock_cleanup(&sem->sem_lock);
++-	wchan_destroy(sem->sem_wchan);
+++		spinlock_cleanup(&sem->sem_lock);
+++		wchan_destroy(sem->sem_wchan);
++         kfree(sem->sem_name);
++         kfree(sem);
++ }
++@@ -100,7 +100,7 @@ P(struct semaphore *sem)
++          */
++         KASSERT(curthread->t_in_interrupt == false);
++ 
++-	spinlock_acquire(&sem->sem_lock);
+++        spinlock_acquire(&sem->sem_lock);
++         while (sem->sem_count == 0) {
++ 		/*
++ 		 * Bridge to the wchan lock, so if someone else comes
++@@ -120,24 +120,22 @@ P(struct semaphore *sem)
++ 		 */
++ 		wchan_lock(sem->sem_wchan);
++ 		spinlock_release(&sem->sem_lock);
++-                wchan_sleep(sem->sem_wchan);
++-
+++	        wchan_sleep(sem->sem_wchan);
++ 		spinlock_acquire(&sem->sem_lock);
++-        }
++-        KASSERT(sem->sem_count > 0);
++-        sem->sem_count--;
+++	}
+++	KASSERT(sem->sem_count > 0);
+++	sem->sem_count--;
++ 	spinlock_release(&sem->sem_lock);
++ }
++ 
++ void
++ V(struct semaphore *sem)
++ {
++-        KASSERT(sem != NULL);
+++    KASSERT(sem != NULL);
+++	spinlock_acquire(&sem->sem_lock); 
++ 
++-	spinlock_acquire(&sem->sem_lock);
++-
++-        sem->sem_count++;
++-        KASSERT(sem->sem_count > 0);
+++	sem->sem_count++;
+++	KASSERT(sem->sem_count > 0);
++ 	wchan_wakeone(sem->sem_wchan);
++ 
++ 	spinlock_release(&sem->sem_lock);
++@@ -158,20 +156,35 @@ lock_create(const char *name)
++         }
++ 
++         lock->lk_name = kstrdup(name);
+++
++         if (lock->lk_name == NULL) {
++                 kfree(lock);
++                 return NULL;
++         }
++-        
+++        //added by vasanth
+++        lock->lock_owner=NULL;
+++        lock->lock_wchan = wchan_create(lock->lk_name);
+++		if (lock->lock_wchan == NULL)
+++		{
+++			kfree(lock->lk_name);
+++			kfree(lock);
+++			return NULL;
+++		}
+++		spinlock_init(&lock->spn_lock);
+++
++         // add stuff here as needed
++-        
++         return lock;
++ }
++ 
++ void
++ lock_destroy(struct lock *lock)
++ {
+++
++         KASSERT(lock != NULL);
+++        //added by vasanth
+++        //KASSERT(lock->lock_owner == NULL);
+++        spinlock_cleanup(&lock->spn_lock);
+++        wchan_destroy(lock->lock_wchan);
++ 
++         // add stuff here as needed
++         
++@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
++ void
++ lock_acquire(struct lock *lock)
++ {
+++		//added by vasanth
+++		KASSERT(lock != NULL);
+++		spinlock_acquire(&lock->spn_lock);
+++		while (lock->lock_owner!=NULL)
+++		{
+++			wchan_lock(lock->lock_wchan);
+++			spinlock_release(&lock->spn_lock);
+++			wchan_sleep(lock->lock_wchan);
+++			spinlock_acquire(&lock->spn_lock);
+++		}
+++		lock->lock_owner=curthread;
+++		spinlock_release(&lock->spn_lock);
++         // Write this
++ 
++-        (void)lock;  // suppress warning until code gets written
+++       // (void)lock;  // suppress warning until code gets written
++ }
++ 
++ void
++ lock_release(struct lock *lock)
++ {
++-        // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
+++		//added by vasanth
+++ 		KASSERT(lock != NULL);
+++		spinlock_acquire(&lock->spn_lock);
+++		if(lock->lock_owner==curthread)
+++		{
+++			lock->lock_owner=NULL;
+++			wchan_wakeall(lock->lock_wchan);
+++		}
+++		spinlock_release(&lock->spn_lock);
+++		// Write this
+++
+++
+++        //(void)lock;  // suppress warning until code gets written
++ }
++ 
++ bool
++ lock_do_i_hold(struct lock *lock)
++ {
++         // Write this
++-
++-        (void)lock;  // suppress warning until code gets written
++-
++-        return true; // dummy until code gets written
+++	bool status;
+++		spinlock_acquire(&lock->spn_lock);
+++		if (lock->lock_owner==curthread)
+++		{
+++			status = true;
+++		}
+++		else
+++		{
+++			status = false;
+++		}
+++		spinlock_release(&lock->spn_lock);
+++		return status;
+++
+++        //(void)lock;  // suppress warning until code gets written
+++
+++        //return true; // dummy until code gets written
++ }
++ 
++ ////////////////////////////////////////////////////////////
++@@ -217,26 +264,36 @@ cv_create(const char *name)
++ 
++         cv = kmalloc(sizeof(struct cv));
++         if (cv == NULL) {
++-                return NULL;
+++        	return NULL;
++         }
++ 
++         cv->cv_name = kstrdup(name);
++         if (cv->cv_name==NULL) {
++-                kfree(cv);
++-                return NULL;
+++            kfree(cv);
+++            return NULL;
++         }
++         
++         // add stuff here as needed
+++        /* Added by Babu :
+++        * Adding a wait channel for making the threads wait during cv_acquire
+++        */
+++        cv->cv_waitchan = wchan_create(cv->cv_name);
+++
++         
++         return cv;
++ }
++ 
+++
++ void
++ cv_destroy(struct cv *cv)
++ {
++         KASSERT(cv != NULL);
++ 
++         // add stuff here as needed
+++        /*
+++         * Added by Babu : wchan destructor
+++         */
+++        wchan_destroy(cv->cv_waitchan);
++         
++         kfree(cv->cv_name);
++         kfree(cv);
++@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
++ void
++ cv_wait(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-        (void)cv;    // suppress warning until code gets written
++-        (void)lock;  // suppress warning until code gets written
+++    // Write this
+++	/** Release lock, wait and then acquire once awake */
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	//kprintf("Waiting in CV\n");
+++
+++	if(lock_do_i_hold(lock))
+++		lock_release(lock);
+++
+++	//kprintf("Sleeping in CV\n");
+++	wchan_lock(cv->cv_waitchan);
+++	wchan_sleep(cv->cv_waitchan);
+++
+++	//kprintf("Came out of CV\n");
+++
+++	if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);
++ }
++ 
++ void
++ cv_signal(struct cv *cv, struct lock *lock)
++ {
++-        // Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++    // Write this
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++	/*if(lock_do_i_hold(lock))
+++		lock_release(lock);*/
+++
+++	//kprintf("Signaling CV\n");
+++
+++	wchan_wakeone(cv->cv_waitchan);
+++	//wchan_unlock(cv->cv_waitchan);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++	(void) lock;
++ }
++ 
++ void
++ cv_broadcast(struct cv *cv, struct lock *lock)
++ {
++ 	// Write this
++-	(void)cv;    // suppress warning until code gets written
++-	(void)lock;  // suppress warning until code gets written
+++	KASSERT(cv != NULL);
+++	KASSERT(lock != NULL);
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++	/*if(lock_do_i_hold(lock))
+++		lock_release(lock);*/
+++
+++	//kprintf("Broadcasting CV\n");
+++	wchan_wakeall(cv->cv_waitchan);
+++
+++
+++	/*if(!lock_do_i_hold(lock))
+++		lock_acquire(lock);*/
+++
+++
+++	(void) lock;
+++}
+++
+++struct rwlock *
+++rwlock_create(const char *name)
+++{
+++	struct rwlock *rwlock;
+++	rwlock = kmalloc(sizeof(struct rwlock));
+++	if (rwlock == NULL)
+++	{
+++		return NULL;
+++	}
+++	rwlock->rwlock_name=kstrdup(name);
+++	if (rwlock->rwlock_name == NULL)
+++	{
+++	    kfree(rwlock);
+++	    return NULL;
+++	}
+++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
+++	if (rwlock->rlock_wchan == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
+++	if (rwlock->wlock_wchan == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		wchan_destroy(rwlock->rlock_wchan);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	rwlock->num_reader=0;
+++	rwlock->num_writer=0;
+++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
+++	if (rwlock->rw_lock == NULL)
+++	{
+++		kfree(rwlock->rwlock_name);
+++		wchan_destroy(rwlock->rlock_wchan);
+++		wchan_destroy(rwlock->wlock_wchan);
+++		kfree(rwlock);
+++		return NULL;
+++	}
+++	return rwlock;
+++
+++}
+++void
+++rwlock_destroy(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_destroy(rwlock->rw_lock);
+++	wchan_destroy(rwlock->rlock_wchan);
+++	wchan_destroy(rwlock->wlock_wchan);
+++	kfree(rwlock->rwlock_name);
+++	kfree(rwlock);
+++}
+++
+++void
+++rwlock_acquire_read(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_acquire(rwlock->rw_lock);
+++	while (rwlock->num_writer>0)
+++	{
+++		wchan_lock(rwlock->rlock_wchan);
+++		lock_release(rwlock->rw_lock);
+++		wchan_sleep(rwlock->rlock_wchan);
+++		lock_acquire(rwlock->rw_lock);
+++	}
+++	rwlock->num_reader++;
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_release_read(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	KASSERT(rwlock->num_reader > 0);
+++	lock_acquire(rwlock->rw_lock);
+++	if(rwlock->num_reader > 0)
+++	{
+++		rwlock->num_reader--;
+++	}
+++	wchan_wakeall(rwlock->wlock_wchan);
+++	wchan_wakeall(rwlock->rlock_wchan);
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_acquire_write(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	lock_acquire(rwlock->rw_lock);
+++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
+++	{
+++		wchan_lock(rwlock->wlock_wchan);
+++		lock_release(rwlock->rw_lock);
+++		wchan_sleep(rwlock->wlock_wchan);
+++		lock_acquire(rwlock->rw_lock);
+++	}
+++	rwlock->num_writer++;
+++	lock_release(rwlock->rw_lock);
+++}
+++void
+++rwlock_release_write(struct rwlock *rwlock)
+++{
+++	KASSERT(rwlock != NULL);
+++	KASSERT(rwlock->num_writer > 0);
+++	lock_acquire(rwlock->rw_lock);
+++	rwlock->num_writer--;
+++	wchan_wakeall(rwlock->rlock_wchan);
+++	wchan_wakeall(rwlock->wlock_wchan);
+++	lock_release(rwlock->rw_lock);
++ }
++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
++index e7235e3..b1dcc73 100644
++--- a/kern/thread/thread.c
+++++ b/kern/thread/thread.c
++@@ -47,6 +47,7 @@
++ #include <addrspace.h>
++ #include <mainbus.h>
++ #include <vnode.h>
+++#include <limits.h>
++ 
++ #include "opt-synchprobs.h"
++ #include "opt-defaultscheduler.h"
++@@ -153,6 +154,19 @@ thread_create(const char *name)
++ 	thread->t_cwd = NULL;
++ 
++ 	/* If you add to struct thread, be sure to initialize here */
+++	/*File descriptor*/
+++		int i;
+++		for (i=0;i<OPEN_MAX;i++)
+++		{
+++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
+++			if (thread->ft[i] == NULL)
+++					{
+++						kfree(thread);
+++						return NULL;
+++					}
+++			thread->ft[i]=0;
+++		}
+++		thread->priority = 5;
++ 
++ 	return thread;
++ }
++@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
++ 	thread->t_wchan_name = "DESTROYED";
++ 
++ 	kfree(thread->t_name);
+++	//if(thread->ft!=NULL)kfree(thread->ft);
++ 	kfree(thread);
++ }
++ 
++@@ -483,7 +498,6 @@ thread_fork(const char *name,
++ 	    struct thread **ret)
++ {
++ 	struct thread *newthread;
++-
++ 	newthread = thread_create(name);
++ 	if (newthread == NULL) {
++ 		return ENOMEM;
++@@ -520,6 +534,8 @@ thread_fork(const char *name,
++ 	 */
++ 	newthread->t_iplhigh_count++;
++ 
+++	//Might have to add the copy of the file table --vasanth
+++
++ 	/* Set up the switchframe so entrypoint() gets called */
++ 	switchframe_init(newthread, entrypoint, data1, data2);
++ 
++@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 
++ 	/* Check the stack guard band. */
++ 	thread_checkstack(cur);
+++	if ( cur->priority > 0 && cur->priority< 10)
+++	{
+++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
+++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
+++	}
++ 
++ 	/* Lock the run queue. */
++ 	spinlock_acquire(&curcpu->c_runqueue_lock);
++@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 		return;
++ 	}
++ 
+++
++ 	/* Put the thread in the right place. */
++ 	switch (newstate) {
++ 	    case S_RUN:
++@@ -618,6 +640,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
++ 	}
++ 	cur->t_state = newstate;
++ 
+++
++ 	/*
++ 	 * Get the next thread. While there isn't one, call md_idle().
++ 	 * curcpu->c_isidle must be true when md_idle is
++@@ -853,6 +876,24 @@ schedule(void)
++ {
++   // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
++   // "interactive" threads here.
+++	spinlock_acquire(&curcpu->c_runqueue_lock);
+++	if (curcpu->c_runqueue.tl_count>1)
+++	{
+++		struct threadlistnode *tnode = &curcpu->c_runqueue.tl_head;
+++		while(tnode->tln_next->tln_next != NULL )
+++		{
+++			int head_priority =(int) curcpu->c_runqueue.tl_head.tln_next->tln_self->priority;
+++			tnode = tnode->tln_next;
+++			int curr_priority = tnode->tln_self->priority;
+++			//kprintf("curr_priority %d\n",curr_priority);
+++			if ( curr_priority < head_priority)
+++			{
+++				threadlist_remove(&curcpu->c_runqueue,tnode->tln_self);
+++				threadlist_addhead(&curcpu->c_runqueue,tnode->tln_self);
+++			}
+++		}
+++	}
+++	spinlock_release(&curcpu->c_runqueue_lock);
++ }
++ #endif
++ 
++diff --git a/mk/os161.config.mk b/mk/os161.config.mk
++index 3de8771..8790d16 100644
++--- a/mk/os161.config.mk
+++++ b/mk/os161.config.mk
++@@ -295,7 +295,7 @@
++ #
++ 
++ # Locations of things.
++-OSTREE=$(HOME)/os161/root	# Root directory to install into.
+++OSTREE=$(HOME)/os161/root-team	# Root directory to install into.
++ WORKDIR=$(TOP)/build		# Top of tree to build into.
++ BUILDSYMLINKS=yes		# yes => link build -> $(BUILDTOP)/$(HERE).
++ 
++diff --git a/submit.patch b/submit.patch
++new file mode 100644
++index 0000000..45c474b
++--- /dev/null
+++++ b/submit.patch
++@@ -0,0 +1,1815 @@
+++diff --git a/defs.mk b/defs.mk
+++new file mode 100644
+++index 0000000..f62cde1
+++--- /dev/null
++++++ b/defs.mk
+++@@ -0,0 +1,20 @@
++++# This file was generated by configure. Edits will disappear if you rerun
++++# configure. If you find that you need to edit this file to make things
++++# work, let the course staff know and we'll try to fix the configure script.
++++#
++++# The purpose of this file is to hold all the makefile definitions
++++# needed to adjust the OS/161 build process to any particular
++++# environment. If I've done it right, all you need to do is rerun the
++++# configure script and make clean if you start working on a different
++++# host OS. If I've done it mostly right, you may need to edit this
++++# file but you still hopefully won't need to edit any of the
++++# makefiles.
++++#
++++# The things that can be set here are documented in mk/os161.config.mk.
++++#
++++
++++OSTREE=$(HOME)/root-team
++++PLATFORM=sys161
++++MACHINE=mips
++++COMPAT_CFLAGS=
++++COMPAT_TARGETS=
+++diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+++index 0f773bd..d205710 100644
+++--- a/kern/arch/mips/syscall/syscall.c
++++++ b/kern/arch/mips/syscall/syscall.c
+++@@ -36,6 +36,8 @@
+++ #include <current.h>
+++ #include <syscall.h>
+++ 
++++#include <endian.h>
++++#include <copyinout.h>
+++ 
+++ /*
+++  * System call dispatcher.
+++@@ -80,6 +82,9 @@ syscall(struct trapframe *tf)
+++ {
+++ 	int callno;
+++ 	int32_t retval;
++++	uint32_t retval2;
++++	uint64_t ar2,ret;
++++	int whence;
+++ 	int err;
+++ 
+++ 	KASSERT(curthread != NULL);
+++@@ -110,7 +115,52 @@ syscall(struct trapframe *tf)
+++ 		break;
+++ 
+++ 	    /* Add stuff here */
+++- 
++++	    case SYS_open:
++++	    retval = open((userptr_t)tf->tf_a0,
++++	    		(int)tf->tf_a1,&err);
++++	    break;
++++
++++   	    case SYS_close:
++++   	    err = close(tf->tf_a0);
++++        break;
++++
++++        case SYS_read:
++++        retval = read(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&err);
++++        break;
++++
++++        case SYS_write:
++++        retval = write(tf->tf_a0,(userptr_t)tf->tf_a1,
++++        		tf->tf_a2,&err);
++++        break;
++++
++++        case SYS_dup2:
++++        err = dup2(tf->tf_a0,tf->tf_a1);
++++        break;
++++
++++        case SYS_lseek:
++++        join32to64(tf->tf_a2,tf->tf_a3,&ar2);
++++        //kprintf("Correct lseek called\n");
++++           if ((err = copyin((const_userptr_t)(tf->tf_sp+16), &whence, sizeof(whence))) != 0) {
++++               break;
++++           }
++++        ret = lseek((int)tf->tf_a0,ar2,whence,&err);
++++        //kprintf("ret value %llu\n",ret);
++++        split64to32(ret,(uint32_t *)&retval,(uint32_t *)&retval2);
++++        //kprintf("Retval %d,%d\n",retval,retval2);
++++        if (!err)
++++        {
++++        tf->tf_v1 = retval2;
++++        }
++++        break;
++++
++++        case SYS_chdir:
++++        err = chdir((const_userptr_t)tf->tf_a0);
++++        break;
++++
++++        case SYS___getcwd:
++++        err = __getcwd((userptr_t)tf->tf_a0,(size_t)tf->tf_a1);
++++        break;
++++
+++ 	    default:
+++ 		kprintf("Unknown syscall %d\n", callno);
+++ 		err = ENOSYS;
+++diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+++index d527f61..4f9c76f 100644
+++--- a/kern/conf/conf.kern
++++++ b/kern/conf/conf.kern
+++@@ -367,6 +367,7 @@ file      vfs/devnull.c
+++ file      syscall/loadelf.c
+++ file      syscall/runprogram.c
+++ file      syscall/time_syscalls.c
++++file	  syscall/file_syscalls.c
+++ 
+++ #
+++ # Startup and initialization
+++diff --git a/kern/include/fcntl.h b/kern/include/fcntl.h
+++new file mode 100644
+++index 0000000..40e3f6c
+++--- /dev/null
++++++ b/kern/include/fcntl.h
+++@@ -0,0 +1,100 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _KERN_FCNTL_H_
++++#define _KERN_FCNTL_H_
++++
++++/*
++++ * Constants for libc's <fcntl.h>.
++++ */
++++
++++
++++/*
++++ * Important
++++ */
++++
++++/* Flags for open: choose one of these: */
++++#define O_RDONLY      0      /* Open for read */
++++#define O_WRONLY      1      /* Open for write */
++++#define O_RDWR        2      /* Open for read and write */
++++/* then or in any of these: */
++++#define O_CREAT       4      /* Create file if it doesn't exist */
++++#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
++++#define O_TRUNC      16      /* Truncate file upon open */
++++#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
++++#define O_NOCTTY     64      /* Required by POSIX, != 0, but does nothing */
++++
++++/* Additional related definition */
++++#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
++++
++++/*
++++ * Not so important
++++ */
++++
++++/* operation codes for flock() */
++++#define LOCK_SH         1       /* shared lock */
++++#define LOCK_EX         2       /* exclusive lock */
++++#define LOCK_UN         3       /* release the lock */
++++#define LOCK_NB         4       /* flag: don't block */
++++
++++/*
++++ * Mostly pretty useless
++++ */
++++
++++/* fcntl() operations */
++++#define F_DUPFD         0       /* like dup() but not quite */  
++++#define F_GETFD         1       /* get per-handle flags */
++++#define F_SETFD         2       /* set per-handle flags */
++++#define F_GETFL         3       /* get per-file flags (O_* open flags) */
++++#define F_SETFL         4       /* set per-file flags (O_* open flags) */
++++#define F_GETOWN        5       /* get process/pgroup for SIGURG and SIGIO */
++++#define F_SETOWN        6       /* set process/pgroup for SIGURG and SIGIO */
++++#define F_GETLK         7       /* inspect record locks */
++++#define F_SETLK         8       /* acquire record locks nonblocking */
++++#define F_SETLKW        9       /* acquire record locks and wait */
++++
++++/* flag for F_GETFD and F_SETFD */
++++#define FD_CLOEXEC      1       /* close-on-exec */
++++
++++/* modes for fcntl (F_GETLK/SETLK) locking */
++++#define F_RDLCK         0       /* shared lock */
++++#define F_WRLCK         1       /* exclusive lock */
++++#define F_UNLCK         2       /* unlock */
++++
++++/* struct for fcntl (F_GETLK/SETLK) locking */
++++struct flock {
++++	off_t l_start;          /* place in file */
++++	int l_whence;           /* SEEK_SET, SEEK_CUR, or SEEK_END */
++++	int l_type;             /* F_RDLCK or F_WRLCK */
++++	off_t l_len;            /* length of locked region */
++++	pid_t l_pid;            /* process that holds the lock */
++++};
++++
++++
++++#endif /* _KERN_FCNTL_H_ */
+++diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+++index 3fad3f2..b2afe55 100644
+++--- a/kern/include/kern/limits.h
++++++ b/kern/include/kern/limits.h
+++@@ -96,5 +96,7 @@
+++ /* Max number of iovec structures at once for readv/writev/preadv/pwritev */
+++ #define __IOV_MAX       1024
+++ 
++++/*Maximum length of file name */
++++
+++ 
+++ #endif /* _KERN_LIMITS_H_ */
+++diff --git a/kern/include/seek.h b/kern/include/seek.h
+++new file mode 100644
+++index 0000000..cf1cfe6
+++--- /dev/null
++++++ b/kern/include/seek.h
+++@@ -0,0 +1,47 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _KERN_SEEK_H_
++++#define _KERN_SEEK_H_
++++
++++/*
++++ * Codes for lseek(), which are shared in libc between <fcntl.h> and
++++ * <unistd.h> and thus get their own file.
++++ *
++++ * These are pretty important. Back in the day (like 20+ years ago)
++++ * people would often just write the values 0, 1, and 2, but that's
++++ * really not recommended.
++++ */
++++
++++#define SEEK_SET      0      /* Seek relative to beginning of file */
++++#define SEEK_CUR      1      /* Seek relative to current position in file */
++++#define SEEK_END      2      /* Seek relative to end of file */
++++
++++
++++#endif /* _KERN_SEEK_H_ */
+++diff --git a/kern/include/synch.h b/kern/include/synch.h
+++index ac3714b..35565c6 100644
+++--- a/kern/include/synch.h
++++++ b/kern/include/synch.h
+++@@ -74,6 +74,10 @@ void V(struct semaphore *);
+++  */
+++ struct lock {
+++         char *lk_name;
++++        //added by vasanth
++++        volatile struct thread *lock_owner;
++++        struct wchan *lock_wchan;
++++        struct spinlock spn_lock;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+++ 
+++ struct cv {
+++         char *cv_name;
++++        struct wchan *cv_waitchan;
+++         // add what you need here
+++         // (don't forget to mark things volatile as needed)
+++ };
+++@@ -140,9 +145,18 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+++ /*
+++  * 13 Feb 2012 : GWA : Reader-writer locks.
+++  */
+++-
++++/* we use two waiting channels one for reader and one for writer we do this so that
++++ *if a writer is waiting all the readers will be put on sleep until the writers are
++++ *done with their writing
++++ */
+++ struct rwlock {
+++         char *rwlock_name;
++++        volatile int num_reader;
++++        volatile int num_writer;
++++        struct wchan *rlock_wchan;
++++        struct wchan *wlock_wchan;
++++        struct lock *rw_lock;
++++
+++ };
+++ 
+++ struct rwlock * rwlock_create(const char *);
+++diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+++index befd3d8..6eb477d 100644
+++--- a/kern/include/syscall.h
++++++ b/kern/include/syscall.h
+++@@ -57,5 +57,12 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+++ 
+++ int sys_reboot(int code);
+++ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+++-
++++int open(userptr_t filename, int flags,int *err);
++++int close(int fd);
++++int read(int fd, userptr_t buf, size_t buflen,int *err);
++++int write(int fd, userptr_t buf, size_t buflen,int *err);
++++int dup2(int oldfd, int newfd);
++++off_t lseek(int fd,off_t pos, int whence, int *err);
++++int chdir(const_userptr_t pathname);
++++int __getcwd(userptr_t buf, size_t buflen);
+++ #endif /* _SYSCALL_H_ */
+++diff --git a/kern/include/test.h b/kern/include/test.h
+++index 240d583..7e24bde 100644
+++--- a/kern/include/test.h
++++++ b/kern/include/test.h
+++@@ -63,6 +63,17 @@ void whalemating_cleanup(void);
+++  * Traffic light.
+++  */
+++ 
++++//volatile unsigned long intersectionOccupied = 0;
++++
++++/**
++++* Added by Babu:
++++* Locks for each quadrants
++++**/
++++struct lock *lockquad0;
++++struct lock *lockquad1;
++++struct lock *lockquad2;
++++struct lock *lockquad3;
++++
+++ void inQuadrant(int);
+++ void leaveIntersection(void);
+++ int stoplight(int, char **);
+++@@ -72,6 +83,7 @@ void turnleft(void *, unsigned long);
+++ void turnright(void *, unsigned long);
+++ void stoplight_init(void);
+++ void stoplight_cleanup(void);
++++void inQuadrantSync(unsigned long);
+++ 
+++ /*
+++  * Test code.
+++diff --git a/kern/include/thread.h b/kern/include/thread.h
+++index 86706ca..65e1f08 100644
+++--- a/kern/include/thread.h
++++++ b/kern/include/thread.h
+++@@ -38,7 +38,7 @@
+++ 
+++ #include <spinlock.h>
+++ #include <threadlist.h>
+++-
++++#include <limits.h>
+++ struct addrspace;
+++ struct cpu;
+++ struct vnode;
+++@@ -57,6 +57,7 @@ struct vnode;
+++ #define SAME_STACK(p1, p2)     (((p1) & STACK_MASK) == ((p2) & STACK_MASK))
+++ 
+++ 
++++
+++ /* States a thread can be in. */
+++ typedef enum {
+++ 	S_RUN,		/* running */
+++@@ -65,6 +66,15 @@ typedef enum {
+++ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+++ } threadstate_t;
+++ 
++++struct fTable{
++++	    char *name;
++++	    int status;
++++	    off_t offset;
++++	    int ref_count;
++++	    struct lock *lock;
++++	    struct vnode *vn;
++++	};
++++
+++ /* Thread structure. */
+++ struct thread {
+++ 	/*
+++@@ -101,6 +111,8 @@ struct thread {
+++ 	int t_curspl;			/* Current spl*() state */
+++ 	int t_iplhigh_count;		/* # of times IPL has been raised */
+++ 
++++
++++
+++ 	/*
+++ 	 * Public fields
+++ 	 */
+++@@ -112,8 +124,11 @@ struct thread {
+++ 	struct vnode *t_cwd;		/* current working directory */
+++ 
+++ 	/* add more here as needed */
++++	struct fTable *ft[OPEN_MAX];          /*File table pointer*/
++++	int priority;
+++ };
+++ 
++++
+++ /* Call once during system startup to allocate data structures. */
+++ void thread_bootstrap(void);
+++ 
+++diff --git a/kern/include/unistd.h b/kern/include/unistd.h
+++new file mode 100644
+++index 0000000..30f2678
+++--- /dev/null
++++++ b/kern/include/unistd.h
+++@@ -0,0 +1,39 @@
++++/*
++++ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
++++ *	The President and Fellows of Harvard College.
++++ *
++++ * Redistribution and use in source and binary forms, with or without
++++ * modification, are permitted provided that the following conditions
++++ * are met:
++++ * 1. Redistributions of source code must retain the above copyright
++++ *    notice, this list of conditions and the following disclaimer.
++++ * 2. Redistributions in binary form must reproduce the above copyright
++++ *    notice, this list of conditions and the following disclaimer in the
++++ *    documentation and/or other materials provided with the distribution.
++++ * 3. Neither the name of the University nor the names of its contributors
++++ *    may be used to endorse or promote products derived from this software
++++ *    without specific prior written permission.
++++ *
++++ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
++++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
++++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++++ * SUCH DAMAGE.
++++ */
++++
++++#ifndef _KERN_UNISTD_H_
++++#define _KERN_UNISTD_H_
++++
++++/* Constants for read/write/etc: special file handles */
++++#define STDIN_FILENO  0      /* Standard input */
++++#define STDOUT_FILENO 1      /* Standard output */
++++#define STDERR_FILENO 2      /* Standard error */
++++
++++
++++#endif /* _KERN_UNISTD_H_ */
+++diff --git a/kern/startup/main.c b/kern/startup/main.c
+++index be4c4b8..969575b 100644
+++--- a/kern/startup/main.c
++++++ b/kern/startup/main.c
+++@@ -1,3 +1,4 @@
++++/*vsubrama@buffalo.edu*/
+++ /*
+++  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+++  *	The President and Fellows of Harvard College.
+++diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+++index 81d2f0e..b1d2a35 100644
+++--- a/kern/synchprobs/problems.c
++++++ b/kern/synchprobs/problems.c
+++@@ -35,6 +35,7 @@
+++ #include <thread.h>
+++ #include <test.h>
+++ #include <synch.h>
++++#include <wchan.h>
+++ 
+++ /*
+++  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
+++@@ -46,8 +47,71 @@
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
+++-
++++struct whalemating{
++++	volatile int num_male_whale;
++++	volatile int num_female_whale;
++++	volatile int num_matchmaker_whale;
++++	struct wchan *male_wchan;
++++	struct wchan *female_wchan;
++++	struct wchan *matchmaker_wchan;
++++	struct wchan *match_wchan;
++++	volatile int match_found;
++++	struct lock *lock;
++++};
++++struct whalemating *whale_mating;
+++ void whalemating_init() {
++++
++++
++++	whale_mating = kmalloc(sizeof(struct whalemating));
++++	if (whale_mating == NULL)
++++	{
++++		return;
++++	}
++++	whale_mating->male_wchan = wchan_create("name");
++++	if (whale_mating->male_wchan == NULL)
++++	{
++++		kfree(whale_mating);
++++		return;
++++	}
++++	whale_mating->female_wchan = wchan_create("name");
++++	if (whale_mating->female_wchan == NULL)
++++	{
++++		wchan_destroy(whale_mating->male_wchan);
++++		kfree(whale_mating);
++++		return;
++++	}
++++	whale_mating->matchmaker_wchan = wchan_create("name");
++++	if (whale_mating->matchmaker_wchan == NULL)
++++	{
++++		wchan_destroy(whale_mating->male_wchan);
++++		wchan_destroy(whale_mating->female_wchan);
++++		kfree(whale_mating);
++++		return;
++++	}
++++	whale_mating->match_wchan = wchan_create("name");
++++	if (whale_mating->matchmaker_wchan == NULL)
++++		{
++++			wchan_destroy(whale_mating->male_wchan);
++++			wchan_destroy(whale_mating->female_wchan);
++++			wchan_destroy(whale_mating->match_wchan);
++++			kfree(whale_mating);
++++			return;
++++		}
++++	whale_mating->lock = lock_create("name");
++++	if (whale_mating->lock == NULL)
++++	{
++++		wchan_destroy(whale_mating->male_wchan);
++++		wchan_destroy(whale_mating->female_wchan);
++++		wchan_destroy(whale_mating->matchmaker_wchan);
++++		wchan_destroy(whale_mating->match_wchan);
++++		kfree(whale_mating);
++++		return;
++++	}
++++	whale_mating->num_male_whale = 0;
++++	whale_mating->num_female_whale = 0;
++++	whale_mating->num_matchmaker_whale = 0;
++++	whale_mating->match_found=0;
++++
+++   return;
+++ }
+++ 
+++@@ -55,6 +119,12 @@ void whalemating_init() {
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void whalemating_cleanup() {
++++	wchan_destroy(whale_mating->male_wchan);
++++	wchan_destroy(whale_mating->female_wchan);
++++	wchan_destroy(whale_mating->matchmaker_wchan);
++++	wchan_destroy(whale_mating->match_wchan);
++++	lock_destroy(whale_mating->lock);
++++	kfree(whale_mating);
+++   return;
+++ }
+++ 
+++@@ -64,9 +134,28 @@ male(void *p, unsigned long which)
+++ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+++   (void)which;
+++   
+++-  male_start();
+++-	// Implement this function 
+++-  male_end();
++++ male_start();
++++	// Implement this function
++++ lock_acquire(whale_mating->lock);
++++ while(whale_mating->num_male_whale>1)
++++ {
++++   wchan_lock(whale_mating->male_wchan);
++++   lock_release(whale_mating->lock);
++++   wchan_sleep(whale_mating->male_wchan);
++++   lock_acquire(whale_mating->lock);
++++ }
++++ whale_mating->num_male_whale++;
++++ wchan_wakeall(whale_mating->match_wchan);
++++ while(!(whale_mating->match_found==1))
++++ {
++++	 wchan_lock(whale_mating->match_wchan);
++++	 lock_release(whale_mating->lock);
++++	 wchan_sleep(whale_mating->match_wchan);
++++	 lock_acquire(whale_mating->lock);
++++ }
++++ lock_release(whale_mating->lock);
++++ male_end();
++++
+++ 
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++@@ -81,15 +170,36 @@ female(void *p, unsigned long which)
+++   (void)which;
+++   
+++   female_start();
+++-	// Implement this function 
++++
++++	// Implement this function
++++  lock_acquire(whale_mating->lock);
++++   while(whale_mating->num_female_whale>1)
++++   {
++++     wchan_lock(whale_mating->female_wchan);
++++     lock_release(whale_mating->lock);
++++     wchan_sleep(whale_mating->female_wchan);
++++     lock_acquire(whale_mating->lock);
++++   }
++++   whale_mating->num_female_whale++;
++++   wchan_wakeall(whale_mating->match_wchan);
++++   while(!(whale_mating->match_found==1))
++++   {
++++  	 wchan_lock(whale_mating->match_wchan);
++++  	 lock_release(whale_mating->lock);
++++  	 wchan_sleep(whale_mating->match_wchan);
++++  	 lock_acquire(whale_mating->lock);
++++   }
++++   lock_release(whale_mating->lock);
+++   female_end();
+++-  
++++
++++
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
+++ void
+++ matchmaker(void *p, unsigned long which)
+++ {
+++@@ -97,15 +207,43 @@ matchmaker(void *p, unsigned long which)
+++   (void)which;
+++   
+++   matchmaker_start();
+++-	// Implement this function 
++++  lock_acquire(whale_mating->lock);
++++  while(whale_mating->num_matchmaker_whale>1)
++++  {
++++     wchan_lock(whale_mating->matchmaker_wchan);
++++     lock_release(whale_mating->lock);
++++     wchan_sleep(whale_mating->matchmaker_wchan);
++++     lock_acquire(whale_mating->lock);
++++  }
++++  whale_mating->num_matchmaker_whale++;
++++  wchan_wakeall(whale_mating->match_wchan);
++++  while((whale_mating->num_male_whale == 0) || (whale_mating->num_female_whale == 0))
++++  {
++++	  wchan_lock(whale_mating->match_wchan);
++++	  lock_release(whale_mating->lock);
++++	  wchan_sleep(whale_mating->match_wchan);
++++	  lock_acquire(whale_mating->lock);
++++  }
++++  whale_mating->match_found=1;
++++  wchan_wakeall(whale_mating->match_wchan);
++++  whale_mating->num_male_whale--;
++++  whale_mating->num_female_whale--;
++++  whale_mating->num_matchmaker_whale--;
++++  whale_mating->match_found=0;
++++  wchan_wakeall(whale_mating->male_wchan);
++++  wchan_wakeall(whale_mating->female_wchan);
++++  wchan_wakeall(whale_mating->matchmaker_wchan);
++++  lock_release(whale_mating->lock);
++++	// Implement this function
+++   matchmaker_end();
+++-  
++++
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // whalemating driver can return to the menu cleanly.
+++   V(whalematingMenuSemaphore);
+++   return;
+++ }
+++ 
++++
+++ /*
+++  * You should implement your solution to the stoplight problem below. The
+++  * quadrant and direction mappings for reference: (although the problem is,
+++@@ -133,27 +271,48 @@ matchmaker(void *p, unsigned long which)
+++  * functions in drivers.c.
+++  */
+++ 
++++/**
++++ * Added by Babu : 27 Feb 2012
++++ * Solving Stop light problem with the help
++++ * of locks and predefined semaphores.
++++ */
++++
++++
+++ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+++ // functions will allow you to do local initialization. They are called at
+++ // the top of the corresponding driver code.
+++ 
+++ void stoplight_init() {
+++-  return;
++++	lockquad0 = lock_create("quad0lk");
++++	lockquad1 = lock_create("quad1lk");
++++	lockquad2 = lock_create("quad2lk");
++++	lockquad3 = lock_create("quad3lk");
++++	return;
+++ }
+++ 
+++ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+++ // care if your problems leak memory, but if you do, use this to clean up.
+++ 
+++ void stoplight_cleanup() {
+++-  return;
++++	lock_destroy(lockquad0);
++++	lock_destroy(lockquad1);
++++	lock_destroy(lockquad2);
++++	lock_destroy(lockquad3);
++++	return;
+++ }
+++ 
+++ void
+++ gostraight(void *p, unsigned long direction)
+++ {
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
+++-  
++++	unsigned long destQuadrant1 = direction;
++++	unsigned long destQuadrant2 = (direction + 3) % 4;
++++	kprintf("go straight....\n");
++++
++++	inQuadrantSync(destQuadrant1);
++++	inQuadrantSync(destQuadrant2);
++++	leaveIntersection();
++++
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++@@ -163,8 +322,16 @@ gostraight(void *p, unsigned long direction)
+++ void
+++ turnleft(void *p, unsigned long direction)
+++ {
++++	kprintf("turn left....\n");
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
++++	unsigned long destQuadrant1 = direction;
++++	unsigned long destQuadrant2 = (direction + 3) % 4;
++++	unsigned long destQuadrant3 = (direction + 2) % 4;
++++
++++	inQuadrantSync(destQuadrant1);
++++	inQuadrantSync(destQuadrant2);
++++	inQuadrantSync(destQuadrant3);
++++	leaveIntersection();
+++   
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++@@ -175,11 +342,54 @@ turnleft(void *p, unsigned long direction)
+++ void
+++ turnright(void *p, unsigned long direction)
+++ {
++++	kprintf("turn right....\n");
+++ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+++-  (void)direction;
++++	unsigned long destQuadrant1 = direction;
++++
++++	inQuadrantSync(destQuadrant1);
++++	leaveIntersection();
+++ 
+++   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+++   // stoplight driver can return to the menu cleanly.
+++   V(stoplightMenuSemaphore);
+++   return;
+++ }
++++
++++/*
++++ * Added by Babu
++++ * Function which serve as a wrapper to inQuadrant operations
++++ * along with synchronization primitive like lock
++++ */
++++void
++++inQuadrantSync(unsigned long destQuadrant)
++++{
++++	struct lock *lockquad;
++++	switch (destQuadrant)
++++	{
++++		case 0:
++++			lockquad = lockquad0;
++++			break;
++++		case 1:
++++			lockquad = lockquad1;
++++			break;
++++		case 2:
++++			lockquad = lockquad2;
++++			break;
++++		case 3:
++++			lockquad = lockquad3;
++++			break;
++++		default:
++++			panic("unknown direction");
++++			break;
++++	}
++++
++++	/* If the lock is not held before, then acquire it */
++++	if(lock_do_i_hold(lockquad))
++++	{
++++		lock_acquire(lockquad);
++++		inQuadrant(destQuadrant);
++++		kprintf("Releasing lock 0\n");
++++		lock_release(lockquad);
++++	}
++++	return;
++++}
+++diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+++new file mode 100644
+++index 0000000..83f4d58
+++--- /dev/null
++++++ b/kern/syscall/file_syscalls.c
+++@@ -0,0 +1,341 @@
++++/*
++++ * file_syscalls.c
++++ *
++++ *  Created on: Mar 8, 2014
++++ *      Author: trinity
++++ */
++++#include <types.h>
++++#include <copyinout.h>
++++#include <lib.h>
++++#include <thread.h>
++++#include <syscall.h>
++++#include <vfs.h>
++++#include <vnode.h>
++++#include <fcntl.h>
++++#include <current.h>
++++#include <synch.h>
++++
++++#include <uio.h>
++++#include <kern/iovec.h>
++++#include <seek.h>
++++#include <stat.h>
++++#include <kern/errno.h>
++++
++++int
++++open(userptr_t filename, int flags,int *err)
++++{
++++	char *iobuff;
++++	int rFlag,vfs_ret;
++++	size_t aSize;
++++	if (filename == NULL)
++++	{
++++		*err = EFAULT;
++++		 return -1;
++++	}
++++	int tflags = flags & O_ACCMODE;
++++	if ( tflags != O_RDONLY && tflags != O_WRONLY && tflags !=O_RDWR )
++++	{
++++		kprintf("Failing in arguments\n");
++++		*err = EINVAL;
++++		return -1;
++++	}
++++	int i;
++++	for ( i=0;i<OPEN_MAX;i++)
++++	{
++++		if (curthread->ft[i] == NULL)
++++		{
++++			curthread->ft[i] = kmalloc(sizeof(struct fTable));
++++			if (curthread->ft[i] == NULL)
++++			{
++++				*err = ENOMEM;
++++				return -1;
++++			}
++++			curthread->ft[i]->lock = lock_create(curthread->t_name);
++++			if (curthread->ft[i]->lock == NULL)
++++			{
++++				kfree(curthread->ft[i]);
++++				curthread->ft[i] = NULL;
++++				*err = ENOMEM;
++++				return -1;
++++			}
++++			curthread->ft[i]->offset=0;
++++			curthread->ft[i]->ref_count=(curthread->ft[i]->ref_count) + 1;
++++			curthread->ft[i]->status = flags;
++++			iobuff = (char *)kmalloc(PATH_MAX*sizeof(char));
++++			if (iobuff == NULL)
++++			{
++++				lock_destroy(curthread->ft[i]->lock);
++++				kfree(curthread->ft[i]);
++++				curthread->ft[i] = NULL;
++++				*err = ENOMEM;
++++				return -1;
++++			}
++++			rFlag = copyinstr((const_userptr_t)filename,iobuff,PATH_MAX,&aSize);
++++			if(rFlag)
++++			{
++++				kfree(iobuff);
++++				lock_destroy(curthread->ft[i]->lock);
++++				kfree(curthread->ft[i]);
++++				curthread->ft[i] = NULL;
++++				*err = EFAULT;
++++				return -1;
++++			}
++++			vfs_ret=vfs_open((char *)filename,flags,0664,&(curthread->ft[i]->vn));
++++			if(vfs_ret)
++++			{
++++				kfree(iobuff);
++++				lock_destroy(curthread->ft[i]->lock);
++++				kfree(curthread->ft[i]);
++++				curthread->ft[i] = NULL;
++++				*err = vfs_ret;
++++				return -1;
++++			}
++++			*err = vfs_ret;
++++			return i;
++++		}
++++	}
++++	return 0;
++++}
++++int close(int fd)
++++{
++++	if ( fd < 0 || fd > OPEN_MAX)
++++	{
++++		return EBADF;
++++	}
++++	if (curthread->ft[fd] == NULL)
++++	{
++++		return EBADF;
++++	}
++++	lock_acquire(curthread->ft[fd]->lock);
++++	curthread->ft[fd]->ref_count=(curthread->ft[fd]->ref_count)-1;
++++	if(curthread->ft[fd]->ref_count == 0)
++++	{
++++		vfs_close(curthread->ft[fd]->vn);
++++		lock_release(curthread->ft[fd]->lock);
++++		lock_destroy(curthread->ft[fd]->lock);
++++		kfree(curthread->ft[fd]);
++++		curthread->ft[fd]=NULL;
++++		return 0;
++++	}
++++	else
++++	{
++++		lock_release(curthread->ft[fd]->lock);
++++		curthread->ft[fd]=NULL;
++++		return 0;
++++	}
++++	return 0;
++++}
++++
++++int
++++read(int fd, userptr_t buf, size_t buflen,int *err)
++++{
++++	int ret;
++++	if ( fd < 0 || fd > OPEN_MAX)
++++	{
++++		*err = EBADF;
++++		return -1;
++++	}
++++	if (curthread->ft[fd] == NULL)
++++	{
++++		*err = EBADF;
++++		return -1;
++++	}
++++	if (buf == NULL)
++++	{
++++		*err = EFAULT;
++++		return -1;
++++	}
++++	lock_acquire(curthread->ft[fd]->lock);
++++	struct iovec iov;
++++	struct uio uio;
++++
++++	iov.iov_ubase = buf;
++++	iov.iov_len = buflen;
++++
++++	uio.uio_iov = &iov;
++++	uio.uio_iovcnt = 1;
++++	uio.uio_offset = curthread->ft[fd]->offset;
++++	uio.uio_resid = buflen;
++++	uio.uio_segflg = UIO_USERSPACE;
++++	uio.uio_space = curthread->t_addrspace;
++++	uio.uio_rw=UIO_READ;
++++	if((ret = VOP_READ(curthread->ft[fd]->vn,&uio))!=0)
++++	{
++++		*err = ret;
++++		return -1;
++++	}
++++	int diff = uio.uio_offset - curthread->ft[fd]->offset;
++++	curthread->ft[fd]->offset=uio.uio_offset;
++++	lock_release(curthread->ft[fd]->lock);
++++	*err = 0;
++++	return diff;
++++}
++++int
++++write(int fd, userptr_t buf, size_t buflen, int *err)
++++{
++++	int ret;
++++	if ( fd < 0 || fd > OPEN_MAX)
++++	{
++++		*err = EBADF;
++++		return -1;
++++	}
++++	if (curthread->ft[fd] == NULL)
++++	{
++++		*err = EBADF;
++++		return -1;
++++	}
++++	if (buf == NULL)
++++	{
++++		*err = EFAULT;
++++		return -1;
++++	}
++++	lock_acquire(curthread->ft[fd]->lock);
++++	struct iovec iov;
++++	struct uio uio;
++++	iov.iov_ubase = buf;
++++	iov.iov_len = buflen;
++++	uio.uio_iov = &iov;
++++	uio.uio_iovcnt = 1;
++++	uio.uio_offset = curthread->ft[fd]->offset;
++++	uio.uio_resid = buflen;
++++	uio.uio_segflg = UIO_USERSPACE;
++++	uio.uio_space = curthread->t_addrspace;
++++	uio.uio_rw=UIO_WRITE;
++++	if((ret = VOP_WRITE(curthread->ft[fd]->vn,&uio))!=0)
++++	{
++++		*err = ret;
++++		return -1;
++++	}
++++	int diff = uio.uio_offset - curthread->ft[fd]->offset ;
++++	curthread->ft[fd]->offset=uio.uio_offset;
++++	lock_release(curthread->ft[fd]->lock);
++++	*err=0;
++++	return diff;
++++}
++++off_t
++++lseek(int fd,off_t pos, int whence,int *err)
++++{
++++	off_t nPos=0;
++++	struct stat eoFILE;
++++	//kprintf("lseek entered\n");
++++	if (curthread->ft[fd] == NULL)
++++	{
++++		*err = EBADF;
++++		 return -1;
++++	}
++++	//kprintf("curthread->ft[fd] == NULL\n");
++++	if ( fd < 0 || fd > OPEN_MAX)
++++	{
++++		*err = EBADF;
++++		 return -1;
++++	}
++++	//kprintf("fd < 0 || fd > OPEN_MAX\n");
++++	if (whence != SEEK_SET && whence != SEEK_CUR && whence != SEEK_END)
++++	{
++++		*err = EINVAL;
++++		return -1;
++++	}
++++	//kprintf("whence != SEEK_SET || whence != SEEK_CUR || whence != SEEK_END\n");
++++	//kprintf("Acquiring lock\n");
++++	lock_acquire(curthread->ft[fd]->lock);
++++	//kprintf("Stat gathering\n");
++++	VOP_STAT(curthread->ft[fd]->vn,&eoFILE);
++++	if (whence == SEEK_SET)
++++	{
++++		nPos = pos;
++++	}
++++	if (whence == SEEK_CUR)
++++	{
++++		nPos = curthread->ft[fd]->offset+pos;
++++	}
++++	if (whence == SEEK_END)
++++	{
++++		nPos = eoFILE.st_size+pos;
++++	}
++++	if (nPos < 0)
++++	{
++++		*err = EINVAL;
++++		lock_release(curthread->ft[fd]->lock);
++++		return -1;
++++	}
++++	//kprintf("NPos %llu\n",nPos);
++++	*err = VOP_TRYSEEK(curthread->ft[fd]->vn,nPos);
++++	if (*err)
++++	{
++++		lock_release(curthread->ft[fd]->lock);
++++	    return -1;
++++	}
++++	curthread->ft[fd]->offset = nPos;
++++	lock_release(curthread->ft[fd]->lock);
++++	//kprintf("New position  %llu\n",nPos);
++++	return curthread->ft[fd]->offset;
++++}
++++int
++++dup2(int oldfd, int newfd)
++++{
++++	int ret;
++++		if ( oldfd < 0 || oldfd > OPEN_MAX || newfd < 0 || newfd > OPEN_MAX)
++++		{
++++			return -1;
++++		}
++++		if (curthread->ft[oldfd] == NULL || curthread->ft[newfd] == NULL)
++++		{
++++			return -1;
++++		}
++++		if (curthread->ft[oldfd] == curthread->ft[newfd] || oldfd == newfd)
++++		{
++++		    return oldfd;
++++		}
++++		if (curthread->ft[newfd] != NULL)
++++		{
++++		   ret = close(newfd);
++++		   if (ret)
++++		      return -1;
++++		}
++++		curthread->ft[newfd] = curthread->ft[oldfd];
++++		lock_acquire(curthread->ft[newfd]->lock);
++++		curthread->ft[newfd]->ref_count++;
++++		lock_release(curthread->ft[newfd]->lock);
++++		return newfd;
++++}
++++
++++int
++++chdir(const_userptr_t pathname)
++++{
++++	char new_path[PATH_MAX];
++++	size_t get;
++++
++++	if (pathname == NULL)
++++	{
++++		return -1;
++++	}
++++
++++	int ret = copyinstr(pathname,new_path,PATH_MAX,&get);
++++
++++	if (ret)
++++	{
++++		return -1;
++++	}
++++
++++	return vfs_chdir(new_path);
++++}
++++int
++++__getcwd(userptr_t buf, size_t buflen)
++++{
++++	char path[PATH_MAX];
++++	int ret;
++++	struct iovec iov;
++++	struct uio uio;
++++	uio_kinit(&iov,&uio,path,PATH_MAX,0,UIO_READ);
++++	ret = vfs_getcwd(&uio);
++++	if (ret)
++++	{
++++		return -1;
++++	}
++++	ret = copyout((userptr_t)path,buf,buflen);
++++	if (ret)
++++	{
++++		return -1;
++++	}
++++	return uio.uio_offset;
++++}
+++diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+++index a6f45c8..d18567f 100644
+++--- a/kern/syscall/runprogram.c
++++++ b/kern/syscall/runprogram.c
+++@@ -44,7 +44,8 @@
+++ #include <vfs.h>
+++ #include <syscall.h>
+++ #include <test.h>
+++-
++++#include <synch.h>
++++#include <unistd.h>
+++ /*
+++  * Load program "progname" and start running it in usermode.
+++  * Does not return except on error.
+++@@ -58,6 +59,56 @@ runprogram(char *progname)
+++ 	vaddr_t entrypoint, stackptr;
+++ 	int result;
+++ 
++++	struct vnode *o, *i, *e;
++++	char *con0 = kstrdup("con:");
++++	char *con1 = kstrdup("con:");
++++	char *con2 = kstrdup("con:");
++++	int inpTemp = vfs_open(con0,O_RDONLY,0664,&i);
++++	int outTemp = vfs_open(con1,O_WRONLY,0664,&o);
++++	int errTemp = vfs_open(con2,O_WRONLY,0664,&e);
++++	KASSERT(inpTemp!=1);
++++	KASSERT(outTemp!=1);
++++	KASSERT(errTemp!=1);
++++
++++	struct fTable *input, *output, *error;
++++	input= kmalloc(sizeof(struct fTable));
++++	output = kmalloc(sizeof(struct fTable));
++++	error = kmalloc(sizeof(struct fTable));
++++	KASSERT(input!=NULL);
++++	KASSERT(output!=NULL);
++++	KASSERT(error!=NULL);
++++
++++	input->name=kstrdup("Standard_Input");
++++	input->offset=0;
++++	input->ref_count =0;
++++	input->status=O_RDONLY;
++++	input->vn=i;
++++	input->lock=lock_create("Standard Input");
++++
++++	output->name=kstrdup("Standard_Output");
++++	output->offset=0;
++++	output->ref_count =0;
++++	output->status=O_WRONLY;
++++	output->vn=o;
++++	output->lock=lock_create("Standard Output");
++++
++++	error->name=kstrdup("Standard_Error");
++++	error->offset=0;
++++	error->ref_count =0;
++++	error->status=O_WRONLY;
++++	error->vn=e;
++++	error->lock=lock_create("Standard Error");
++++	KASSERT(input->lock!=NULL);
++++	KASSERT(output->lock!=NULL);
++++	KASSERT(error->lock!=NULL);
++++
++++	curthread->ft[STDIN_FILENO]=input;
++++	curthread->ft[STDOUT_FILENO]=output;
++++	curthread->ft[STDERR_FILENO]=error;
++++	kfree(con0);
++++	kfree(con1);
++++	kfree(con2);
++++	//kprintf("IO fd's initialized\n");
+++ 	/* Open the file. */
+++ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+++ 	if (result) {
+++diff --git a/kern/test/malloctest.c b/kern/test/malloctest.c
+++index b4dd87c..a8e4ba8 100644
+++--- a/kern/test/malloctest.c
++++++ b/kern/test/malloctest.c
+++@@ -60,7 +60,6 @@ mallocthread(void *sm, unsigned long num)
+++ 	void *oldptr=NULL;
+++ 	void *oldptr2=NULL;
+++ 	int i;
+++-
+++ 	for (i=0; i<NTRIES; i++) {
+++ 		ptr = kmalloc(ITEMSIZE);
+++ 		if (ptr==NULL) {
+++diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
+++index d072469..f106f4a 100644
+++--- a/kern/test/synchtest.c
++++++ b/kern/test/synchtest.c
+++@@ -309,21 +309,23 @@ cvtest2thread(void *junk, unsigned long num)
+++ {
+++ 	int i;
+++ 	(void)junk;
+++-
+++ 	for (i=0; i<NCVLOOPS; i++) {
+++ 		lock_acquire(testlock);
+++ 		while (testval1 != num) {
+++-      testval2 = 0;
++++			testval2 = 0;
++++
+++ 			cv_wait(testcv, testlock);
+++-      testval2 = 0xFFFFFFFF;
++++			testval2 = 0xFFFFFFFF;
+++ 		}
+++ 		testval2 = num;
++++
+++ 		cv_broadcast(testcv, testlock);
+++ 		thread_yield();
+++ 		kprintf("Thread %lu\n", testval2);
+++ 		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+++ 		lock_release(testlock);
+++ 	}
++++	kprintf("cv2 test exiting\n");
+++ 	V(donesem);
+++ }
+++ 
+++@@ -344,6 +346,7 @@ cvtest2(int nargs, char **args)
+++ 	for (i=0; i<NTHREADS; i++) {
+++ 		result = thread_fork("synchtest", cvtest2thread, NULL, i,
+++ 				      NULL);
++++		//kprintf("Thread fork failure\n");
+++ 		if (result) {
+++ 			panic("cvtest: thread_fork failed: %s\n",
+++ 			      strerror(result));
+++diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+++index 9a7468c..7828129 100644
+++--- a/kern/thread/synch.c
++++++ b/kern/thread/synch.c
+++@@ -47,20 +47,20 @@
+++ struct semaphore *
+++ sem_create(const char *name, int initial_count)
+++ {
+++-        struct semaphore *sem;
++++	struct semaphore *sem;
+++ 
+++-        KASSERT(initial_count >= 0);
++++	KASSERT(initial_count >= 0);
+++ 
+++-        sem = kmalloc(sizeof(struct semaphore));
+++-        if (sem == NULL) {
+++-                return NULL;
+++-        }
++++	sem = kmalloc(sizeof(struct semaphore));
++++	if (sem == NULL) {
++++			return NULL;
++++	}
+++ 
+++-        sem->sem_name = kstrdup(name);
+++-        if (sem->sem_name == NULL) {
+++-                kfree(sem);
+++-                return NULL;
+++-        }
++++	sem->sem_name = kstrdup(name);
++++	if (sem->sem_name == NULL) {
++++			kfree(sem);
++++			return NULL;
++++	}
+++ 
+++ 	sem->sem_wchan = wchan_create(sem->sem_name);
+++ 	if (sem->sem_wchan == NULL) {
+++@@ -70,9 +70,9 @@ sem_create(const char *name, int initial_count)
+++ 	}
+++ 
+++ 	spinlock_init(&sem->sem_lock);
+++-        sem->sem_count = initial_count;
++++    sem->sem_count = initial_count;
+++ 
+++-        return sem;
++++    return sem;
+++ }
+++ 
+++ void
+++@@ -81,8 +81,8 @@ sem_destroy(struct semaphore *sem)
+++         KASSERT(sem != NULL);
+++ 
+++ 	/* wchan_cleanup will assert if anyone's waiting on it */
+++-	spinlock_cleanup(&sem->sem_lock);
+++-	wchan_destroy(sem->sem_wchan);
++++		spinlock_cleanup(&sem->sem_lock);
++++		wchan_destroy(sem->sem_wchan);
+++         kfree(sem->sem_name);
+++         kfree(sem);
+++ }
+++@@ -100,7 +100,7 @@ P(struct semaphore *sem)
+++          */
+++         KASSERT(curthread->t_in_interrupt == false);
+++ 
+++-	spinlock_acquire(&sem->sem_lock);
++++        spinlock_acquire(&sem->sem_lock);
+++         while (sem->sem_count == 0) {
+++ 		/*
+++ 		 * Bridge to the wchan lock, so if someone else comes
+++@@ -120,24 +120,22 @@ P(struct semaphore *sem)
+++ 		 */
+++ 		wchan_lock(sem->sem_wchan);
+++ 		spinlock_release(&sem->sem_lock);
+++-                wchan_sleep(sem->sem_wchan);
+++-
++++	        wchan_sleep(sem->sem_wchan);
+++ 		spinlock_acquire(&sem->sem_lock);
+++-        }
+++-        KASSERT(sem->sem_count > 0);
+++-        sem->sem_count--;
++++	}
++++	KASSERT(sem->sem_count > 0);
++++	sem->sem_count--;
+++ 	spinlock_release(&sem->sem_lock);
+++ }
+++ 
+++ void
+++ V(struct semaphore *sem)
+++ {
+++-        KASSERT(sem != NULL);
++++    KASSERT(sem != NULL);
++++	spinlock_acquire(&sem->sem_lock); 
+++ 
+++-	spinlock_acquire(&sem->sem_lock);
+++-
+++-        sem->sem_count++;
+++-        KASSERT(sem->sem_count > 0);
++++	sem->sem_count++;
++++	KASSERT(sem->sem_count > 0);
+++ 	wchan_wakeone(sem->sem_wchan);
+++ 
+++ 	spinlock_release(&sem->sem_lock);
+++@@ -158,20 +156,35 @@ lock_create(const char *name)
+++         }
+++ 
+++         lock->lk_name = kstrdup(name);
++++
+++         if (lock->lk_name == NULL) {
+++                 kfree(lock);
+++                 return NULL;
+++         }
+++-        
++++        //added by vasanth
++++        lock->lock_owner=NULL;
++++        lock->lock_wchan = wchan_create(lock->lk_name);
++++		if (lock->lock_wchan == NULL)
++++		{
++++			kfree(lock->lk_name);
++++			kfree(lock);
++++			return NULL;
++++		}
++++		spinlock_init(&lock->spn_lock);
++++
+++         // add stuff here as needed
+++-        
+++         return lock;
+++ }
+++ 
+++ void
+++ lock_destroy(struct lock *lock)
+++ {
++++
+++         KASSERT(lock != NULL);
++++        //added by vasanth
++++        //KASSERT(lock->lock_owner == NULL);
++++        spinlock_cleanup(&lock->spn_lock);
++++        wchan_destroy(lock->lock_wchan);
+++ 
+++         // add stuff here as needed
+++         
+++@@ -182,27 +195,61 @@ lock_destroy(struct lock *lock)
+++ void
+++ lock_acquire(struct lock *lock)
+++ {
++++		//added by vasanth
++++		KASSERT(lock != NULL);
++++		spinlock_acquire(&lock->spn_lock);
++++		while (lock->lock_owner!=NULL)
++++		{
++++			wchan_lock(lock->lock_wchan);
++++			spinlock_release(&lock->spn_lock);
++++			wchan_sleep(lock->lock_wchan);
++++			spinlock_acquire(&lock->spn_lock);
++++		}
++++		lock->lock_owner=curthread;
++++		spinlock_release(&lock->spn_lock);
+++         // Write this
+++ 
+++-        (void)lock;  // suppress warning until code gets written
++++       // (void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ void
+++ lock_release(struct lock *lock)
+++ {
+++-        // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
++++		//added by vasanth
++++ 		KASSERT(lock != NULL);
++++		spinlock_acquire(&lock->spn_lock);
++++		if(lock->lock_owner==curthread)
++++		{
++++			lock->lock_owner=NULL;
++++			wchan_wakeall(lock->lock_wchan);
++++		}
++++		spinlock_release(&lock->spn_lock);
++++		// Write this
++++
++++
++++        //(void)lock;  // suppress warning until code gets written
+++ }
+++ 
+++ bool
+++ lock_do_i_hold(struct lock *lock)
+++ {
+++         // Write this
+++-
+++-        (void)lock;  // suppress warning until code gets written
+++-
+++-        return true; // dummy until code gets written
++++	bool status;
++++		spinlock_acquire(&lock->spn_lock);
++++		if (lock->lock_owner==curthread)
++++		{
++++			status = true;
++++		}
++++		else
++++		{
++++			status = false;
++++		}
++++		spinlock_release(&lock->spn_lock);
++++		return status;
++++
++++        //(void)lock;  // suppress warning until code gets written
++++
++++        //return true; // dummy until code gets written
+++ }
+++ 
+++ ////////////////////////////////////////////////////////////
+++@@ -217,26 +264,36 @@ cv_create(const char *name)
+++ 
+++         cv = kmalloc(sizeof(struct cv));
+++         if (cv == NULL) {
+++-                return NULL;
++++        	return NULL;
+++         }
+++ 
+++         cv->cv_name = kstrdup(name);
+++         if (cv->cv_name==NULL) {
+++-                kfree(cv);
+++-                return NULL;
++++            kfree(cv);
++++            return NULL;
+++         }
+++         
+++         // add stuff here as needed
++++        /* Added by Babu :
++++        * Adding a wait channel for making the threads wait during cv_acquire
++++        */
++++        cv->cv_waitchan = wchan_create(cv->cv_name);
++++
+++         
+++         return cv;
+++ }
+++ 
++++
+++ void
+++ cv_destroy(struct cv *cv)
+++ {
+++         KASSERT(cv != NULL);
+++ 
+++         // add stuff here as needed
++++        /*
++++         * Added by Babu : wchan destructor
++++         */
++++        wchan_destroy(cv->cv_waitchan);
+++         
+++         kfree(cv->cv_name);
+++         kfree(cv);
+++@@ -245,23 +302,180 @@ cv_destroy(struct cv *cv)
+++ void
+++ cv_wait(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-        (void)cv;    // suppress warning until code gets written
+++-        (void)lock;  // suppress warning until code gets written
++++    // Write this
++++	/** Release lock, wait and then acquire once awake */
++++	KASSERT(cv != NULL);
++++	KASSERT(lock != NULL);
++++
++++	//kprintf("Waiting in CV\n");
++++
++++	if(lock_do_i_hold(lock))
++++		lock_release(lock);
++++
++++	//kprintf("Sleeping in CV\n");
++++	wchan_lock(cv->cv_waitchan);
++++	wchan_sleep(cv->cv_waitchan);
++++
++++	//kprintf("Came out of CV\n");
++++
++++	if(!lock_do_i_hold(lock))
++++		lock_acquire(lock);
+++ }
+++ 
+++ void
+++ cv_signal(struct cv *cv, struct lock *lock)
+++ {
+++-        // Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++    // Write this
++++	KASSERT(cv != NULL);
++++	KASSERT(lock != NULL);
++++
++++	/*if(!lock_do_i_hold(lock))
++++		lock_acquire(lock);*/
++++
++++	/*if(lock_do_i_hold(lock))
++++		lock_release(lock);*/
++++
++++	//kprintf("Signaling CV\n");
++++
++++	wchan_wakeone(cv->cv_waitchan);
++++	//wchan_unlock(cv->cv_waitchan);
++++
++++	/*if(!lock_do_i_hold(lock))
++++		lock_acquire(lock);*/
++++	(void) lock;
+++ }
+++ 
+++ void
+++ cv_broadcast(struct cv *cv, struct lock *lock)
+++ {
+++ 	// Write this
+++-	(void)cv;    // suppress warning until code gets written
+++-	(void)lock;  // suppress warning until code gets written
++++	KASSERT(cv != NULL);
++++	KASSERT(lock != NULL);
++++
++++	/*if(!lock_do_i_hold(lock))
++++		lock_acquire(lock);*/
++++
++++	/*if(lock_do_i_hold(lock))
++++		lock_release(lock);*/
++++
++++	//kprintf("Broadcasting CV\n");
++++	wchan_wakeall(cv->cv_waitchan);
++++
++++
++++	/*if(!lock_do_i_hold(lock))
++++		lock_acquire(lock);*/
++++
++++
++++	(void) lock;
++++}
++++
++++struct rwlock *
++++rwlock_create(const char *name)
++++{
++++	struct rwlock *rwlock;
++++	rwlock = kmalloc(sizeof(struct rwlock));
++++	if (rwlock == NULL)
++++	{
++++		return NULL;
++++	}
++++	rwlock->rwlock_name=kstrdup(name);
++++	if (rwlock->rwlock_name == NULL)
++++	{
++++	    kfree(rwlock);
++++	    return NULL;
++++	}
++++	rwlock->rlock_wchan = wchan_create(rwlock->rwlock_name);
++++	if (rwlock->rlock_wchan == NULL)
++++	{
++++		kfree(rwlock->rwlock_name);
++++		kfree(rwlock);
++++		return NULL;
++++	}
++++	rwlock->wlock_wchan = wchan_create(rwlock->rwlock_name);
++++	if (rwlock->wlock_wchan == NULL)
++++	{
++++		kfree(rwlock->rwlock_name);
++++		wchan_destroy(rwlock->rlock_wchan);
++++		kfree(rwlock);
++++		return NULL;
++++	}
++++	rwlock->num_reader=0;
++++	rwlock->num_writer=0;
++++	rwlock->rw_lock = lock_create(rwlock->rwlock_name);
++++	if (rwlock->rw_lock == NULL)
++++	{
++++		kfree(rwlock->rwlock_name);
++++		wchan_destroy(rwlock->rlock_wchan);
++++		wchan_destroy(rwlock->wlock_wchan);
++++		kfree(rwlock);
++++		return NULL;
++++	}
++++	return rwlock;
++++
++++}
++++void
++++rwlock_destroy(struct rwlock *rwlock)
++++{
++++	KASSERT(rwlock != NULL);
++++	lock_destroy(rwlock->rw_lock);
++++	wchan_destroy(rwlock->rlock_wchan);
++++	wchan_destroy(rwlock->wlock_wchan);
++++	kfree(rwlock->rwlock_name);
++++	kfree(rwlock);
++++}
++++
++++void
++++rwlock_acquire_read(struct rwlock *rwlock)
++++{
++++	KASSERT(rwlock != NULL);
++++	lock_acquire(rwlock->rw_lock);
++++	while (rwlock->num_writer>0)
++++	{
++++		wchan_lock(rwlock->rlock_wchan);
++++		lock_release(rwlock->rw_lock);
++++		wchan_sleep(rwlock->rlock_wchan);
++++		lock_acquire(rwlock->rw_lock);
++++	}
++++	rwlock->num_reader++;
++++	lock_release(rwlock->rw_lock);
++++}
++++void
++++rwlock_release_read(struct rwlock *rwlock)
++++{
++++	KASSERT(rwlock != NULL);
++++	KASSERT(rwlock->num_reader > 0);
++++	lock_acquire(rwlock->rw_lock);
++++	if(rwlock->num_reader > 0)
++++	{
++++		rwlock->num_reader--;
++++	}
++++	wchan_wakeall(rwlock->wlock_wchan);
++++	wchan_wakeall(rwlock->rlock_wchan);
++++	lock_release(rwlock->rw_lock);
++++}
++++void
++++rwlock_acquire_write(struct rwlock *rwlock)
++++{
++++	KASSERT(rwlock != NULL);
++++	lock_acquire(rwlock->rw_lock);
++++	while ((rwlock->num_reader>0) || (rwlock->num_writer > 0))
++++	{
++++		wchan_lock(rwlock->wlock_wchan);
++++		lock_release(rwlock->rw_lock);
++++		wchan_sleep(rwlock->wlock_wchan);
++++		lock_acquire(rwlock->rw_lock);
++++	}
++++	rwlock->num_writer++;
++++	lock_release(rwlock->rw_lock);
++++}
++++void
++++rwlock_release_write(struct rwlock *rwlock)
++++{
++++	KASSERT(rwlock != NULL);
++++	KASSERT(rwlock->num_writer > 0);
++++	lock_acquire(rwlock->rw_lock);
++++	rwlock->num_writer--;
++++	wchan_wakeall(rwlock->rlock_wchan);
++++	wchan_wakeall(rwlock->wlock_wchan);
++++	lock_release(rwlock->rw_lock);
+++ }
+++diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+++index e7235e3..b1dcc73 100644
+++--- a/kern/thread/thread.c
++++++ b/kern/thread/thread.c
+++@@ -47,6 +47,7 @@
+++ #include <addrspace.h>
+++ #include <mainbus.h>
+++ #include <vnode.h>
++++#include <limits.h>
+++ 
+++ #include "opt-synchprobs.h"
+++ #include "opt-defaultscheduler.h"
+++@@ -153,6 +154,19 @@ thread_create(const char *name)
+++ 	thread->t_cwd = NULL;
+++ 
+++ 	/* If you add to struct thread, be sure to initialize here */
++++	/*File descriptor*/
++++		int i;
++++		for (i=0;i<OPEN_MAX;i++)
++++		{
++++			thread->ft[i] = kmalloc(sizeof(struct file_table *));
++++			if (thread->ft[i] == NULL)
++++					{
++++						kfree(thread);
++++						return NULL;
++++					}
++++			thread->ft[i]=0;
++++		}
++++		thread->priority = 5;
+++ 
+++ 	return thread;
+++ }
+++@@ -263,6 +277,7 @@ thread_destroy(struct thread *thread)
+++ 	thread->t_wchan_name = "DESTROYED";
+++ 
+++ 	kfree(thread->t_name);
++++	//if(thread->ft!=NULL)kfree(thread->ft);
+++ 	kfree(thread);
+++ }
+++ 
+++@@ -483,7 +498,6 @@ thread_fork(const char *name,
+++ 	    struct thread **ret)
+++ {
+++ 	struct thread *newthread;
+++-
+++ 	newthread = thread_create(name);
+++ 	if (newthread == NULL) {
+++ 		return ENOMEM;
+++@@ -520,6 +534,8 @@ thread_fork(const char *name,
+++ 	 */
+++ 	newthread->t_iplhigh_count++;
+++ 
++++	//Might have to add the copy of the file table --vasanth
++++
+++ 	/* Set up the switchframe so entrypoint() gets called */
+++ 	switchframe_init(newthread, entrypoint, data1, data2);
+++ 
+++@@ -574,6 +590,11 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 
+++ 	/* Check the stack guard band. */
+++ 	thread_checkstack(cur);
++++	if ( cur->priority > 0 && cur->priority< 10)
++++	{
++++		if (newstate == S_SLEEP)cur->priority--;     //increment priority if thread was sleeping
++++		if (newstate == S_READY)cur->priority++;     //decrement priority if thread was ready
++++	}
+++ 
+++ 	/* Lock the run queue. */
+++ 	spinlock_acquire(&curcpu->c_runqueue_lock);
+++@@ -585,6 +606,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+++ 		return;
+++ 	}
+++ 
++++
+++ 	/* Put the thread in the right place. */
+++ 	switch (newstate) {
+++ 	    case S_
++\ No newline at end of file
++diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
++index b807ff6..7776818 100644
++--- a/user/testbin/fileonlytest/fileonlytest.c
+++++ b/user/testbin/fileonlytest/fileonlytest.c
++@@ -83,6 +83,7 @@ main(int argc, char **argv)
++ 			writebuf[j] = i * 2 * j;
++ 		}
++ 		len = write(fh, writebuf, sizeof(writebuf));
+++		printf("Written %d bytes.\n",len);
++ 		if (len != sizeof(writebuf)) {
++ 			err(1, "write failed");
++ 		}
+diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
+index b807ff6..d43b0fc 100644
+--- a/user/testbin/fileonlytest/fileonlytest.c
++++ b/user/testbin/fileonlytest/fileonlytest.c
+@@ -83,6 +83,7 @@ main(int argc, char **argv)
+ 			writebuf[j] = i * 2 * j;
+ 		}
+ 		len = write(fh, writebuf, sizeof(writebuf));
++		printf("Written %d bytes.\n",len);
+ 		if (len != sizeof(writebuf)) {
+ 			err(1, "write failed");
+ 		}
+@@ -159,7 +160,7 @@ main(int argc, char **argv)
+ 	}
+ 		
+ 	// 23 Mar 2012 : GWA : FIXME : Spin until exit() works.
+-	
++	exit(0);
+ 	printf("Spinning in case exit() doesn't work.\n");
+ 	while (1) {};
+ 
+diff --git a/user/testbin/sysexittest/Makefile b/user/testbin/sysexittest/Makefile
+new file mode 100644
+index 0000000..0f4e2be
+--- /dev/null
++++ b/user/testbin/sysexittest/Makefile
+@@ -0,0 +1,11 @@
++# Makefile for forktest
++
++TOP=../../..
++.include "$(TOP)/mk/os161.config.mk"
++
++PROG=sysexittest
++SRCS=sysexittest.c
++BINDIR=/testbin
++
++.include "$(TOP)/mk/os161.prog.mk"
++
+diff --git a/user/testbin/sysexittest/sysexittest.c b/user/testbin/sysexittest/sysexittest.c
+new file mode 100644
+index 0000000..0dcb72e
+--- /dev/null
++++ b/user/testbin/sysexittest/sysexittest.c
+@@ -0,0 +1,34 @@
++
++/*
++ * forktest - test fork().
++ *
++ * This should work correctly when fork is implemented.
++ *
++ * It should also continue to work after subsequent assignments, most
++ * notably after implementing the virtual memory system.
++ */
++
++#include <unistd.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdio.h>
++#include <err.h>
++
++
++int
++main()
++{
++	//printf("entering sysexit test");
++	int pid = fork();
++	if(pid == 0)
++	{
++		warnx("child thread");
++	}
++	else
++	{
++		warnx("parent thread");
++	}			
++	warnx(" fork pid : %d \n", pid);
++	exit(0);
++	return 0;
++}
diff --git a/user/bin/sh/sh.c b/user/bin/sh/sh.c
index 3907571..44a795b 100644
--- a/user/bin/sh/sh.c
+++ b/user/bin/sh/sh.c
@@ -362,6 +362,7 @@ docommand(char *buf)
 			return _MKWAIT_EXIT(255);
 		case 0:
 			/* child */
+			warn("args[0] : %s and args %s, %s, %s\n", args[0], args[1], args[2], args[3]);
 			execv(args[0], args);
 			warn("%s", args[0]);
 			/*
diff --git a/user/lib/libc/.deptmp b/user/lib/libc/.deptmp
new file mode 100644
index 0000000..e69de29
diff --git a/user/testbin/argtest/argtest.c b/user/testbin/argtest/argtest.c
index 7ed552e..3b5782b 100644
--- a/user/testbin/argtest/argtest.c
+++ b/user/testbin/argtest/argtest.c
@@ -43,8 +43,8 @@ main(int argc, char *argv[])
 	const char *tmp;
 	int i;
 
-	printf("argc: %d\n", argc);
-
+	//printf("argc: %d\n", argc);
+	//printf("address arg[0] %x",*(unsigned int *)argv);
 	for (i=0; i<=argc; i++) {
 		tmp = argv[i];
 		if (tmp==NULL) {
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..d43b0fc 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -83,6 +83,7 @@ main(int argc, char **argv)
 			writebuf[j] = i * 2 * j;
 		}
 		len = write(fh, writebuf, sizeof(writebuf));
+		printf("Written %d bytes.\n",len);
 		if (len != sizeof(writebuf)) {
 			err(1, "write failed");
 		}
@@ -159,7 +160,7 @@ main(int argc, char **argv)
 	}
 		
 	// 23 Mar 2012 : GWA : FIXME : Spin until exit() works.
-	
+	exit(0);
 	printf("Spinning in case exit() doesn't work.\n");
 	while (1) {};
 
diff --git a/user/testbin/sysexittest/Makefile b/user/testbin/sysexittest/Makefile
new file mode 100644
index 0000000..0f4e2be
--- /dev/null
+++ b/user/testbin/sysexittest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for forktest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=sysexittest
+SRCS=sysexittest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/sysexittest/sysexittest.c b/user/testbin/sysexittest/sysexittest.c
new file mode 100644
index 0000000..d0be429
--- /dev/null
+++ b/user/testbin/sysexittest/sysexittest.c
@@ -0,0 +1,34 @@
+
+/*
+ * forktest - test fork().
+ *
+ * This should work correctly when fork is implemented.
+ *
+ * It should also continue to work after subsequent assignments, most
+ * notably after implementing the virtual memory system.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+
+
+int
+main()
+{
+	//printf("entering sysexit test");
+	//int pid = fork();
+	//if(pid == 0)
+	//{
+	//	warnx("child thread");
+	//}
+	//else
+	//{
+	//	warnx("parent thread");
+	//}			
+	//warnx(" fork pid : %d \n", pid);
+	exit(0);
+	return 0;
+}
